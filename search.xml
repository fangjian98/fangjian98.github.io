<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/article/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Github Pages+Hexo搭建个人博客及其主题优化</title>
    <url>/article/84ebc250.html</url>
    <content><![CDATA[<blockquote>
<p>通过Github搭建个人博客blog：GitHub Pages是一个静态站点托管服务，可直接从GitHub上的存储库获取HTML，CSS和JavaScript文件，还可以选择在构建过程中运行这些文件并发布网站。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<a id="more"></a>

<h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><ul>
<li>github pages</li>
<li>node.js</li>
<li>hexo</li>
</ul>
<h2 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h2><ul>
<li>下载地址</li>
</ul>
<p><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<ul>
<li>测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装成功测试cmd</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h2 id="hexo安装与配置"><a href="#hexo安装与配置" class="headerlink" title="hexo安装与配置"></a>hexo安装与配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cmd切换到blog文件夹下，输入安装hexo命令</span><br><span class="line">npm install hexo -g</span><br><span class="line"></span><br><span class="line"># 安装成功测试</span><br><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line"># hexo初始化</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"># 安装必要的组件</span><br><span class="line">npm isntall</span><br><span class="line"></span><br><span class="line"># 开启服务器</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"># 显示本地博客地址，复制位置到浏览器打开后显示</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"># 如果无法显示网页,说明端口可能被占用,更改端口便可</span><br><span class="line">hexo server -p 4001</span><br></pre></td></tr></table></figure>

<h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><ul>
<li>下载地址</li>
</ul>
<p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<ul>
<li>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成rsa命令</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;test@hotmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加密钥到ssh-agent</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line"><span class="comment"># 添加生成的SSH key到ssh-agent</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将id_rsa.pub文件里的内容复制到add SSH keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否成功</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>再blog文件夹中找到_config.yml文件，修改repo值(末尾)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:test/test.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h2 id="创建新博客"><a href="#创建新博客" class="headerlink" title="创建新博客"></a>创建新博客</h2><ul>
<li>流程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建博客</span></span><br><span class="line">hexo new <span class="string">&quot;blog name&quot;</span></span><br><span class="line"><span class="comment"># 博客生成</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 博客部署</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 博客生成+部署</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<ul>
<li>默认生成的post</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: blog name</span><br><span class="line">date: 2022-05-05 22:51:03</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure>

<ul>
<li>关于post其他标签</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>文章的文件名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
<tr>
<td>keywords</td>
<td>仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: blog name</span><br><span class="line">date: 2022-05-05 22:51:03</span><br><span class="line">categories:</span><br><span class="line">	- 分类</span><br><span class="line">	- 子分类</span><br><span class="line">tags:</span><br><span class="line">	- 标签1</span><br><span class="line">	- 标签2</span><br></pre></td></tr></table></figure>


<ul>
<li>博客编辑器typora</li>
</ul>
<p><a href="https://www.typora.io/">https://www.typora.io/</a></p>
<ul>
<li>博客图片上传问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改_config.yml里的psot_asset_folder:设置为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd执行</span></span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line">(或npm install https://github.com/CodeFalling/hexo-asset-image --save)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用hexo new &quot;blog name&quot;新建博客时，_posts目录下会出现同名*.md和文件夹，图片放在此文件夹中</span></span><br><span class="line">![](本地图片测试/logo.jpg) </span><br></pre></td></tr></table></figure>



<h2 id="博客个性化设置"><a href="#博客个性化设置" class="headerlink" title="博客个性化设置"></a>博客个性化设置</h2><h3 id="下载hexo主题（自选主题模板）"><a href="#下载hexo主题（自选主题模板）" class="headerlink" title="下载hexo主题（自选主题模板）"></a>下载hexo主题（自选主题模板）</h3><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo//theme.jpg" alt="theme"></p>
<h3 id="下载next主题"><a href="#下载next主题" class="headerlink" title="下载next主题"></a>下载next主题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h3 id="修改-blog-config-yml"><a href="#修改-blog-config-yml" class="headerlink" title="修改./blog/_config.yml"></a>修改./blog/_config.yml</h3><ul>
<li>主题选择</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<ul>
<li>网页信息</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Just_Paranoid</span><br><span class="line">subtitle: 特立独行</span><br><span class="line">description: &#x27;&#x27;</span><br><span class="line">keywords: &#x27;&#x27;</span><br><span class="line">author: fangjian98</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="修改-blog-themes-next-config-yml"><a href="#修改-blog-themes-next-config-yml" class="headerlink" title="修改./blog/themes/next/_config.yml"></a>修改./blog/themes/next/_config.yml</h3><ul>
<li>选择主题样式<br>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新<br>Gemini - 左侧网站信息及目录，块+片段结构布局</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<ul>
<li>网站图标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># See: https://theme-next.org/docs/getting-started/</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure>

<p>ico图标下载：<a href="https://icons8.com/icons">https://icons8.com/icons</a>,</p>
<p>ico图标制作：<a href="http://www.bitbug.net/">http://www.bitbug.net/</a></p>
<ul>
<li>主页显示摘要</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line">excerpt_description: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button will be displayed in excerpt section.</span></span><br><span class="line">read_more_btn: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在文章中添加该标志，本文在首页的预览就会显示到这个段落为止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>头像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: #&#x2F;images&#x2F;avatar.gif</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>

<ul>
<li>社交链接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: &#96;Key: permalink || icon&#96;</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before &#96;||&#96; delimiter is the target permalink, value after &#96;||&#96; delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  #GitHub: https:&#x2F;&#x2F;github.com&#x2F;yourname || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || fab fa-weibo</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || fab fa-google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br></pre></td></tr></table></figure>

<ul>
<li>创建菜单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Usage: &#96;Key: &#x2F;link&#x2F; || icon&#96;</span><br><span class="line"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before &#96;||&#96; delimiter is the target link, value after &#96;||&#96; delimiter is the name of Font Awesome icon.</span><br><span class="line"># When running the site in a subdirectory (e.g. yoursite.com&#x2F;blog), remove the leading slash from link value (&#x2F;archives -&gt; archives).</span><br><span class="line"># External url should start with http:&#x2F;&#x2F; or https:&#x2F;&#x2F;</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  #categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line"># Enable &#x2F; Disable menu icons &#x2F; item badges.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: false</span><br></pre></td></tr></table></figure>

<ul>
<li>修改完主题后需要重新部署</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<ul>
<li>增加本地搜索</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo-generator-searchdb，在站点的根目录下执行以下命令</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根目录_config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置站点搜索信息</span></span><br><span class="line">search:</span><br><span class="line"> path: search.xml</span><br><span class="line"> field: post</span><br><span class="line"> format: html</span><br><span class="line"> <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改themes&#x2F;next&#x2F;_config.yml</span><br><span class="line"></span><br><span class="line">local_search:</span><br><span class="line"> enable: true</span><br></pre></td></tr></table></figure>

<ul>
<li>显示浏览进度</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  sidebar: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>RSS</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo-generator-feed</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加_config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># feed</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/hexojs/hexo-generator-feed</span></span><br><span class="line">feed:</span><br><span class="line">  <span class="built_in">type</span>: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  <span class="built_in">limit</span>: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br></pre></td></tr></table></figure>

<ul>
<li>不开启不蒜子博客访问量统计</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<ul>
<li>修改博文链接地址<code>/posts/xxxxx.html</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br><span class="line"></span><br><span class="line"># 根目录下的 _config.yml 文件</span><br><span class="line">permalink: posts&#x2F;:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>

<ul>
<li>首页title优化<code>网站名称-网站描述</code></li>
</ul>
<p>更改<code>index.swig</code>文件<code>your-hexo-site\themes\next\layout</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br><span class="line"># 改成</span><br><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>代码托管平台推荐</title>
    <url>/article/86025775.html</url>
    <content><![CDATA[<blockquote>
<p>Github、Gitee 这些开源场景的代码托管平台，他们对个人开发者友好，可以接触到很多优秀的开源项目。是很好的开源社区，统一的代码托管平台是DevOps的基础，也是管理代码的科学手段，为了方便各位程序员更好的选择代码托管平台，特此总结分享一下国内外代码托管平台。</p>
</blockquote>
<a id="more"></a>

<h3 id="Github-github-com"><a href="#Github-github-com" class="headerlink" title="Github - github.com"></a>Github - <a href="https://github.com/">github.com</a></h3><p>GitHub 代码托管平台，包含了全世界很多优秀的开源项目，可以从GitHub获取到很多很多优秀的开源项目来进行学习，也可以将自己的项目上传上去与他人分享。</p>
<p>GitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目Ruby on Rails、jQuery、python等。</p>
<p>2018年6月4日，微软宣布，通过75亿美元的股票交易收购代码托管平台GitHub。</p>
<p>作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</p>
<h3 id="Gitlab-gitlab-com"><a href="#Gitlab-gitlab-com" class="headerlink" title="Gitlab - gitlab.com"></a>Gitlab - <a href="https://gitlab.com/">gitlab.com</a></h3><p>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。安装方法是参考GitLab在GitHub上的Wiki页面。<br>2022年2月消息，极狐（GitLab）正式宣布推出极狐GitLab SaaS （JihuLab.com），为中国用户提供从源代码托管到开发运维的全栈式一体化DevOps SaaS平台与企业级专家咨询服务。</p>
<p>GitLab是由GitLabInc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。</p>
<p>应用特点：Web框架使用RubyonRails、基于MIT代码发布协议、需要gitolite协同工作。</p>
<h3 id="GitCode-gitcode-net"><a href="#GitCode-gitcode-net" class="headerlink" title="GitCode - gitcode.net"></a>GitCode - <a href="https://gitcode.net/">gitcode.net</a></h3><p>GitCode 是 CSDN 为开发者提供的开源项目创新服务平台，秉承“创新、开放、协作、共享”的开源价值观，致力于为大规模开源开放协同创新助力赋能，打造创新成果孵化和新时代开发者培养的开源创新生态！支持公有云使用、私有化部署以及软硬一体化私有部署。</p>
<p>一亿人的安全代码仓，源码级别的安全分析 &amp; 协议分析平台。</p>
<h3 id="Coding-coding-net"><a href="#Coding-coding-net" class="headerlink" title="Coding - coding.net"></a>Coding - <a href="https://coding.net/">coding.net</a></h3><p>CODING 是一个面向软件研发团队的研发协作管理平台，提供云原生开发环境、在线编码、代码托管、项目管理、测试管理、持续集成、制品库、持续部署、团队知识库等系列工具产品，帮助研发团队实践敏捷开发与 DevOps。</p>
<p>CODING 成立于 2014 年 2 月，于 2019 年被腾讯收购成为其全资子公司，作为腾讯云官方 DevOps 平台工具向广大开发者及企业研发团队提供服务，支持 SaaS 模式或私有部署模式。</p>
<p>产品优势：一站式研发工具、开箱即用，免部署、节省研发工具建设成本、提高软件交付效率。</p>
<h3 id="Bitbicket-bitbucket-org"><a href="#Bitbicket-bitbucket-org" class="headerlink" title="Bitbicket - bitbucket.org"></a>Bitbicket - <a href="https://bitbucket.org/">bitbucket.org</a></h3><p>BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。</p>
<p>特点：无限制的私有仓库个数、无限制的磁盘空间、同时支持https/ssh、Bug 跟踪、项目Wiki、API 支持、灵活的权限控制、可自定义域名、RSS 修改记录输出、自定义下载等。</p>
<h3 id="托管平台对比"><a href="#托管平台对比" class="headerlink" title="托管平台对比"></a>托管平台对比</h3><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/code_hosting_platform.png"></p>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Gitee</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git忽略文件.gitignore</title>
    <url>/article/d04701bd.html</url>
    <content><![CDATA[<blockquote>
<p>在工程中，并不是所有文件都需要保存到版本库中的，例如“target”目录及目录下的文件就可以忽略。在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件或目录。</p>
</blockquote>
<a id="more"></a>

<h3 id="Git-忽略规则优先级"><a href="#Git-忽略规则优先级" class="headerlink" title="Git 忽略规则优先级"></a>Git 忽略规则优先级</h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p>
<ol>
<li>从命令行中读取可用的忽略规则</li>
<li>当前目录定义的规则</li>
<li>父级目录定义的规则，依次递推</li>
<li>$GIT_DIR/info/exclude 文件中定义的规则</li>
<li>core.excludesfile中定义的全局规则</li>
</ol>
<h3 id="Git-忽略规则匹配语法"><a href="#Git-忽略规则匹配语法" class="headerlink" title="Git 忽略规则匹配语法"></a>Git 忽略规则匹配语法</h3><p>在 .gitignore 文件中，每一行的忽略规则的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 空格不匹配任意文件，可作为分隔符，可用反斜杠转义</span><br><span class="line">* 开头的文件标识注释，可以使用反斜杠进行转义</span><br><span class="line">* ! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义</span><br><span class="line">* &#x2F; 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件</span><br><span class="line">* &#x2F; 开始的模式匹配项目跟目录</span><br><span class="line">* 如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录</span><br><span class="line">* ** 匹配多级目录，可在开始，中间，结束</span><br><span class="line">* ? 通用匹配单个字符</span><br><span class="line">* * 通用匹配零个或多个字符</span><br><span class="line">* [] 通用匹配单个字符列表</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<h3 id="常用匹配示例"><a href="#常用匹配示例" class="headerlink" title="常用匹配示例"></a>常用匹配示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">&#x2F;bin: 忽略根目录下的bin文件</span><br><span class="line">&#x2F;*.c: 忽略 cat.c，不忽略 build&#x2F;cat.c</span><br><span class="line">debug&#x2F;*.obj: 忽略 debug&#x2F;io.obj，不忽略 debug&#x2F;common&#x2F;io.obj 和 tools&#x2F;debug&#x2F;io.obj</span><br><span class="line">**&#x2F;foo: 忽略&#x2F;foo, a&#x2F;foo, a&#x2F;b&#x2F;foo等</span><br><span class="line">a&#x2F;**&#x2F;b: 忽略a&#x2F;b, a&#x2F;x&#x2F;b, a&#x2F;x&#x2F;y&#x2F;b等</span><br><span class="line">!&#x2F;bin&#x2F;run.sh: 不忽略 bin 目录下的 run.sh 文件</span><br><span class="line">*.log: 忽略所有 .log 文件</span><br><span class="line">config.php: 忽略当前路径的 config.php 文件</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<h3 id="gitignore规则不生效"><a href="#gitignore规则不生效" class="headerlink" title=".gitignore规则不生效"></a>.gitignore规则不生效</h3><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。</p>
<p>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;update .gitignore&#39;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h3 id="Android-APK项目参考-gitignore"><a href="#Android-APK项目参考-gitignore" class="headerlink" title="Android APK项目参考.gitignore"></a>Android APK项目参考<code>.gitignore</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># built application files</span><br><span class="line">*.apk</span><br><span class="line">*.ap_</span><br><span class="line"></span><br><span class="line"># files for the dex VM</span><br><span class="line">*.dex</span><br><span class="line"></span><br><span class="line"># Java class files</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># generated files</span><br><span class="line">bin&#x2F;</span><br><span class="line">gen&#x2F;</span><br><span class="line"></span><br><span class="line"># Ignore gradle files</span><br><span class="line">.gradle&#x2F;</span><br><span class="line">build&#x2F;</span><br><span class="line"></span><br><span class="line"># Local configuration file (sdk path, etc)</span><br><span class="line">local.properties</span><br><span class="line"></span><br><span class="line"># Proguard folder generated by Eclipse</span><br><span class="line">proguard&#x2F;</span><br><span class="line">proguard-project.txt</span><br><span class="line"></span><br><span class="line"># Eclipse files</span><br><span class="line">.project</span><br><span class="line">.classpath</span><br><span class="line">.settings&#x2F;</span><br><span class="line"></span><br><span class="line"># Android Studio&#x2F;IDEA</span><br><span class="line">*.iml</span><br><span class="line">.idea</span><br><span class="line"></span><br><span class="line"># Mac specific ignore</span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p><code>.gitignore</code>文件要在文件提交之前设置才有效，如果文件已经提交，需要先把仓库里面的文件删除掉。如果module目录下的文件颜色没有改变，则选中.gitignore文件右击鼠标选择Git-&gt;+Add颜色变为浅绿色。</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title>关于图床的使用</title>
    <url>/article/91cd0b89.html</url>
    <content><![CDATA[<blockquote>
<p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p>
</blockquote>
<a id="more"></a>

<h3 id="图床意义"><a href="#图床意义" class="headerlink" title="图床意义"></a>图床意义</h3><p>图床就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。图床相当于在网络上存储图片的地方，可以节约本地资源，图片可以多次引用。我最早接触的图床是<a href="https://sm.ms/">sm.ms</a>，后来需要登录才可以使用了，其实CSDN写文章插入图片也可以使用作为图床使用。</p>
<h3 id="使用托管平台图床"><a href="#使用托管平台图床" class="headerlink" title="使用托管平台图床"></a>使用托管平台图床</h3><h4 id="1-Github"><a href="#1-Github" class="headerlink" title="1.Github"></a>1.Github</h4><p>Github作为图床可以使用，但是速度太慢，可以使用 <a href="https://www.jsdelivr.com/">jsDeliver</a> 加速。</p>
<p>Github原生格式：(目前无法直接访问，需要科学上网)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;&#123;UserName&#125;&#x2F;&#123;Repo&#125;&#x2F;&#123;Branch&#125;&#x2F;&#123;Images Path&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;fangjian98&#x2F;fangjian98.github.io&#x2F;hexo&#x2F;source&#x2F;images&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>

<p>jsDeliver加速格式参考:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;&#123;UserName&#125;&#x2F;&#123;Repo&#125;@&#123;Branch&#125;&#x2F;&#123;Images Path&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;fangjian98&#x2F;fangjian98.github.io@hexo&#x2F;source&#x2F;images&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>

<h4 id="2-Gitee"><a href="#2-Gitee" class="headerlink" title="2.Gitee"></a>2.Gitee</h4><p>Gitee相当于是Github的中国版，国内访问速度很快。</p>
<p>Gitee格式参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;&#123;UserName&#125;&#x2F;&#123;Repo&#125;&#x2F;raw&#x2F;&#123;Branch&#125;&#x2F;&#123;Images Path&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;fangjian98&#x2F;imagespace&#x2F;raw&#x2F;master&#x2F;img19.jpg</span><br></pre></td></tr></table></figure>

<h4 id="3-GitCode"><a href="#3-GitCode" class="headerlink" title="3.GitCode"></a>3.GitCode</h4><p>Gitcode原来叫CodeChina，好像是CSDN出品的项目托管平台，速度也很快。我目前正在使用的就是GitCode图床。</p>
<p>GitCode格式参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;gitcode.net&#x2F;&#123;UserName&#125;&#x2F;&#123;Repi&#125;&#x2F;-&#x2F;raw&#x2F;&#123;Branch&#125;&#x2F;&#123;Images Path&#125;</span><br></pre></td></tr></table></figure>

<p> 示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;gitcode.net&#x2F;weixin_44008788&#x2F;images&#x2F;-&#x2F;raw&#x2F;master&#x2F;gitcode.png</span><br></pre></td></tr></table></figure>

<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/gitcode.png" alt="GitCode"></p>
<h3 id="图床管理工具"><a href="#图床管理工具" class="headerlink" title="图床管理工具"></a>图床管理工具</h3><p>该类工具可以可视化的直接复制图片链接，不必要在纠结在格式链接上了。</p>
<ul>
<li><strong>PicGO</strong> -  一个用于快速上传图片并获取图片 URL 链接的工具，需要下载客户端</li>
</ul>
<p>发行版下载：<a href="https://github.com/Molunerfinn/PicGo/releases/">Molunerfinn/PicGo/releases</a></p>
<p>开源地址：<a href="https://github.com/Molunerfinn/PicGo">Molunerfinn/PicGo</a></p>
<ul>
<li><strong>PicX</strong> - 是一款基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床工具，在线操作即可，无需下载和安装</li>
</ul>
<p>在线地址：<a href="https://picx.xpoet.cn/">picx.xpoet.cn</a></p>
<p>开源地址：<a href="https://github.com/XPoet/picx">XPoet/picx</a></p>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Image Hosting Service</tag>
        <tag>PicGO</tag>
      </tags>
  </entry>
  <entry>
    <title>Github的神级操作</title>
    <url>/article/33799c4b.html</url>
    <content><![CDATA[<blockquote>
<p>GitHub是面向开源及私有软件项目的托管平台，其流行及在开源世界的受欢迎程度自不必多言，但是关于Github的使用你又知道多少呢？这里将介绍下Github的常用快捷键、高级搜索语法和在线查看且运行项目，还有Github的官方文档值得认真读读，可以学到很多有用的点。</p>
</blockquote>
<a id="more"></a>

<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>聚焦于搜索栏：<kbd>S</kbd></p>
<p>激活文件查找器：<kbd>T</kbd></p>
<p>跳至代码中的某一行：<kbd>L</kbd></p>
<p>打开追溯视图：<kbd>B</kbd></p>
<p>在线VSCode查看：<kbd>。</kbd></p>
<p>打开命令面板：<kbd>Ctrl</kbd> + <kbd>K</kbd></p>
<p>查看帮助：<kbd>Shift</kbd> + <kbd>?</kbd></p>
<p>更多快捷键查看：<a href="https://docs.github.com/cn/get-started/using-github/keyboard-shortcuts">Keyboard shortcuts</a></p>
<h3 id="关于搜索"><a href="#关于搜索" class="headerlink" title="关于搜索"></a>关于搜索</h3><p>高级搜索面板：<a href="https://github.com/search/advanced">Advanced search</a></p>
<p>常用搜索语法：</p>
<table>
<thead>
<tr>
<th>搜索条件 - 找开发者</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>location:</td>
<td>location:china，匹配用户填写的地址在china</td>
</tr>
<tr>
<td>language</td>
<td>language:javascript，匹配开发语音为javascript的开发者</td>
</tr>
<tr>
<td>followers:</td>
<td>followers:&gt;=1000，匹配超过1000关注者的开发者</td>
</tr>
<tr>
<td>in:fullname</td>
<td>jack in:fullname，匹配用户名实名为jack的开发者</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>搜索条件 - 找项目</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Awesome+关键字</td>
<td>神奇的关键字awesome，帮助找到优秀的工具列表</td>
</tr>
<tr>
<td>stars:</td>
<td>stars:&gt;=500</td>
</tr>
<tr>
<td>language:</td>
<td>language:javascript</td>
</tr>
<tr>
<td>forks:</td>
<td>forks:&gt;=500</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>搜索条件 - 找开发者</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>in:name xxx</td>
<td>项目名包含xxx</td>
</tr>
<tr>
<td>in:description xxx</td>
<td>项目描述包含xxx</td>
</tr>
<tr>
<td>in:readme xxx</td>
<td>项目介绍文档里含有xxx</td>
</tr>
</tbody></table>
<p>更多搜索相关：<a href="https://docs.github.com/cn/search-github/getting-started-with-searching-on-github/about-searching-on-github">About searching on GitHub</a></p>
<h3 id="在线运行Github项目"><a href="#在线运行Github项目" class="headerlink" title="在线运行Github项目"></a>在线运行Github项目</h3><p>再Github项目仓库前加上：<code>gitpod.io/#/</code>即可在线打开项目，并且支持在线运行该项目，相当于拥有一台可操作的远程服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如原仓库</span></span><br><span class="line">https://github.com/ant-design/ant-design-pro</span><br><span class="line"><span class="comment"># 添加前缀</span></span><br><span class="line">https://gitpod.io/<span class="comment">#/github.com/ant-design/ant-design-pro</span></span><br><span class="line"><span class="comment"># 即可在线查看项目和运行</span></span><br></pre></td></tr></table></figure>

<p>关于<a href="https://www.gitpod.io/">Gitpod</a>，这是一个与GitHub紧密集成的云IDE，Gitpod为开发人员的GitHub项目提供了一次性的，可随时编程的开发环境。</p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git初始化配置</title>
    <url>/article/66ea434c.html</url>
    <content><![CDATA[<blockquote>
<p>我们推荐创建的Git仓库都包含一个<code>README</code>、<code>LICENSE</code>和<code>.gitignore</code>，这里将学习创建本地分支、远程仓库推送和修改远程仓库Url。</p>
</blockquote>
<a id="more"></a>


<h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;# gitblog&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:fangjian98&#x2F;gitblog.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="推送本地仓库"><a href="#推送本地仓库" class="headerlink" title="推送本地仓库"></a>推送本地仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:fangjian98&#x2F;gitblog.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="更新本地仓库-Remote-Url"><a href="#更新本地仓库-Remote-Url" class="headerlink" title="更新本地仓库 Remote Url"></a>更新本地仓库 Remote Url</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote remove origin</span><br><span class="line">git remote add origin https://gitcode.net/xxxx.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者是使用 SSH 地址</span></span><br><span class="line">git remote add origin git@gitcode.net:xxxx.git</span><br></pre></td></tr></table></figure>

<h3 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除仓库索引</span></span><br><span class="line"><span class="comment"># 如果是文件</span></span><br><span class="line">git rm --cached reference/esp-qcloud</span><br><span class="line"><span class="comment"># 如果是文件夹</span></span><br><span class="line">git rm -r --cached reference/esp-qcloud</span><br><span class="line"><span class="comment"># 如果执行以上命令后提示：[error: 如下文件其暂存的内容和工作区及 HEAD 中的都不一样：] ，`-f`强制删除</span></span><br><span class="line">git rm -r -f --cached reference/esp-qcloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加仓库索引</span></span><br><span class="line"><span class="comment"># 创建子模块并添加 url 地址</span></span><br><span class="line">git submodule add &lt;url&gt; project</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">git submodule add https://gitee.com/JavonPeng/project.git reference/esp-qcloud</span><br><span class="line"><span class="comment"># 或者使用 ssh 地址</span></span><br><span class="line">git submodule add git@gitee.com:JavonPeng/project.git reference/esp-qcloud</span><br><span class="line"></span><br><span class="line">添加成功后会生成.gitmodules文件，即添加子模块</span><br></pre></td></tr></table></figure>

<h3 id="查看仓库配置信息"><a href="#查看仓库配置信息" class="headerlink" title="查看仓库配置信息"></a>查看仓库配置信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS D:\CodeSpace\openAI&gt; cat .\.git\config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">false</span></span><br><span class="line">        bare = <span class="literal">false</span></span><br><span class="line">        logallrefupdates = <span class="literal">true</span></span><br><span class="line">        symlinks = <span class="literal">false</span></span><br><span class="line">        ignorecase = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:fangjian98/openAI.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">&quot;main&quot;</span>]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br><span class="line">[branch <span class="string">&quot;dev&quot;</span>]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/dev</span><br></pre></td></tr></table></figure>

<h3 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉去指定远程仓库分支到本地</span></span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置远程仓库分支</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看.git/config 对应分支</span></span><br><span class="line">[branch <span class="string">&quot;dev&quot;</span>]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令简写的配置</title>
    <url>/article/8b0e152.html</url>
    <content><![CDATA[<blockquote>
<p>在使用Git工具时，有些命令比较常用，为了加快输入速度，可以自定义一些简写配置，能提高我们提交代码的效率。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>编辑Git配置文件且显示配置文件路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global -e</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件<code> ~/.gitconfig</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">  name = xxxxx</span><br><span class="line">  email = xxxx@mail.com</span><br><span class="line">[core]</span><br><span class="line">  editor = vim</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    a = add</span><br><span class="line">    co = checkout</span><br><span class="line">    cm = commit</span><br><span class="line">    st = status</span><br><span class="line">    pl = pull</span><br><span class="line">    ps = push</span><br><span class="line">    df = diff</span><br><span class="line">    lg = <span class="built_in">log</span></span><br><span class="line">    cp = cherry-pick</span><br><span class="line">    ca = commit --amend</span><br><span class="line">    br = branch</span><br><span class="line">    mg = merge</span><br><span class="line">    dt = difftool</span><br><span class="line">    mt = mergetool</span><br><span class="line">    lo = <span class="built_in">log</span> --oneline</span><br><span class="line">    lg = <span class="built_in">log</span> --color --graph --pretty=format:<span class="string">&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit</span><br></pre></td></tr></table></figure>

<ul>
<li>查看Git配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Github的常用功能</title>
    <url>/article/f715120c.html</url>
    <content><![CDATA[<blockquote>
<p>Github 包含的功能点很多，你知道他们的作用是什么吗？改如何去使用这些功能呢？这里将列出常用的功能点，并描述其功能和什么时候去使用以及如何使用，当然你也可以查看Github的官方文档来了解和学习这些。</p>
</blockquote>
<a id="more"></a>

<h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ul>
<li>Issue</li>
</ul>
<blockquote>
<p>Issue的作用在于对开源项目提Bug者需求来不断完善开源社区，这对问题追踪是很重要的，可以对现有代码讨论和交流，也可以交流如何使用，还可以作为项目管理的规划Todo List，提交cmmit关联issue id等。Issue 在整个GitHub，谁都可以提问issue，谁都可以对issue问题进行回答。</p>
<p>1.Issue的Label功能：自己的仓库或者作者给权限的仓库才有右边这些选项，点进去选择相应label即可</p>
<p>2.Issue Title的格式规范：[Issue Type] Issue brife description</p>
<p>3.Issue 内容模板(可自定义)：&lt;1&gt;该问题是怎么引起的 &lt;2&gt;重现步骤 &lt;3&gt;报错信息</p>
<p>4.Issue 可以有额外的属性:</p>
<p>Labels，标签。包括 enhancement、bug、invalid 等，表示 Issue 的类型，解决的方式。除了自带的以外，也可以去自定义。</p>
<p>Milestone，里程碑。作为 Issue 的一个集合，通常用来表示项目的一个阶段，比如 demo、release 等，保护达成这些阶段需要解决的问题。有时候，也会与版本计划重合，比如 v1.0、v2.0 等。Issue 不能设置截止时间，但是 Milestone 可以。</p>
<p>Assignees，责任人。指定这个 Issue 由谁负责来解决。</p>
<p>充分利用这些功能，让每一个 commit 的意义更加明确，可以起到了良好的过程管理作用，使得这个 Git 库的项目进度更加显然。而且，这也是项目后期，写文档的绝佳素材。其实，GitHub 的 issue ，就是一个轻量级协作系统。它的 comment 支持 GitHub Flavored Markdown，可以进行内容丰富的交流。Git 本身就是分布式的代码版本控制软件，是为了程序员的协作而设计的。而 issue 的 Assignee 功能，就是这个在线协作系统的核心，足以让一群线上的开发者，一起完成一个软件项目。</p>
<p>5.使用 GitHub Issues 来写博客：<a href="https://github.com/yihong0618/gitblog">yihong0618/gitblog</a></p>
</blockquote>
<ul>
<li>Github commit关联Issue的小技巧</li>
</ul>
<blockquote>
<p>如果一个处于Open状态的Issue已经处理完毕，只要在该提交中以下列任意一种格式描述提交信息，但PR通过后对应的Issue就会被Close，示例：<code>git commit -m &quot;message title, fix #1&quot;</code>。一个commit message 可同时关联多个任务，示例：<code>fix #1 #2</code> ，不同issue_id之间需要空格隔开。</p>
<p>关键词：fix、fixes、fixed、close、closes、closed、resolve、resolves、resolved</p>
<p>借助issue进行问题的提出，将问题内容反馈给研发人员，研发人员根据issue内容进行针对性的修复，并将修复后的结果反馈给测试人员，该过程属于一个迭代过程，待测试人员确认无误后，可关闭issue。</p>
</blockquote>
<ul>
<li>Pull Requset</li>
</ul>
<blockquote>
<p>Pull Request简写为PR，中文译为拉取请求，是为github开源项目提交自己的代码。</p>
<p>第一次参与开源贡献代码流程参考：<a href="https://github.com/firstcontributions/first-contributions/blob/master/translations/README.chs.md">firstcontributions/first-contributions</a></p>
<ol>
<li>Fork代码仓库</li>
<li>Clone代码仓库</li>
<li>新建分支，修改代码，再Commit修改，Push到Github</li>
<li>提出Pull Request你的修改供项目拥有者审阅Review，待conform merge即可合入修改</li>
</ol>
</blockquote>
<ul>
<li>Fork</li>
</ul>
<blockquote>
<p>复制克隆，相当于复制某个开源项目成为自己的一个同名仓库</p>
</blockquote>
<ul>
<li>Stars</li>
</ul>
<blockquote>
<p>收藏，打开对应的项目主页，点击右上角star按钮即可收藏，在Your stars中查看个人收藏</p>
</blockquote>
<ul>
<li>Github Wiki</li>
<li>Github Release</li>
</ul>
<blockquote>
<p>GitHub Releases是向用户提供软件的方式，您可以创建包软件的发行版，以及发行说明和二进制文件链接，以供其他人使用。</p>
<p>1.Release发布步骤：</p>
<p>tag：v1.0.0</p>
<p>release title：ExploreGithub v1.0.0</p>
<p>describe this release：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Features</span><br><span class="line"></span><br><span class="line">- Add an integration library to support decoding AVIF ([&#96;3fd8e77&#96;](https:&#x2F;&#x2F;github.com&#x2F;bumptech&#x2F;glide&#x2F;commit&#x2F;3fd8e777e2be6a3fedc5f5c5f688970a212a285f), [&#96;f5e78ed&#96;]</span><br><span class="line"></span><br><span class="line">## Bugs</span><br><span class="line"></span><br><span class="line">- Fix memory leak caused by unusual activity&#x2F;fragment lifecycle interactions ([&#96;8bebf71&#96;](https:&#x2F;&#x2F;github.com&#x2F;bumptech&#x2F;glide&#x2F;commit&#x2F;8bebf71e80c2cd1f260d919e6b0697436da6e302))</span><br></pre></td></tr></table></figure>

<p>2.Release参考：</p>
<p><a href="https://github.com/meefik/linuxdeploy">https://github.com/meefik/linuxdeploy</a></p>
<p><a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></p>
</blockquote>
<ul>
<li>Github Discussions</li>
<li>Github Pages</li>
<li>Github Actions</li>
<li>Github REST API</li>
<li>License</li>
<li>关于仓库的gh-pages分支</li>
<li>如何提Issue</li>
<li>如何贡献Pull Request</li>
</ul>
<h2 id="隐藏技巧"><a href="#隐藏技巧" class="headerlink" title="隐藏技巧"></a>隐藏技巧</h2><ol>
<li><p>username同名仓库：</p>
<p>该仓库的<code>README.md</code>将直接显示再主页，可以作为自己的个人介绍详情页，有多种美化方式。</p>
</li>
<li><p>username.github.io仓库：</p>
<p>该仓库直接生成专属你的网站，地址为<code>username.github.io</code></p>
</li>
<li><p>Github Emoji</p>
</li>
</ol>
<blockquote>
<p>官方Emoji<br><a href="https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md">https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md</a></p>
<p>其他Emoji<br><a href="https://emoji.muan.co/">https://emoji.muan.co/</a><br><a href="https://gitmoji.dev/">https://gitmoji.dev/</a></p>
</blockquote>
<ol start="4">
<li><p>Github图标</p>
<p>Github主页图标：<a href="https://github.com/anuraghazra/github-readme-stats">https://github.com/anuraghazra/github-readme-stats</a></p>
<p>Github主页访问数：<a href="https://visitor-badge.laobi.icu/">https://visitor-badge.laobi.icu/</a></p>
<p>Github项目图标：<a href="https://shields.io/">https://shields.io/</a></p>
</li>
<li><p>Github在线编辑器</p>
<p>github项目界面 按下<kbd>。</kbd> 即可进去vscode编辑界面</p>
<p>github.com/user/repo在github后加<code>1s</code>，回车即可进入vscode编辑界面</p>
<p>Vscode在线：<a href="https://vscode.dev/">https://vscode.dev/</a></p>
</li>
<li><p>Github Contributions 3D模型下载：<a href="https://skyline.github.com/">Here</a></p>
</li>
<li><p>Github Markdown 语法：<a href="https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">Here</a></p>
</li>
</ol>
<p>示例：添加todo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- [x] this is a todo</span><br><span class="line">- [ ] this is a todo</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> this is a todo</li>
<li><input disabled="" type="checkbox"> this is a todo</li>
</ul>
<ol start="8">
<li>Github引用图片和文件方式</li>
</ol>
<p>下面是一些使用相对链接显示图像的示例。</p>
<table>
<thead>
<tr>
<th align="left">上下文</th>
<th align="left">相对链接</th>
</tr>
</thead>
<tbody><tr>
<td align="left">在同一个分支上的 <code>.md</code> 文件中</td>
<td align="left"><code>/assets/images/electrocat.png</code></td>
</tr>
<tr>
<td align="left">在另一个分支的 <code>.md</code> 文件中</td>
<td align="left"><code>/../main/assets/images/electrocat.png</code></td>
</tr>
<tr>
<td align="left">在仓库的议题、拉取请求和评论中</td>
<td align="left"><code>../blob/main/assets/images/electrocat.png</code></td>
</tr>
<tr>
<td align="left">在另一个仓库的 <code>.md</code> 文件中</td>
<td align="left"><code>/../../../../github/docs/blob/main/assets/images/electrocat.png</code></td>
</tr>
<tr>
<td align="left">在另一个仓库的议题、拉取请求和评论中</td>
<td align="left"><code>../../../github/docs/blob/main/assets/images/electrocat.png?raw=true</code></td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">引用文件链接</span><br><span class="line">https://github.com/alibaba/fastjson/blob/master/license.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Github Pages</tag>
        <tag>Github Actions</tag>
        <tag>Issue</tag>
        <tag>Pull Request</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/article/64245.html</url>
    <content><![CDATA[<blockquote>
<p>Ubuntu常用的Linux命令</p>
</blockquote>
<blockquote>
<p>使用Linux系统的时候会经常用到终端命令行来执行想要的操作，尤其是通过远程SSH使用时，没有可视化的界面就只能用命令行了，这就需要我们掌握常用的Linux命令了。</p>
</blockquote>
<a id="more"></a>

<h2 id="Ubuntu常用命令"><a href="#Ubuntu常用命令" class="headerlink" title="Ubuntu常用命令"></a>Ubuntu常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装vim</span><br><span class="line">sudo apt-get install vim</span><br><span class="line">sudo apt install vim</span><br><span class="line"></span><br><span class="line">更新源</span><br><span class="line">sudo apt-get update</span><br><span class="line">更新软件</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">apt list</span><br><span class="line">列出本地仓库中所有的软件包名</span><br><span class="line"></span><br><span class="line">apt list [package]</span><br><span class="line">从本地仓库中查找指定的包名，支持通配符，比如<span class="string">&quot;apt list zlib*“就能列出以zlib开头的所有包名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt list --installed</span></span><br><span class="line"><span class="string">列出系统中所有已安装的包名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt search [key]</span></span><br><span class="line"><span class="string">与list类似，通过给出的关键字进行搜索，列出所有的包和其描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt show [package]</span></span><br><span class="line"><span class="string">列出指定包的详细情况，包名要填写完整。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt install [package]</span></span><br><span class="line"><span class="string">安装指定的包，并同时安装其依赖的其他包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt remove [package]</span></span><br><span class="line"><span class="string">卸载包，但不删除相关配置文件。包名支持通配符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt autoremove</span></span><br><span class="line"><span class="string">卸载因安装软件自动安装的依赖，而现在又不需要的依赖包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt purge [package]</span></span><br><span class="line"><span class="string">卸载包，同时删除相关配置文件。包名支持通配符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt clean</span></span><br><span class="line"><span class="string">删除所有已下载的软件包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">apt autoclean</span></span><br><span class="line"><span class="string">类似clean，但删除的是过期的包（即已不能下载或者是无用的包）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Linux screen命令用于多重视窗管理程序</span></span><br><span class="line"><span class="string">screen -ls</span></span><br><span class="line"><span class="string">显示目前所有的screen作业</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">screen -r 4458</span></span><br><span class="line"><span class="string">重新连接screen作业</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">screen --wipe</span></span><br><span class="line"><span class="string">清除dead会话命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看运行内存情况 -h是以GB为单位</span></span><br><span class="line"><span class="string">free -h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Linux中buff/cache内存占用过高解决方案</span></span><br><span class="line"><span class="string">echo 1 &gt; /proc/sys/vm/drop_caches</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux通用命令"><a href="#Linux通用命令" class="headerlink" title="Linux通用命令"></a>Linux通用命令</h2><h4 id="ls：文件列出命令"><a href="#ls：文件列出命令" class="headerlink" title="ls：文件列出命令"></a>ls：文件列出命令</h4><ul>
<li>ls -a 显示所有文件和目录（包括隐藏文件）</li>
<li>ls -l 显示文件的详细信息</li>
<li>ls -r 将文件以相反序列列出</li>
<li>ls -t 将文件以建立时间列出</li>
</ul>
<h4 id="mkdir：创建文件夹命令"><a href="#mkdir：创建文件夹命令" class="headerlink" title="mkdir：创建文件夹命令"></a>mkdir：创建文件夹命令</h4><ul>
<li>mkdir &lt;文件名&gt; 即可在当前目录下创建一个文件夹</li>
</ul>
<h4 id="rm：删除文件命令"><a href="#rm：删除文件命令" class="headerlink" title="rm：删除文件命令"></a>rm：删除文件命令</h4><ul>
<li>rm -r * 删除当前目录下得所有文件及目录</li>
<li>rm &lt;文件名&gt; 删除一个文件</li>
</ul>
<h4 id="cp：复制文件到指定位置"><a href="#cp：复制文件到指定位置" class="headerlink" title="cp：复制文件到指定位置"></a>cp：复制文件到指定位置</h4><ul>
<li>cp -a 复制目录下的所有内容 eg. cp -a test/ newtest</li>
<li>cp -d 复制时保留链接</li>
<li>cp -f 覆盖已存在的文件，不提示</li>
<li>cp -i 覆盖已存在的文件，提示</li>
<li>cp -p 复制的文件保留修改时间和访问权限</li>
<li>cp -r 复制目录下的所有子目录和文件</li>
</ul>
<h4 id="mv：一般用来为文件或者目录改名，或者将目录移动到其他位置"><a href="#mv：一般用来为文件或者目录改名，或者将目录移动到其他位置" class="headerlink" title="mv：一般用来为文件或者目录改名，或者将目录移动到其他位置"></a>mv：一般用来为文件或者目录改名，或者将目录移动到其他位置</h4><ul>
<li>mv -b 文件目标存在时，会创建一个备份 eg. mv onefile twofile (将onefile改名为twofile）</li>
<li>mv -i 在覆盖前会询问</li>
<li>mv -f 覆盖前不会询问</li>
<li>mv -n 不覆盖任何文件</li>
<li>mv -u 目标文件不存在才能移动</li>
</ul>
<h4 id="find：在指定目录下查找文件"><a href="#find：在指定目录下查找文件" class="headerlink" title="find：在指定目录下查找文件"></a>find：在指定目录下查找文件</h4><ul>
<li>find 路径 -&lt;操作&gt; eg. find . -name “*.c” 查找所有后缀为.c的文件</li>
<li>find . -type f 将当前目录及子目录下的文件全部列出</li>
<li>find . -ctime -20 将当前目录及子目录下的在最近20天更新过的文件全部列出</li>
</ul>
<h4 id="grep：查找文件内符合条件的字符串"><a href="#grep：查找文件内符合条件的字符串" class="headerlink" title="grep：查找文件内符合条件的字符串"></a>grep：查找文件内符合条件的字符串</h4><ul>
<li>grep test *file 在当前目录中查找后缀有file的，并且包含test字符串的文件，并且打印出字符串的行</li>
<li>grep -r update /etc/acpi 以递归的方式查找符合条件的文件。eg.查找指定目录下的包含update的文件，并且打印所在行</li>
<li>grep -v test <em>test</em> 反向查找，查找文件名中包含test的文件中不包含test的行。</li>
<li>grep -i 不区分大小写</li>
</ul>
<h4 id="cat：输出文件内容"><a href="#cat：输出文件内容" class="headerlink" title="cat：输出文件内容"></a>cat：输出文件内容</h4><ul>
<li>cat -n 由1开始对所有内容进行行数编号</li>
<li>cat -b 对空白行不进行编号</li>
<li>cat -s 将两个空白行合并为一个</li>
<li>cat -E 在每行结束时显示$</li>
<li>cat -T 将TAB显示为^|</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的Git命令</title>
    <url>/article/5c7291e7.html</url>
    <content><![CDATA[<blockquote>
<p>这里将列出常用的Git命令，包括初始化仓库、配置、增删、提交、分支、标签、状态信息、远程同步、撤销等其他。</p>
</blockquote>
<a id="more"></a>

<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p><strong>Git配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">&quot;xxx@xx.com&quot;</span></span><br><span class="line"></span><br><span class="line">$ git config user.name</span><br><span class="line">fangjian98</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成ssh key</span></span><br><span class="line">Admin@PS2020KDZVZTZQ MINGW64 ~/learngit (master)</span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;xxx@xx.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Admin/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">&#x27;/c/Users/Admin/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/Admin/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/Admin/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:mc855CP9q3vjn17hFWn37pbuYmjqZ4OL8CbrNgjK2GU 2360870585@qq.com</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                .|</span></span><br><span class="line"><span class="string">|               +.|</span></span><br><span class="line"><span class="string">|         o    . +|</span></span><br><span class="line"><span class="string">|        S .    .o|</span></span><br><span class="line"><span class="string">| .  E    * .  ..o|</span></span><br><span class="line"><span class="string">|+..o..  . X .  .+|</span></span><br><span class="line"><span class="string">|o... +o..o Xoo =.|</span></span><br><span class="line"><span class="string">|    oo=o.+O=*=B+.|</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看ssh key</span></span><br><span class="line"><span class="string">$ cat ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>
<p><strong>Git项目常用命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/c/Users/Admin/learngit</span><br><span class="line"></span><br><span class="line">$ git init</span><br><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m <span class="string">&quot;write a readme file&quot;</span></span><br><span class="line">[master (root-commit) 5a5268c] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line">$ git push origin master</span><br><span class="line"> </span><br><span class="line">$ git branch</span><br><span class="line">$ git status.</span><br><span class="line">$ git diff readme.txt</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">$ cat readme.txt</span><br><span class="line">$ git checkout -- readme.txt</span><br><span class="line">$ git rm test.txt</span><br><span class="line">$ git pull</span><br><span class="line">$ rm test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Github提交远程仓库</span></span><br><span class="line">Admin@PS2020KDZVZTZQ MINGW64 ~/learngit (master)</span><br><span class="line">$ git remote add origin git@github.com:fangjian98/learngit.git</span><br><span class="line"></span><br><span class="line">Admin@PS2020KDZVZTZQ MINGW64 ~/learngit (master)</span><br><span class="line">$ git push -u origin master </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">$ git <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git log常用参数：after之后的记录，before之前的记录</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --all --grep=<span class="string">&quot;status&quot;</span> --author=<span class="string">&quot;fangjian&quot;</span> --after=<span class="string">&quot;2019-01-01&quot;</span> --before=<span class="string">&quot;2020-01-01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep 忽略大小写</span></span><br><span class="line">grep -i   </span><br></pre></td></tr></table></figure>

<p><strong>其他知识</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Git三种状态</span></span><br><span class="line">committed</span><br><span class="line">staged</span><br><span class="line">modified</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIt文件机制：.git目录下</span></span><br><span class="line">·HEAD	文件存放根节点的信息（目录结构是树形结构）</span><br><span class="line">·refs	目录存储当前版本控制目录下的各种引用：heads（不同根）、remotes（远程版本库）、stash（Git栈）、tags（标签）</span><br><span class="line">·logs	目录根据不同的引用存储了日志信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见命令</span></span><br><span class="line">git init</span><br><span class="line">gir <span class="built_in">clone</span></span><br><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git rm</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line">git fetch</span><br><span class="line">git merge</span><br><span class="line">git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD		还原至上一个提交</span><br><span class="line">git checkout HEAD &lt;path&gt;	从HEAD中签出并且恢复成未修改的样子</span><br><span class="line"></span><br><span class="line">git revert HEAD			撤销旧的提交</span><br><span class="line">git commit --amend		修改刚才的这个提交</span><br><span class="line"></span><br><span class="line">reset：是要reset到指定commit位置的状态</span><br><span class="line">	git reset -mixed</span><br><span class="line">	git reset -hard</span><br><span class="line">revert：file rollback并且自动产生一个roll back的commit</span><br><span class="line">	git revert HEAD</span><br><span class="line">	git revert HEAD^</span><br><span class="line">	git revert &lt;commit&gt;</span><br><span class="line"></span><br><span class="line">git diff &lt;path&gt;</span><br><span class="line">git diff --cached &lt;path&gt;</span><br><span class="line">git diff HEAD &lt;path&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Git-常用命令详解"><a href="#Git-常用命令详解" class="headerlink" title="Git 常用命令详解"></a>Git 常用命令详解</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>

<h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line">暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的adb命令</title>
    <url>/article/3610a686.html</url>
    <content><![CDATA[<blockquote>
<p>ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 <a href="https://developer.android.google.cn/studio/releases/platform-tools">sdk/platform-tools</a> 目录下。</p>
</blockquote>
<a id="more"></a>

<h2 id="Adb常用命令"><a href="#Adb常用命令" class="headerlink" title="Adb常用命令"></a>Adb常用命令</h2><ul>
<li>截图命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell /system/bin/screencap -p /sdcard/screenshot.png</span><br></pre></td></tr></table></figure>

<ul>
<li>将截图复制到电脑盘中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/screenshot.png D:\download</span><br></pre></td></tr></table></figure>

<ul>
<li>使用adb命令开始录屏</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li>启动和关闭ADB服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb start-server</span><br><span class="line">adb <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure>

<ul>
<li>强制停止apk</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop com.sohu.sohuvideo</span><br></pre></td></tr></table></figure>

<ul>
<li>强制停止apk，并清除数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm clear com.sohu.sohuvideo</span><br></pre></td></tr></table></figure>

<ul>
<li>静默安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm install -r filePath</span><br><span class="line">adb install **.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>列出安装的apk包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm list packsges</span><br></pre></td></tr></table></figure>

<ul>
<li>根据包名查找apk路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm path packages.name</span><br></pre></td></tr></table></figure>

<ul>
<li>根据包名卸载apk</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm uninstall packages.name</span><br></pre></td></tr></table></figure>

<ul>
<li>启动apk</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell am start -n ｛包(package)名｝/｛包名｝.&#123;活动(activity)名称&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 IP 地址无线连接到设备</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 USB 线将设备连接到主机，设置目标设备以监听端口 5555 上的 TCP/IP 连接。</span></span><br><span class="line">adb tcpip 5555</span><br><span class="line"><span class="comment"># 拔掉连接目标设备的 USB 线，通过 IP 地址连接到设备</span></span><br><span class="line">adb connect device_ip_address:5555</span><br><span class="line"><span class="comment"># 查看连接设备</span></span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<ul>
<li>Android源码开发常用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看存储</span></span><br><span class="line">df -h</span><br><span class="line"><span class="comment"># 查看运行内存</span></span><br><span class="line">free -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入root模式</span></span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解锁</span></span><br><span class="line">adb <span class="built_in">disable</span>-verity</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入boot模式</span></span><br><span class="line">adb reboot bootloader</span><br><span class="line">fastboot devices</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>

<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://developer.android.google.cn/studio/command-line/adb">https://developer.android.google.cn/studio/command-line/adb</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim的常用用法</title>
    <url>/article/c771602a.html</url>
    <content><![CDATA[<blockquote>
<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。连 vim 的官方网站 (<a href="https://www.vim.org/">https://www.vim.org/</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
</blockquote>
<a id="more"></a>

<h3 id="Vim的三种模式"><a href="#Vim的三种模式" class="headerlink" title="Vim的三种模式"></a>Vim的三种模式</h3><blockquote>
<p>vi的使用在linux环境下，使用vi &lt;文件名&gt; 即可进入vi编辑模式，vi编辑器一共有三种模式，分别是：命令模式，输入模式，和末行模式。</p>
</blockquote>
<ul>
<li>命令模式下，我们不可以输入字符，所输入的字符都被当做了命令来执行。比如最常见的i进入输入模式，o换行并且进入输入模式，x删除所在位置的字符等，在其他模式下可以通过esc键进入命令模式。</li>
<li>输入模式下，就和我们普通的编辑文档一样，操作没有特殊之处</li>
<li>末行模式下，我们只能在最后一行进行输入，一般wq保存并且退出vi模式，q退出但是不保存。</li>
</ul>
<h3 id="基本的命令"><a href="#基本的命令" class="headerlink" title="基本的命令"></a>基本的命令</h3><ul>
<li><p>k j h l 分别对应上下左右光标的移动</p>
</li>
<li><p>x删除一个字符/ dd删除一行</p>
</li>
<li><p>yy复制一行 / p 粘贴</p>
</li>
<li><p>o/O 向上/向下空一行，并且进入输入模式</p>
</li>
<li><p>a/A 进入输入模式从光标处开始</p>
</li>
<li><p>w,wq,q!,q,ZZ, 保存/保存并退出/不保存退出/离开/保存并退出</p>
</li>
<li><p>/：搜索</p>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>知识共享许可协议 Creative Commons Licenses</title>
    <url>/article/d8f310cd.html</url>
    <content><![CDATA[<blockquote>
<p>知识共享版权许可协议（Creative Commons licenses，简称cc）是在著作权法的传统的“所有权利保留”环境下构造平衡。给个人创作者、公司、机构在内的每一个人，提供简单的、标准化的方式授予他们所创作作品的版权许可。</p>
</blockquote>
<a id="more"></a>

<h3 id="关于知识共享许可协议-Creative-Commons-Licenses"><a href="#关于知识共享许可协议-Creative-Commons-Licenses" class="headerlink" title="关于知识共享许可协议 Creative Commons Licenses"></a>关于知识共享许可协议 Creative Commons Licenses</h3><p>知识共享许可协议（Creative Commons licenses，简称cc），它是由成立于2001年的美国<a href="http://creativecommons.org/">Creative Commons基金会</a>，在2002年12月16日提出的。<br>知识共享版权许可协议是在著作权法的传统的“所有权利保留”环境下构造平衡。给个人创作者、公司、机构在内的每一个人，提供简单的、标准化的方式授予他们所创作作品的版权许可。</p>
<p>严格意义上说该协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。CC 协议种类繁多，每一种都授权特定的权利。大多数的比较严格的 CC 协议会声明 “署名权，非商业用途，禁止衍生” 条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的 CC 协议类型当属 “署名” 协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p>
<p>知识共享许可协议-CC许可协议是博文常用的一个版权许可协议，例如：CSDN默认为<code>CC 4.0 BY-SA版权协议</code>，这意味着你的博文可用于商业使用。</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" align="left"/></br></p>
<h3 id="关于CC许可类型"><a href="#关于CC许可类型" class="headerlink" title="关于CC许可类型"></a>关于CC许可类型</h3><p><strong>1.四种核心权利</strong><br>署名（Attribution，简写为BY）：必须提到原作者。<br>非商业用途（Noncommercial，简写为NC）：不得用于盈利性目的。<br>禁止演绎（No Derivative Works，简写为ND）：不得修改原作品, 不得再创作。<br>相同方式共享（Share Alike，简写为SA）：允许修改原作品，但必须使用相同的许可证发布。</p>
<p><strong>2.六种组合</strong><br>署名（BY）<br>署名（BY）-相同方式共享（SA）<br>署名（BY）-禁止演绎（ND）<br>署名（BY）-非商业性使用（NC）<br>署名（BY）-非商业性使用（NC）-相同方式共享（SA）<br>署名（BY）-非商业性使用（NC）-禁止演绎（ND）</p>
<p>如果你还不确定该如何选择CC协议，你可以查看 <a href="https://creativecommons.org/choose/">creativecommons.org/choose</a> 来生成一个许可证。现在最流行的知识共享协议是<code>CC 4.0 BY-NC-SA版权协议</code></p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" align="left"/></br></p>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Creative Commons Licenses</tag>
      </tags>
  </entry>
  <entry>
    <title>开源许可协议 Open Source License</title>
    <url>/article/b86684bd.html</url>
    <content><![CDATA[<blockquote>
<p>开源许可证是计算机软件和其他产品的一种许可证，允许在定义的条款和条件下使用、修改和/或共享源代码、蓝图或设计。这允许最终用户和商业公司根据自己的定制、好奇心或故障排除需求来审查和修改源代码、蓝图或设计。</p>
</blockquote>
<a id="more"></a>

<h3 id="关于开源许可证-Open-Source-License"><a href="#关于开源许可证-Open-Source-License" class="headerlink" title="关于开源许可证 Open Source License"></a>关于开源许可证 Open Source License</h3><p>开源许可证是计算机软件和其他产品的一种许可证，允许在定义的条款和条件下使用、修改和/或共享源代码、蓝图或设计。这允许最终用户和商业公司根据自己的定制、好奇心或故障排除需求来审查和修改源代码、蓝图或设计。</p>
<p>我们接触到的开源软件一般都有对应的开源许可证对软件的使用、复制、修改和再发布等进行限制。许可证即授权条款，开源许可证就是保证开源软件这些限制的法律文件，目的在于规范受著作权保护的软件的使用或者分发行为。<strong>开源许可证是开源软件生态系统的基础，可以促进软件的协同开发。</strong></p>
<blockquote>
<p>常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：<br><strong>1. 宽松自由软件许可协议 Permissive Free Software Licence</strong><br>是一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。<br><strong>2.著佐权许可证 Copyleft License</strong><br>是在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。<br><strong>两者最大的差别在于</strong>：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而Permissive Free Software Licence 不要求公开源代码（衍生软件可以变为专有软件）。<br><strong>其中</strong>，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（Copyleft ）许可证，LGPL、MPL 是弱著佐权（Copyleft ）许可证。SSPL 则是近年来 MongoDB 创建的一个新许可证，存在较大争议，开放源代码促进会 OSI 甚至认为 SSPL 就不是开源许可协议。</p>
</blockquote>
<h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a>如何选择开源许可证</h3><p>如何为代码选择开源许可证，这是一个问题。世界上的开源许可证，大概有上百种，很少有人能弄清楚它们的区别。即使在最流行的六种开源许可证：<a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a>、<a href="https://en.wikipedia.org/wiki/BSD_licenses">BSD</a>、<a href="https://en.wikipedia.org/wiki/MIT_License">MIT</a>、<a href="https://www.mozilla.org/MPL/">Mozilla</a>、<a href="https://www.apache.org/licenses/LICENSE-2.0">Apache</a>和<a href="https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License">LGPL</a>，在这些中做出选择也很复杂。</p>
<p>乌克兰程序员Paul Bagwell 画了一张分析图，说明应该怎么选择，这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。<br><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/licenses.png" alt="开源许可证"></p>
<h3 id="常见开源许可证声明方式"><a href="#常见开源许可证声明方式" class="headerlink" title="常见开源许可证声明方式"></a>常见开源许可证声明方式</h3><ul>
<li><a href="https://opensource.org/licenses/MIT">MIT</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIT License</span><br><span class="line"></span><br><span class="line">Copyright (c) &lt;year&gt; &lt;copyright holders&gt;</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache2.0</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copyright [yyyy] [name of copyright owner]</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.gnu.org/licenses/gpl-3.0.html">GPL3.0</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;one line to give the program&#39;s name and a brief idea of what it does.&gt;</span><br><span class="line"></span><br><span class="line">Copyright (C) &lt;year&gt;  &lt;name of author&gt;</span><br><span class="line"></span><br><span class="line">This program is free software: you can redistribute it and&#x2F;or modify</span><br><span class="line">it under the terms of the GNU General Public License as published by</span><br><span class="line">the Free Software Foundation, either version 3 of the License, or</span><br><span class="line">(at your option) any later version.</span><br><span class="line"></span><br><span class="line">This program is distributed in the hope that it will be useful,</span><br><span class="line">but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="line">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="line">GNU General Public License for more details.</span><br><span class="line"></span><br><span class="line">You should have received a copy of the GNU General Public License</span><br><span class="line">along with this program.  If not, see &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;licenses&#x2F;&gt;.</span><br></pre></td></tr></table></figure>

<h3 id="查询开源协议的网站"><a href="#查询开源协议的网站" class="headerlink" title="查询开源协议的网站"></a>查询开源协议的网站</h3><ol>
<li><a href="https://spdx.org/licenses/">spdx.org/licenses/</a></li>
<li><a href="https://opensource.org/licenses">opensource.org/licenses</a></li>
<li><a href="https://choosealicense.com/">choosealicense.com/</a></li>
</ol>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Open Source License</tag>
        <tag>MIT</tag>
        <tag>Apache2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之设计模式</title>
    <url>/article/8f5452f1.html</url>
    <content><![CDATA[<blockquote>
<p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
</blockquote>
<a id="more"></a>

<h3 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h3><ul>
<li>代码重用性：相同功能的代码，不用多次编写</li>
<li>可读性：编程规范性，便于其他程序员的阅读和理解</li>
<li>可扩展性：当需要增加新的功能时非常方便，可维护性</li>
<li>高内聚低耦合：模块内部代码紧密，模块之间松散</li>
<li>可靠性：增加新的功能后，对原有的功能没有影响</li>
</ul>
<h3 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h3><ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转（倒置）</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ul>
<h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><ul>
<li>抽象工厂模式(Abstract Factory) ,提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li>生成器模式 (Builder)，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li>工厂方法模式(Factory Method) ，定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</li>
<li>原型模式 (Prototype) ，用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li>
<li>单例模式(Singleton)，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
</ul>
<h3 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h3><ul>
<li>适配器模式 (Adapter) ，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>桥接模式(Bridge) ，将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>
<li>组合模式(Composite) ，将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</li>
<li>容器模式</li>
<li>修饰模式 (Decorator) ，动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。<br>扩展性模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>管道与过滤器模式</li>
<li>代理模式(Proxy) ，为其他对象提供一个代理以控制对这个对象的访问。</li>
</ul>
<h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><ul>
<li>责任链模式 (Chain of Responsibility) ，为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</li>
<li>命令模式 (Command) ，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</li>
<li>柯里化模式</li>
<li>事件监听器模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式 (Memento) ，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</li>
<li>观察者模式(Observer) ，定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</li>
<li>状态模式 (State) ，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li>
<li>策略模式 (Strategy) ，定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</li>
<li>模板方法模式</li>
<li>访问者模式 (Visitor)，表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
<li>层次访问者模式</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Github的重要功能Pages、Actions、REST API以及GitHub Flow</title>
    <url>/article/604f0261.html</url>
    <content><![CDATA[<blockquote>
<p>这里将介绍Github的四个重要功能：Github Pages、Github Actions、REST API以及GitHub Flow。</p>
</blockquote>
<a id="more"></a>

<h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p>Github Pages的优点</p>
<ul>
<li>使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便.</li>
<li>免费: 免费提供 username.github.io 的域名, 免费的静态网站服务器.</li>
<li>无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站.</li>
</ul>
<p>Github提供了Pages功能, 分别是user pages和project pages, 区别如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>User Page</th>
<th>Project Page</th>
</tr>
</thead>
<tbody><tr>
<td>是否多个</td>
<td>一个帐号只有一个</td>
<td>可以有多个, 每个repo都可以有对应的Project page</td>
</tr>
<tr>
<td>repo and branch</td>
<td>repo名必须为<code>&lt;username&gt;.github.io</code>, 页面在master上</td>
<td>repo名随意, 页面必须在分支<code>gh-pages</code>下</td>
</tr>
<tr>
<td>URL</td>
<td><code>http(s)://&lt;username&gt;.github.io</code></td>
<td><code>http(s)://&lt;username&gt;.github.io/&lt;projectname&gt;</code></td>
</tr>
</tbody></table>
<p>常见的使用Github Pages搭建个人博客的方式：<code>hexo</code>与<code>jekyll</code></p>
<p><code>Github Pages</code>其实等于<code>jekyll engine</code> + <code>static web server,</code> 方法1其实是利用<code>jekyll</code>搭建<code>blog</code>, 这两个功能都用到了.</p>
<p><code>Hexo</code> + <code>Github pages</code>搭建blog其实就是只利用了github pages的<code>static web server</code>功能, hexo基于node.js, hexo在本机将用户的blog翻译成静态页面, 然后将这些静态页面上传到<code>github</code>上, 由<code>github pages</code>的<code>static web server</code>部署这些静态页面.</p>
<p>他们的主要区别是:</p>
<ul>
<li><code>md</code>到<code>html</code>的转换时机不同, <code>hexo</code>在本机完成, jekyll是由github pages完成</li>
<li>提交到github库里的文件不同, hexo是提交转换后的静态页面, jekyll是提交转换前的md文件</li>
</ul>
<blockquote>
<p>[1] <a href="https://blog.csdn.net/baidu_25464429/article/details/80805237">https://blog.csdn.net/baidu_25464429/article/details/80805237</a><br>[2] <a href="https://www.jianshu.com/p/7c013faaaba1">https://www.jianshu.com/p/7c013faaaba1</a><br>[3] Github Pages：<a href="https://docs.github.com/cn/pages">https://docs.github.com/cn/pages</a></p>
</blockquote>
<h2 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h2><p>manual.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is a basic workflow that is manually triggered</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Manual</span> <span class="string">workflow</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Controls when the action will run. Workflow runs when manually triggered using the UI</span></span><br><span class="line"><span class="comment"># or API.</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">    <span class="comment"># Inputs the workflow accepts.</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">name:</span></span><br><span class="line">        <span class="comment"># Friendly description to be shown in the UI instead of &#x27;name&#x27;</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">&#x27;Person to greet&#x27;</span></span><br><span class="line">        <span class="comment"># Default value if no value is explicitly provided</span></span><br><span class="line">        <span class="attr">default:</span> <span class="string">&#x27;World&#x27;</span></span><br><span class="line">        <span class="comment"># Input has to be provided for the workflow to run</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># This workflow contains a single job called &quot;greet&quot;</span></span><br><span class="line">  <span class="attr">greet:</span></span><br><span class="line">    <span class="comment"># The type of runner that the job will run on</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Steps represent a sequence of tasks that will be executed as part of the job</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># Runs a single command using the runners shell</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Send</span> <span class="string">greeting</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Hello $<span class="template-variable">&#123;&#123; github.event.inputs.name &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1] Github Action：<a href="https://docs.github.com/cn/actions">https://docs.github.com/cn/actions</a></p>
</blockquote>
<h2 id="Github-REST-API"><a href="#Github-REST-API" class="headerlink" title="Github REST API"></a>Github REST API</h2><p>要创建集成、检索数据和自动化工作流程，请使用 GitHub REST API 构建。</p>
<p><a href="https://docs.github.com/cn/rest">https://docs.github.com/cn/rest</a></p>
<h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><p>GitHub flow，顾名思义，就是 GitHub 所推崇的 Workflow。千万不要理解成 GitHub 上才能用的 Workflow。</p>
<p>其官网的描述为：</p>
<blockquote>
<p>GitHub flow is a lightweight, branch-based workflow that supports teams and projects where deployments are made regularly.</p>
</blockquote>
<p>从中我们可以得出的信息是 —— <em>这段描述完全就是废话</em> GitHub flow 具有很高的通用性。</p>
<p>为了更便于了解 GitHub flow 的内容，我们从流程图入手：</p>
<p>GitHub 流是一个轻量级的、基于分支的工作流。GitHub 流程对所有人有用，而不仅仅是开发人员。例如，在 GitHub，我们将 GitHub 流用于我们的站点策略、文档和路线图。</p>
<p><img src="https://pic3.zhimg.com/80/v2-bafaef976e8842a50403d61912239b52_720w.jpg" alt="img"></p>
<p>其中的主要流程为：</p>
<ul>
<li>新建分支（Create a branch）；</li>
<li>提交修改（Add commits）；</li>
<li>创建PR（Open a Pull Request）；</li>
<li>代码评审（Discuss and review your code）；</li>
<li>部署（Deploy）；</li>
<li>合并（Merge）；</li>
</ul>
<p>细心的同学可能很快会发现，GitHub flow 最大的亮点在于部署（Deploy）发生在 合并（Merge）之前，这就是 GitHub flow 的核心，非阻塞式集成 ——在产生任何副作用之前得知当前修改的所有集成效果，达到真正的持续集成。</p>
<p>常见的分支策略有以下三种：GitFlow、GitHubFlow以及GitLabFlow。</p>
<ul>
<li><p>GitFlow通常包含五种类型的分支：Master分支、Develop分支、Feature分支、Release分支以及Hotfix分支。</p>
</li>
<li><p>GitHubFlow通常只有一个Master分支是固定的，而且GitHubFlow中的Master分支通常是受保护的，只有特定权限的人才可以向Master分支合入代码。</p>
</li>
<li><p>相比于GitHubFlow，GitLabFlow增加了对预生产环境和生产环境的管理，即Master分支对应为开发环境的分支，预生产和生产环境由其他分支（如Pre-Production、Production）进行管理。</p>
</li>
</ul>
<blockquote>
<p>[1] <a href="http://t.zoukankan.com/huaweiyun-p-15014479.html">http://t.zoukankan.com/huaweiyun-p-15014479.html</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/81396787">https://zhuanlan.zhihu.com/p/81396787</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Github Pages</tag>
        <tag>Github Actions</tag>
        <tag>GitHub Flow</tag>
        <tag>REST API</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的基本使用</title>
    <url>/article/163a8691.html</url>
    <content><![CDATA[<blockquote>
<p>Git的基本使用是需要掌握的基本概念和命令，以及掌握一些高级用法，如git rebase、git stash等。</p>
</blockquote>
<a id="more"></a>

<h3 id="Git的基本使用"><a href="#Git的基本使用" class="headerlink" title="Git的基本使用"></a>Git的基本使用</h3><ol>
<li>第一次使用git需要使用命令 <code>git config --global user.name &lt;name&gt;</code> 、<code>git config --global user.email &lt;email&gt;</code> 配置好git的用户名和邮箱</li>
<li>在本地测试仓库，不需要配置ssh公钥，但是在诸如码云或者其他远程服务器上进行仓库关联需要使用ssh公钥进行关联。使用命令<code>ssh-keygen -t rsa &lt;emial&gt; </code>可以在本地生成一个ssh公钥，之后登陆码云后将秘钥黏贴进去，即可在本地与远程仓库之间建立连接</li>
<li>生成本地仓库，首先在需要生成仓库的位置右键点击git bash here ，输入git init 即可在当前目录下生成一个.git文件夹，这就是本地仓库的位置啦</li>
<li>我们可以输入命令 touch readme.txt 来在当前目录下生成一个文件，以这个文件为例，测试git的拉取和上传功能。输入命令git status，即可查看当前没有上传至暂存处的修改或者新建的文件，这时就需要我们进行后续的一套操作。</li>
<li>输入命令<code>git add . </code>即可将这些文件存放至暂存区，这个区域是不可见得，所以不用区找，我们可以再次输入<code>git status </code>查看当前的文件的状态。可以发现这些文件都存进暂存区了。</li>
<li>输入命令<code>git commit -m &lt;注释&gt; </code>这是把当前在暂存区的文件或者操作完成的文件（比如git rm后的文件）全部提交到git本地仓库中去，这就完成了文件的提交。再次查看git status 可以发现这些文件都消失了，说明文件都提交上去了。</li>
<li>这里可以使用<code>git reset</code>进行版本的回溯，输入<code>git log</code> 查看commit 的版本号，再次输入，git reset –hard &lt;版本号&gt; 可以回滚到之前的提交版本。</li>
<li>到了这里本地仓库的操作都完成了，接下来是进行与远程仓库之间的关联和文件的上传了。输入命令 <code>git remote add origin &lt;关联的远程仓库的地址&gt;:&lt;ssh仓库的路径&gt; </code>这就和远程仓库进行关联了，有时候这里会弹出错误 （remote origin already exists）这表明已经与其它远程仓库进行关联了，输入命令<code>git remote rm origin </code>将当前关联的远程仓库删除即可。</li>
<li>下面进行远程仓库的文件的拉取，这一步是必要的，因为如果与远程仓库的文件不同步，可能会发生冲突，因此建议这里在push前都要pull一下，避免冲突。输入命令<code>git pull --rebase origin master</code>(这里的pull其实包含 fetch 和merge两个操作，即fetch解决冲突问题，merge就是将文件合并），最后就可以愉快地进行代码地上传了，输入命令<code>git push -u origin master</code>(输入-u，在下一次使用push时可以直接git push，不用敲 origin master了），转到码云刷新仓库即可看到刚刚上传的文件已经显示在仓库中了。</li>
</ol>
<h3 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h3><p>Git分支可以理解为一个链表，插入新的分支，就是在链表的一个节点上插入新的链表，而分支的合并分情况讨论，如果主支没有修改，而插入的分支进行了修改，那么在合并的时候就将指针也就是master指向了最新的一次commit节点。而如果主支修改的同时，插入的分支也修改了，那么在合并的时候就需要解决冲突，可能两个修改的分支会并存，这时候可以用git log查看commit的日志。<br>注意：在初始化一个git仓库后，首先需要在仓库中存入一个任意的文件，如果直接创建分支，那么默认分支，也就是master会消失，取而代之的是默认分支变为主支。</p>
<ul>
<li>分支的创建，输入命令git branch &lt;分支名&gt;</li>
<li>分支的切换，输入命令git checkout &lt;分支名&gt;</li>
<li>分支的创建和切换，分支的创建并且切换到该分支，git checkout -b &lt;分支名&gt;</li>
<li>查看当前的所有分支，输入命令git branch</li>
<li>行显示日志，输入命令git log –decorate –oneline</li>
<li>图像化显示日志，输入命令 git log –decorate –oneline -graph -all</li>
<li>本地分支合并 git merge &lt;分支名&gt;</li>
</ul>
<h3 id="Git-diff"><a href="#Git-diff" class="headerlink" title="Git diff"></a>Git diff</h3><ul>
<li>比较当前工作区未提交内容与最后一次commit内容的不同之处git diff</li>
<li>比较暂存区(已经add，但是未commit的内容) 和最后一次commit的区别git diff –catched / git diff –staged</li>
<li>显示工作目录，新创建但未add的文件，和暂存区已经add但未commit的文件，与最后一次commit的区别git diff HEAD</li>
<li>比较两个分支上的最后commit 的区别git diff <branch1> <branch2></li>
<li>比较两个分支log有什么区别git log <branch1>…<branch2></li>
<li>比上面更清楚的知道区别git log –left-right <branch>…<branch2></li>
</ul>
<h3 id="Git-stash"><a href="#Git-stash" class="headerlink" title="Git stash"></a>Git stash</h3><p>Git stash 主要功能就是，将当前的工作区保存，之后再使用git status查看可以发现当前工作区变干净了。想要恢复时，使用git checkout 切换分支，再使用git stash pop恢复即可。<br>注意：多次使用git stash后，可以使用git stash list查看保存的列表，使用git stash apply恢复，或者使用git stash drop删除。</p>
<h3 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h3><p>Git rebase 主要使用在分支合并的操作上，因此从远程下拉代码、本地分支合并并提交都会用到rebase命令。</p>
<ol>
<li>我们可以使用rebase合并多个commit为一个commit，这样在log中就能更加清爽整洁，使用命令 git rebase -i [开始版本号] [结束版本号] /或者 git rebase -i HEAD~[一个区间数字]，之后使用如下命令进行操作即可。</li>
</ol>
<ul>
<li>pick：保留该commit（缩写:p）</li>
<li>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</li>
<li>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</li>
<li>squash：将该commit和前一个commit合并（缩写:s）</li>
<li>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</li>
<li>exec：执行shell命令（缩写:x）</li>
<li>drop：我要丢弃该commit（缩写:d）</li>
</ul>
<ol start="2">
<li>此外我们可以使用rebase可以将commit黏贴到另外一个分支上，使用命令 git rebase [开始版本号] [结束版本号] –onto [分支名]。</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP常用命令</title>
    <url>/article/b42edc12.html</url>
    <content><![CDATA[<blockquote>
<p>手机厂商或者智能模块厂商都是基于Android系统源码基础上进行二次开发，即AOSP(Android Open Source Project)，开发人员涉及Framework、APP、底层驱动以及通信BP侧等，这就需要我们了解Android系统的架构设计、编译、刷机验证等知识。</p>
</blockquote>
<a id="more"></a>

<h3 id="AOSP编译命令"><a href="#AOSP编译命令" class="headerlink" title="AOSP编译命令"></a>AOSP编译命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码全编译</span></span><br><span class="line"><span class="built_in">cd</span> LA.UM.7.6/</span><br><span class="line">git branch -a</span><br><span class="line">git checkout -b SLM758W_meig_custom origin/SLM758W_meig_custom</span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch <span class="comment">#选择编译项</span></span><br><span class="line">42</span><br><span class="line"><span class="comment"># lunch msm8953_64-userdebug</span></span><br><span class="line">make -j8 2&gt;&amp;1 | tee build.log <span class="comment">#加上编译log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除编译结果目录</span></span><br><span class="line">rm -rf out/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单模块编译</span></span><br><span class="line">在整体编译时部分依赖测试不会进行编译，所以使用使用mmm时会提示依赖出错，此时应该用mmma进行编译</span><br><span class="line">mm 构建模块在当前文件夹，不构建依赖</span><br><span class="line">mmm 构建模块指定路径，不构建依赖</span><br><span class="line">mma 构建模块在当前文件夹并构建依赖</span><br><span class="line">mmma 构建模块在当前文件夹并构建依赖</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单模块编译make:module name可查看对于模块下的Android.mk或Android.bp</span></span><br><span class="line">make &lt;module name&gt;</span><br><span class="line">make SystemUI</span><br><span class="line"></span><br><span class="line">其他编译命令：</span><br><span class="line"><span class="comment"># 编译bootloader</span></span><br><span class="line">make aboot	             </span><br><span class="line"><span class="comment"># 编译kernel</span></span><br><span class="line">make bootimage</span><br><span class="line"><span class="comment"># 编译system</span></span><br><span class="line">make systemimage</span><br><span class="line"><span class="comment"># 编译userdata</span></span><br><span class="line">make userdataimage</span><br><span class="line"><span class="comment"># 编译recovery</span></span><br><span class="line">make recoveryimage</span><br><span class="line"><span class="comment"># mmm编译指定目录的模块，如编译联系人</span></span><br><span class="line">mmm packages/apps/Contacts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见的编译错误有：</span></span><br><span class="line">1.编译环境配置不正常；</span><br><span class="line">2.编译的代码有语法或逻辑错误；</span><br><span class="line">3.编译过程中服务器中断。</span><br><span class="line"><span class="comment"># 对应解决方法：</span></span><br><span class="line">1.配置对应编译环境；</span><br><span class="line">2.根据error提示修改代码；</span><br><span class="line">3.重新连接服务器重新编译或者继续编译，若想清除之前编译的信息则使用指令：make clean</span><br></pre></td></tr></table></figure>
<h3 id="修改验证方式"><a href="#修改验证方式" class="headerlink" title="修改验证方式"></a>修改验证方式</h3><ol>
<li>修改APK应用</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在packages中的应用如果修改后都可以单独编译。先执行 </span><br><span class="line">$ <span class="built_in">source</span> build/envsetup.sh <span class="comment">#初始化</span></span><br><span class="line">$ mmm packages/providers/ContactsProvider/</span><br><span class="line"><span class="comment"># 用mm/mmm来编译生成的.apk并不会打包到system.img中，需要我们手动通过make snod把system文件夹打包为system.img</span></span><br><span class="line"><span class="comment">#可以使用make snod将模块打包到system.img中，也可以使用 adb install *.apk安装</span></span><br><span class="line">$ make snod <span class="comment">#可重新打包android系统镜像文件system.img</span></span><br><span class="line"></span><br><span class="line">注：通过mmm packages/providers/ContactsProvider/ 编译后的apk在 out/target/product/generic/system/app </span><br><span class="line">这时候通过 adb install out/target/product/generic/system/app/xxx.apk 安装你刚修改过的apk就可以在模拟器上看到你修改的效果了。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改framework</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果在Contacts.java中修改了，必须重新编译下framework。先执行 </span><br><span class="line">$ <span class="built_in">source</span> build/envsetup.sh <span class="comment">#初始化</span></span><br><span class="line"><span class="comment">#网上有的说要执行 make update-api，实际上直接make PRODUCT-sdk-sdk就可以将修改后的framework编译到sdk中。 </span></span><br><span class="line"><span class="comment">#编译framework后，那些修改了的应用可以不用再单独编译了。4～6分钟</span></span><br><span class="line">$ make PRODUCT-sdk-sdk <span class="comment">#重新生成SDK 10~20分钟</span></span><br></pre></td></tr></table></figure>

<h3 id="高通烧录工具QFIL"><a href="#高通烧录工具QFIL" class="headerlink" title="高通烧录工具QFIL"></a>高通烧录工具QFIL</h3><p>1.编译结果目录：\192.168.0.227\home1\fangjian\LA.UM.7.6\out\target\product\msm8953_64<br>2.将其目录下的非文件夹文件拷贝到原始镜像的文件夹中 \SLM758W\android9\SLM758E\V24<br>3.使用QFil进行烧录 选择xml</p>
<h3 id="Linux-amp-Git命令"><a href="#Linux-amp-Git命令" class="headerlink" title="Linux&amp;Git命令"></a>Linux&amp;Git命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir 7.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出文件</span></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上一级目录</span></span><br><span class="line"><span class="comment"># `.`是当前目录 `..`是上一级目录 `/`是根目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容量</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行内存</span></span><br><span class="line">free -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有使用人情况</span></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line"><span class="comment"># device目录下的状态</span></span><br><span class="line">git status device/</span><br><span class="line"><span class="comment"># 修改的文件的不同</span></span><br><span class="line">git diff  device/qcom/msm8937_32/system.prop</span><br><span class="line"><span class="comment"># 在根目录下生成patch</span></span><br><span class="line">git diff  device/qcom/msm8937_32/system.prop &gt; patch</span><br><span class="line"><span class="comment"># 查看20行提交信息</span></span><br><span class="line">git <span class="built_in">log</span> --oneline -20</span><br><span class="line"><span class="comment"># 按q退出</span></span><br></pre></td></tr></table></figure>

<h3 id="验证ADB命令"><a href="#验证ADB命令" class="headerlink" title="验证ADB命令"></a>验证ADB命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看连接设备</span></span><br><span class="line">adb devices</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入命令行模式</span></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">adb reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成运行的log的命令</span></span><br><span class="line">adb logcat -b all &gt; test.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前界面的应用包名</span></span><br><span class="line">adb shell dumpsys activity | grep Resume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从设备导出文件到当前目录下</span></span><br><span class="line">adb pull /sdcard/Pictures/xx.png ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装手机应用命令</span></span><br><span class="line">adb install C:\Users\Admin\Desktop\MusicTests.apk</span><br><span class="line">adb install -r</span><br><span class="line">adb install -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性值</span></span><br><span class="line">adb shell getprop persist.sys.strict_op_enable</span><br><span class="line"><span class="comment"># 设置属性值</span></span><br><span class="line">adb shell setprop persist.sys.strict_op_enable <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭SELinux</span></span><br><span class="line">adb shell setenforce 0</span><br><span class="line"><span class="comment"># 打开SELinux</span></span><br><span class="line">adb shell setenforce 1</span><br><span class="line"><span class="comment"># 查询SELinux的运行模式</span></span><br><span class="line"><span class="comment"># 0： 切换成 permissive（宽容模式）</span></span><br><span class="line"><span class="comment"># 1： 切换成 enforcing（强制模式）</span></span><br><span class="line">adb shell getenforce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证：编译好应用，push后重启即可</span></span><br><span class="line">adb root </span><br><span class="line">adb remount</span><br><span class="line">adb push out/target/product/generic/system/app/xxx.apk /system/app/</span><br><span class="line">adb reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不重启 push frameworks操作</span></span><br><span class="line">C:\Users\Admin&gt;adb shell</span><br><span class="line">msm8937_32:/ <span class="comment"># stop</span></span><br><span class="line">msm8937_32:/ <span class="comment"># start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remount报错：重启后再执行adb root &amp;&amp; adb remount</span></span><br><span class="line">adb <span class="built_in">disable</span>-verity</span><br><span class="line">adb reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入bootloader模式</span></span><br><span class="line">adb reboot bootloader</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastboot flash partition filename 指定烧写一个分区</span></span><br><span class="line"><span class="comment"># Fastboot刷system分区</span></span><br><span class="line">fastboot flash system system.img </span><br><span class="line"><span class="comment"># 查看当前连接的设备</span></span><br><span class="line">fastboot devices </span><br><span class="line"><span class="comment"># 正常重启启动系统</span></span><br><span class="line">fastboot reboot </span><br><span class="line"><span class="comment"># 重启启动系统到bootloader阶段</span></span><br><span class="line">fastboot reboot-bootloader </span><br><span class="line"><span class="comment"># 烧写所有的分区</span></span><br><span class="line">fastboot flashall </span><br><span class="line"><span class="comment"># 擦除一个分区</span></span><br><span class="line">fastboot erase partition </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库</span></span><br><span class="line">adb root </span><br><span class="line">adb shell</span><br><span class="line"><span class="built_in">cd</span> data/data/</span><br><span class="line"><span class="built_in">cd</span> com.android.providers.media/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<h3 id="AOSP编译服务器设置"><a href="#AOSP编译服务器设置" class="headerlink" title="AOSP编译服务器设置"></a>AOSP编译服务器设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.生成你的ssh key，一路回车即可</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.将key注册到代码服务器</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.配置本地ssh策略</span></span><br><span class="line">vim ~/.ssh/config</span><br><span class="line"><span class="comment">#加入下面内容</span></span><br><span class="line">Host * KexAlgorithms +diffie-hellman-group1-sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.拉取代码</span></span><br><span class="line">git <span class="built_in">clone</span> ssh://fangjian@192.168.0.240:29418/LA.UM.7.6 &amp;&amp; scp -p -P 29418 fangjian@192.168.0.240:hooks/commit-msg LA.UM.7.6/.git/hooks/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>在线笔记工具Notion</title>
    <url>/article/3c2ec6ca.html</url>
    <content><![CDATA[<blockquote>
<p>Notion 是一款很强大的 All-in-One 在线记录工具。它集成了云笔记，云表格，Wiki等等生产力工具，拥有自由的模块化编辑排版功能，上手也非常容易。</p>
</blockquote>
<a id="more"></a>

<h3 id="关于Notion"><a href="#关于Notion" class="headerlink" title="关于Notion"></a>关于Notion</h3><p>官网：<a href="https://www.notion.so/product">https://www.notion.so/product</a></p>
<p>在线：<a href="https://www.notion.so/">https://www.notion.so</a></p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/notion_home.png" alt="Notion官网"></p>
<p>Notion 作为新生代的笔记工具，有很多过人之处，官方的一句话介绍是：The all-in-one workspace for your notes, tasks, wikis, and databases。这段描述毫无吹嘘的成分。尽管在四个领域内，Notion 的表现各有高低，但作为一款强大的全平台 Web App，确实有 All-in-one 的底气。</p>
<p>Notion 主要由三个内容单元——Block、Page 和 Database 构成。Block 可以是任意文本、列表、表格、代码或网页书签，Page 则是 Block 的集合，Database 又是 Page 的集合。</p>
<p>最妙的是，Notion 采用一种「无极」的内容组织形式，即 Block、Page 和 Database 三者可以互相包含——Page 组成 Database，但 Page 中又可以插入 Database。</p>
<blockquote>
<p>Personal 版本<br>拥有 无限 Blocks<br>Block 能分享给 5个 guests<br>支持多设备，多端同步<br>文件上传有尺寸限制（5MB）</p>
</blockquote>
<p>Notion可能是国外最受欢迎的一款笔记软件，其官网主打Team Wiki、Projects &amp; tasks 、Notes &amp; docs 三个模块，也代表了Notion团队协作、任务规划、个人笔记三个主要功能。现在，Notion 面向个人给出了「免费 + 无限」的新计划！真心值得喜爱「效率工具」的各位前去一试。</p>
<h3 id="Notion的使用"><a href="#Notion的使用" class="headerlink" title="Notion的使用"></a>Notion的使用</h3><p>1.符号/：触发功能选项</p>
<p>2.可用功能</p>
<ul>
<li><strong>Basic blocks</strong>：Text/Page/To-do list/Heading 1/2/3/Table/Buleted list/Numberd list/Toggle list/Quote/Divider/Link to page/Callout</li>
<li><strong>Inline</strong>：Mention a persion/Mention a page/Date or reminder/Emoji/Inline equation</li>
<li><strong>Database</strong>：Table view/Board view/Gallery view/List view/Calendar view/Timeline view/Database-Inline/Database-Full page/Linked view of database</li>
<li><strong>Media</strong>：Image/Web bookmark/Video/Audio/Code/File/</li>
<li><strong>Embeds</strong>：Google Drive/Tweet/Github Gist/Google Maps/Figma/Sketch/PDF/CodePen/Jira/Github/Slack/Dropbox/Zoom/OneDrive</li>
<li><strong>Adavanced blocks</strong>：Table of contents/Block equation/Template  button/Breadcrumb/Synced block/Toggle heading 1/2/3</li>
</ul>
<p>2.灵便的布局和重组：随意拖拽 自由排列</p>
<p>3.分栏：拖动块至最右端即可自动分栏，可多栏</p>
<p>4.颜色：选择某项，可以更改字体颜色和背景颜色</p>
<p>5.导入和导出文件</p>
<p>6.团队共享空间</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/notion_web.png" alt="Notion的使用"></p>
<blockquote>
<p>[1]  <a href="https://sspai.com/post/39694">https://sspai.com/post/39694</a></p>
</blockquote>
<h3 id="同类产品"><a href="#同类产品" class="headerlink" title="同类产品"></a>同类产品</h3><ul>
<li>Wolai ：<a href="https://www.wolai.com/">https://www.wolai.com/</a></li>
</ul>
<p>wolai是一种新形态的文档系统，它与你过去使用的所有传统文档、在线文档都有很多不同，学会使用wolai就等于拥有了一个强大的个人与团队生产力工具，被很多人称之为国产Notion。</p>
<ul>
<li>语雀：<a href="https://www.yuque.com/">https://www.yuque.com/</a></li>
</ul>
<p>语雀是蚂蚁集团旗下的文档与知识库工具，源自蚂蚁集团和阿里巴巴内部文档协同需求，塑造新一代知识构建与分享工具</p>
<ul>
<li>Boost Note - <a href="http://boostnote.io/">http://boostnote.io/</a></li>
</ul>
<p>Boost Note 是一种文档驱动的项目管理工具，可最大限度地提高远程 DevOps 团队的速度。</p>
<ul>
<li>Obsidian ：<a href="https://obsidian.md/">https://obsidian.md/</a></li>
</ul>
<p>一款笔记软件，markdown编辑工具，文件都在本地，不会丢失，文件夹式管理</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows使用技巧集合</title>
    <url>/article/2b5594fd.html</url>
    <content><![CDATA[<blockquote>
<p>Windows系列操作系统是如今个人电脑上使用最为广泛的操作系统，但很多人使用的方式依旧局限在只会鼠标点击的状态中，正确使用Windows也十分重要，一些经验与技巧，希望有帮助。</p>
</blockquote>
<a id="more"></a>

<h3 id="Windows使用技巧"><a href="#Windows使用技巧" class="headerlink" title="Windows使用技巧"></a>Windows使用技巧</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">复制网页禁止复制的文档：360文档 百度文库</span><br><span class="line">检查--设置--preference--Debugger--打开Disable JavaScript</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下载网页中视频：</span><br><span class="line">检查--network--media--F5刷新 -- 右键open <span class="keyword">in</span> new table--新窗口下载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">恶意软件删除工具：cmd--mrt--快速扫描--自动清理有恶意弹出的软件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wndows桌面优化：</span><br><span class="line">1.设置-个性化-开始-打开（显示更多磁贴、使用全屏开始屏幕） 按win键打开应用列表</span><br><span class="line"></span><br><span class="line">dell设置</span><br><span class="line">Fn+T切换极速模式和安静模式</span><br><span class="line"></span><br><span class="line">此电脑桌面</span><br><span class="line">桌面右键--个性化--主题--下拉 桌面图标显示 -- 选择此电脑 回收站 控制面板</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百度搜索技巧：加双引号 屏蔽广告</span></span><br><span class="line">intitle:python filetype:pdf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器快捷键</span></span><br><span class="line">ctrl+<span class="built_in">shift</span>+T 打开上次关闭的窗口</span><br><span class="line">ctrl+T 新建标签页</span><br><span class="line">ctrl+1 跳转到第一个标签页</span><br><span class="line">ctrl+9 跳转到到最后一个标签页</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows关机命令</span></span><br><span class="line">shutdown -r 关机并重启</span><br><span class="line">shutdown -s 关机</span><br></pre></td></tr></table></figure>

<h3 id="Windows常见快捷键"><a href="#Windows常见快捷键" class="headerlink" title="Windows常见快捷键"></a>Windows常见快捷键</h3><blockquote>
<p>Win + D：显示桌面</p>
<p>Win + E：打开资源管理器</p>
<p>Win + F：搜索文件或文件夹</p>
<p>Win + PrtSc：键自动截屏并保存</p>
<p>Win + Home：最小化所有窗口，除了当前激活窗口</p>
<p>Win + M：最小化所有窗口</p>
<p>Win + ↑：最大化窗口</p>
<p>Win + ↓：最小化窗口</p>
<p>Win+R : 打开命令行</p>
<p>Win+G：录屏</p>
<p>Win+Shift+S：截屏</p>
<p>Win+H：语音识别框</p>
<p>Win+。: 表情符号</p>
</blockquote>
<h3 id="浏览器技巧"><a href="#浏览器技巧" class="headerlink" title="浏览器技巧"></a>浏览器技巧</h3><ul>
<li><p>Edge浏览器扩展按钮不显示解决方案<br>1.首选我们打开Edge浏览器，在浏览器右上方可以看到一个由三个点组成的“设置及其它”图标，使用鼠标点击该图标。<br>2.点击之后会在下方弹出Edge浏览器的菜单窗口，在窗口中找到并点击“设置”这一项。<br>3.这时会打开Edge浏览器的设置页面中，在页面左侧的导航菜单中点击切换到“外观”设置页面中。<br>4.在外观设置中找到“选择要在工具栏上显示的按钮”这一栏，在其中找到“扩展按钮”，点击其右侧的开关将其开启就可以了。</p>
</li>
<li><p>插件默认路径</p>
<p>1.Edge浏览器：C:\Users\UserName\AppData\Local\Microsoft\Edge\User Data\Default\Extensions</p>
<p>2.Google浏览器：C:\Users\UserName\AppData\Local\Google\Chrome\User Data\Default\Extensions</p>
</li>
</ul>
<h3 id="Windows10激活"><a href="#Windows10激活" class="headerlink" title="Windows10激活"></a>Windows10激活</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmd命令激活windows</span></span><br><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr/skms kms.03k.org</span><br><span class="line">slmgr/ato</span><br><span class="line"></span><br><span class="line"><span class="comment"># Win10密钥</span></span><br><span class="line">专业版：W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">企业版：NPPR9-FWDCX-D2C8J-H872K-2YT43</span><br><span class="line">家庭版：TX9XD-98N7V-6WMQ6-BX7FG-H8Q99</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询激活命令</span></span><br><span class="line">运行：slmgr.vbs -dlv 命令可以查询到Windows的激活信息，包括：激活ID、安装ID、激活截止日期等；</span><br><span class="line">运行：slmgr.vbs -dli 命令可以查询到操作系统版本、部分产品密钥、许可证状态等；</span><br><span class="line">运行：slmgr.vbs -xpr 命令可以查询Windows是否永久激活；</span><br><span class="line">运行：Winver 命令可以查询系统内核版本，以及注册用户。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># WINDOWS_LTSC_2021下载</span></span><br><span class="line">文件名：Windows 10 Enterprise LTSC 2021 (x64) - DVD (Chinese-Simplified)</span><br><span class="line">ED2K下载链接：</span><br><span class="line">ed2k://|file|SW_DVD9_WIN_ENT_LTSC_2021_64BIT_ChnSimp_MLF_X22-84402.ISO|5044211712|1555B7DCA052B5958EE68DB58A42408D|/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像下载mdsn：</span></span><br><span class="line">https://next.itellyou.cn/</span><br></pre></td></tr></table></figure>

<h3 id="Windows上的语音识别功能"><a href="#Windows上的语音识别功能" class="headerlink" title="Windows上的语音识别功能"></a>Windows上的语音识别功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.Windows 语音识别命令功能：</span><br><span class="line">控制面板--轻松使用--语音识别--启动语音设别</span><br><span class="line">语音参考卡片</span><br><span class="line">https://support.microsoft.com/zh-cn/windows/windows-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%91%BD%E4%BB%A4-9d25ef36-994d-f367-a81a-a326160128c7</span><br><span class="line">经测试时Windows 语音识别很鸡肋 根本啥也听不懂</span><br><span class="line"></span><br><span class="line">2.设置--轻松使用--语音--WIN+H 开始听写--可以实现语音转文字  -- 此功能比较不错</span><br><span class="line"></span><br><span class="line">3.OneNote上的office听写语音设别准确度更高</span><br></pre></td></tr></table></figure>

<h3 id="命令行安装工具Winget"><a href="#命令行安装工具Winget" class="headerlink" title="命令行安装工具Winget"></a>命令行安装工具Winget</h3><p>使用 winget 工具可以安装和管理应用程序，winget ，全称windows package manager client，开发人员可以在 Windows 10 计算机上使用 winget 命令行工具来发现、安装、升级、删除和配置应用程序。 此工具是 Windows 程序包管理器服务的客户端接口。Windows常见的包管理器还有Chocolatey、winget、Scoop。</p>
<p>Winget：命令行安装工具 ，WIn10在微软商店安装“应用安装程序”，即可使用winget命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">winget search firefox</span><br><span class="line"><span class="comment"># 显示具体信息</span></span><br><span class="line">winget show fiefox</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">winget install firefox</span><br><span class="line"></span><br><span class="line"><span class="comment"># -e 是指定版本</span></span><br><span class="line">winget install firefox -e </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在winget上找不到软件，可以尝试用source添加软件源manifest</span></span><br><span class="line">winget <span class="built_in">source</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># add 添加新来源; list 列出当前源; update 更新当前源;remove 删除当前源;reset 重置源；</span></span><br></pre></td></tr></table></figure>

<h3 id="远程桌面Microsoft-Remote-Desktop"><a href="#远程桌面Microsoft-Remote-Desktop" class="headerlink" title="远程桌面Microsoft Remote Desktop"></a>远程桌面Microsoft Remote Desktop</h3><p><a href="https://docs.microsoft.com/zh-cn/windows-server/remote/remote-desktop-services/clients/remote-desktop-allow-access">Microsoft Remote Desktop</a>可以使用远程桌面通过Microsoft 远程桌面客户端（适用于 Windows、iOS、macOS 和 Android）从远程设备连接并控制你的电脑。 当你允许远程连接到你的电脑时，可以使用其他设备连接到你的电脑并访问所有应用、文件和网络资源，就像坐在办公桌前一样。</p>
<p>可以使用远程桌面连接到 Windows 10 专业版和企业版、Windows 8.1 和 8 企业版和专业版、Windows 7 专业版、企业版和旗舰版以及比 Windows Server 2008 更高的 Windows Server 版本。 不能连接到运行家庭版的计算机（如 Windows 10 家庭版）。</p>
<h3 id="系统管理优化工具-Dism"><a href="#系统管理优化工具-Dism" class="headerlink" title="系统管理优化工具 Dism++"></a>系统管理优化工具 Dism++</h3><p>Dism++ 是一款 Windows 系统管理优化工具，它解决了我们安装、维护系统的一大痛点问题——自定义设置和优化。相当于一个 “一站式” 管理优化工具集。</p>
<p>它把用户使用、调整频率较高的选项集合到一起，让我们可以使用它快速地完成电脑的自定义设置和优化，而不需要一层层地打开在不同位置的设置选项逐个调整，极大地方便了我们的操作。</p>
<p>官网：<a href="https://www.chuyu.me/zh-Hans/">www.chuyu.me</a></p>
<h3 id="数据恢复工具"><a href="#数据恢复工具" class="headerlink" title="数据恢复工具"></a>数据恢复工具</h3><ol>
<li>WinHex</li>
</ol>
<p>winhex 是一个专门用来对付各种日常紧急情况的工具。它可以用来检查和修复各种文件、恢复删除文件、硬盘损坏造成的数据丢失等。同时它还可以让你看到其他程序隐藏起来的文件和数据。总体来说是一款非常不错的 16 进制编辑器。</p>
<ol start="2">
<li>Windows File Recovery</li>
</ol>
<p>微软之前发布过一款免费的数据恢复软件：叫做Windows File Recovery，唯一且最大的缺陷是仅支持命令行，也就是只有懂命令的用户才能正常使用，这让我们大部分普通用户使用相当困难，很多用户望而止步。 今天给大家推荐一款免费好用的Windows文件恢复软件——WinFR界面版，它是为Windows File Recovery（微软官方命令行工具）专门开发的图形界面工具，支持从多种存储设备中恢复媒体文件、办公文件、压缩文件等，包括JPEG、 PDF、DOCX、MP3、EXCEL、ZIP等。</p>
<p>WinFR界面版<br><a href="https://www.iplaysoft.com/winfr-gui.html">https://www.iplaysoft.com/winfr-gui.html</a></p>
<p>WinFR命令行<br><a href="https://www.iplaysoft.com/windows-file-recovery.html">https://www.iplaysoft.com/windows-file-recovery.html</a></p>
<h3 id="Kotlin插件下载慢"><a href="#Kotlin插件下载慢" class="headerlink" title="Kotlin插件下载慢"></a>Kotlin插件下载慢</h3><p>Android Studio升级后，Kotlin插件往往也要升级。但是经常出现下载Kotlin插件卡住，超时的情况。</p>
<p>解决方法：</p>
<p>打开 <a href="https://plugins.jetbrains.com/plugin/6954-kotlin/versions">Jetbrains Kotlin下载界面</a> ，找到对应的Kotlin插件版本号，由于从这个地址下载也特别慢（10kb/s左右），所以可以借助迅雷下载（500kb/s左右）。先在网页界面使用F12，打开开发者调试界面，点击下载按钮，控制台的NetWork标签页会加载出下载地址，然后拷贝到迅雷，新建下载任务。</p>
<p>下载好zip格式的插件包后，在AndroidStudio的插件列表，添加本地插件<code>install plugin form disk</code>即可。</p>
<h3 id="Android-Studio配置Auto-Import"><a href="#Android-Studio配置Auto-Import" class="headerlink" title="Android Studio配置Auto Import"></a>Android Studio配置Auto Import</h3><ol>
<li>在粘贴的时候添加导入</li>
</ol>
<p>Insert imports on paste:  Always</p>
<ol start="2">
<li>添加清楚的导入，就是不带*的导入</li>
</ol>
<p>Add unambiguous imports on the fly</p>
<ol start="3">
<li>优化导入，会去掉没用到的包</li>
</ol>
<p>Optimize imports on the fly</p>
<h3 id="IntelliJ-IDEA创建项目"><a href="#IntelliJ-IDEA创建项目" class="headerlink" title="IntelliJ IDEA创建项目"></a>IntelliJ IDEA创建项目</h3><p>IntelliJ IDEA 如何创建一个普通的java项目，及创建java文件并运行。</p>
<ol>
<li><p>创建java项目：<br>1.打开IDEA 软件，点击界面上的Creaye New Project 或file – new – project<br>2.出现以下界面，选中Java，然后选择jdk，最后点击Next，进行下一步（我的是jdk1.8）<br>3.这里是选择生成项目时是否创建java文件，勾选上Java Hello World后会生成一个默认的Hello world文件，<br>点击Next进行下一步，也可以都不勾选<br>4.给项目命名，默认是untiled，自己填个名字吧，最后点击finish<br>5.项目创建完成</p>
</li>
<li><p>创建java文件：<br>1.点击src – new – package，创建一个文件包，并给包命名：com.example.demo<br>2.在包下面创建java类文件，点击包名 – New – Java Class，给类文件命名<br>3.运行java文件，点击Run – Run.;<br>4.输出结果</p>
</li>
</ol>
<h3 id="Pycharm默认源"><a href="#Pycharm默认源" class="headerlink" title="Pycharm默认源"></a>Pycharm默认源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">默认：https://pypi.python.org/simple</span><br><span class="line">清华: https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">豆瓣: http://pypi.douban.com/simple/</span><br><span class="line">阿里: http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">推荐清华源</span><br><span class="line"></span><br><span class="line">使用pip的时候在后面加上-i参数，指定pip的下载源</span><br><span class="line">pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h3 id="关于Conda"><a href="#关于Conda" class="headerlink" title="关于Conda"></a>关于Conda</h3><p>Conda的作用：在python开发中，我们希望每个应用有一个独立的python环境，因为不同应用可能使用的软件库的版本不一样，因此Conda虚拟环境即可以为一个应用创建一套隔离的python运行环境。</p>
<p>使用python的包管理器conda即可轻松创建虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看python安装路径</span></span><br><span class="line">C:\Users\fangj&gt;<span class="built_in">where</span> python</span><br><span class="line">C:\Program Files (x86)\Python36-32\python.exe</span><br><span class="line">C:\Users\fangj\Miniconda3\python.exe</span><br><span class="line">C:\Users\fangj\AppData\Local\Microsoft\WindowsApps\python.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 下载第三方库路径</span></span><br><span class="line">\Lib\site-packages</span><br><span class="line"></span><br><span class="line"><span class="comment"># conda常用命令</span></span><br><span class="line">conda create --name env-name</span><br><span class="line">conda activate env-name</span><br><span class="line">conda deactivate</span><br><span class="line">conda env remove --name env-name</span><br><span class="line">conda env list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建虚拟环境：tf2 虚拟环境名字  python=3.6指定python版本 -y确认</span></span><br><span class="line">conda create -n tf2 python=3.6 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看conda环境</span></span><br><span class="line">C:\Users\fangj&gt;conda env list</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">base                  *  C:\Users\fangj\Miniconda3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活性能环境</span></span><br><span class="line">conda activate tf2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">conda deactivate </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除虚拟环境</span></span><br><span class="line">conda remove -n tf2 --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索opencv包</span></span><br><span class="line">conda search opencv -c conda-forge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示添加的源</span></span><br><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure>

<h3 id="MinGW-编译器"><a href="#MinGW-编译器" class="headerlink" title="MinGW 编译器"></a>MinGW 编译器</h3><p>MinGW的全称是：Minimalist GNU on Windows 。它实际上是将经典的开源 C语言 编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。一句话来概括：MinGW 就是 GCC 的 Windows 版本 。<br>MinGW-w64 与 MinGW 的区别在于 MinGW 只能编译生成32位可执行程序，而 MinGW-w64 则可以编译生成 64位 或 32位 可执行程序。正因为如此，MinGW 现已被 MinGW-w64 所取代，且 MinGW 也早已停止了更新，内置的 GCC 停滞在了 4.8.1 版本，而 MinGW-w64 内置的 GCC 则更新到了 8.1.0 版本。（2020/12/15）</p>
<ol>
<li>下载</li>
</ol>
<p>mingw64下载：<a href="https://www.mingw-w64.org/downloads/">https://www.mingw-w64.org/downloads/</a></p>
<p>eg:x86_64-7.3.0-release-posix-seh-rt_v5-rev0.7z</p>
<p>sourceforge下载：<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/</a></p>
<ol start="2">
<li>添加环境变量</li>
</ol>
<p>之前安装的的 MinGW-w64 的 bin 文件夹地址，复制到新增的Path空白变量位置里，即可完成 MinGW-w64 的配置</p>
<ol start="3">
<li>验证安装</li>
</ol>
<p><code>win+r</code>，输入cmd进入命令行，输入<code>gcc -v</code>并按回车键（Enter），将会显示 MinGW-w64 的组件列表。</p>
<h3 id="关于VSCode"><a href="#关于VSCode" class="headerlink" title="关于VSCode"></a>关于VSCode</h3><ol>
<li><p>VSCode底部状态栏颜色问题</p>
<p>当你打开文件夹时，它是蓝色的。当你没有打开其他文件时，它是紫色的。修改主题色和这个没有关系。</p>
</li>
<li><p>超详细的VsCode创建SpringBoot项目(图文并茂)</p>
<p><a href="https://blog.csdn.net/zyd573803837/article/details/109263219">https://blog.csdn.net/zyd573803837/article/details/109263219</a></p>
</li>
</ol>
<h3 id="Github-Copilot的使用"><a href="#Github-Copilot的使用" class="headerlink" title="Github Copilot的使用"></a>Github Copilot的使用</h3><p><a href="https://copilot.github.com/">Copilot</a>是由 Github 提供的AI编码辅助工具，它可以在编码过程中提供基于 AI 学习的编码建议。在很多情况下，只需要有注释或者函数名称，Copilot就可以实例完整的代码。</p>
<p>目前 Copilot 还没有全量开放，需要申请开通权限。访问它的官方网站<a href="https://copilot.github.com/">copilot.github.com</a>，点击“Sign up“按钮即可申请开通。当获得开通权限后，就可以在 Github 上使用 Copilot。</p>
<p>正常使用时，当 Copilot 给出建议时，会在光标位置的后方出现建议的代码，并灰色字显示。如果不希望使用提示，则继续输入代码即可，如果希望使用提示的代码，按下 Tab 键即可。</p>
<p><img src="https://tutorials.maiyatang.co/attachments/vscode/copilot-usage-and-shortcut/04.completion.png" alt="使用截图"></p>
<p>在 VSCode 中，Copilot 有一个图标，需要确认状态是打开的。当它的样子与其它图标类似，没有背景颜色时，表示是开启的，此时当你编辑代码文件的时候，Copilot会自动提示代码建议。当它有背景颜色（红色、深黄色等）时，表示是关闭的。如果要切换状态只要点击它，然后选择全局（Globally）即可。</p>
<p><img src="https://tutorials.maiyatang.co/attachments/vscode/copilot-usage-and-shortcut/05.icon.png" alt="状态图标"></p>
<p>Copilot 也提供了一些快捷键，可以很方便地使用。</p>
<ul>
<li>接受建议：<code>Tab</code></li>
<li>拒绝建议：<code>Esc</code></li>
<li>打开Copilot：<code>Ctrl + Enter</code> （会打开一个单独的面板，展示10个建议）</li>
<li>下一条建议：<code>Alt/Option + ]</code></li>
<li>上一条建议：<code>Alt/Option + [</code></li>
<li>触发行内Copilot：<code>Alt/Option + \</code> （Coplit还没有给出建议或者建议被拒绝了，希望手工触发它提供建议）</li>
</ul>
<h3 id="Windows探索"><a href="#Windows探索" class="headerlink" title="Windows探索"></a>Windows探索</h3><ul>
<li><p>Ubuntu虚拟机设置网络：网络适配器 - 网络连接 - 选择 NAT模式：用于共享主机IP</p>
</li>
<li><p>免费申请office E5开发者订阅，附无限续期+私人网盘教程</p>
</li>
</ul>
<p>​        <a href="https://zhuanlan.zhihu.com/p/105438817?utm_source=qq">https://zhuanlan.zhihu.com/p/105438817?utm_source=qq</a></p>
<ul>
<li><p>WOL（Wake On LAN - 局域网唤醒）外网唤醒 配置教程 远程开机</p>
<p><a href="https://blog.csdn.net/qq_19764639/article/details/82817719">https://blog.csdn.net/qq_19764639/article/details/82817719</a></p>
</li>
<li><p>Gitee免费图床搭建以及PicGo的使用</p>
<p><a href="https://blog.csdn.net/cl939974883/article/details/109469396">https://blog.csdn.net/cl939974883/article/details/109469396</a></p>
<p><a href="https://sspai.com/post/65716">https://sspai.com/post/65716</a></p>
<p><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Edge</tag>
      </tags>
  </entry>
  <entry>
    <title>三阶魔方简易教程</title>
    <url>/article/88c25441.html</url>
    <content><![CDATA[<blockquote>
<p>魔方拥有竞速、盲拧、单拧等多种玩法，风靡程度经久未衰，每年都会举办大小赛事，是最受欢迎的智力游戏之一。三阶魔方形状通常是正方体，由有弹性的硬塑料制成。三阶魔方有很多种还原方法，其中“层先法”是最适合初学者掌握的方法。</p>
</blockquote>
<a id="more"></a>

<p>前提：两个公式<br>左手公式：上右下左<br>右手公式：上左下右</p>
<p>1.拼黄色小花<br>     白<br>白 黄 白<br>     白</p>
<p>2.找小柱子(中间)，向下转2周</p>
<p>3.白色朝底，找角块，找(对应颜色)目标位，找好对应位置 –&gt; 白色一层<br>   看白色块，左边或右边，不能后边<br>   白色块在左边：做左手公式<br>   白色块在右边：做右手公式</p>
<p>4.找棱块(中间块) –&gt; 二层<br>  没有黄色块：好朋友<br>  有黄色块：坏朋友(暂时不管)<br>  好朋友：找目标色块，若目标色块在左，要远离，先右转，再左手公式<br>                                   若目标色块在右，要远离，先左转，再右手公式<br>  都是坏朋友：先侧边右手公式，再转一面，左手公式</p>
<p>5.顶面十字<br>   小炸弹：        四边一档只有一个黄色块   –&gt; 开宝箱，右手公式 x1，关宝箱 –&gt; 变成小弯刀<br>   激光剑：—   横着放        –&gt; 开宝箱，右手公式 x1，关宝箱<br>   小弯刀：__|    九点钟方向        –&gt; 开宝箱，右手公式 x2，关宝箱</p>
<p>  开宝箱：整个面向下转一下<br>  关宝箱：整个面向上转一下</p>
<p>6.顶层角块位置<br>   二个位置对，二个位置不对，(颜色对应即可)，叫眼睛<br>   若是眼睛：对的一边放左边，右手公式 x3，整体左转，左手公式 x3<br>   若不是眼睛，右手公式 x3，整体转一下，左手公式 x3，变成眼睛</p>
<p>7.顶层黄色还原：只用右手公式<br>  白色面为顶，没有还原好的黄色块，放在右手下边，右手公式 x2，直到还原，可能需要重复几次<br>  然后继续将其他没有还原好的黄色块，放在右手下边，右手公式 x2<br>  乱了也没事，继续将底边黄色还原</p>
<p>8.还原<br>   一面全好的叫观众<br>   若有观众，正对自己，确定观众对面中心块颜色，<br>   若对面中心块颜色在左边，则左 x1，右 x1，左x5，右 x5<br>   若对面中心块颜色在右边，则右 x1，左 x1，右x5，左 x5</p>
<p>   没有观众：先左或先右都可，左 x1，右 x1，左x5，右 x5，变成观众</p>
<p>附：第8步：上三楼公式：上右上 左上左上 右下右下下<br>      把观众的对面朝向自己，上三楼公式</p>
<p>参考：<a href="https://baike.baidu.com/item/%E4%B8%89%E9%98%B6%E9%AD%94%E6%96%B9/2109093#3">三阶魔方还原方法</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>魔方</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言的Hello World程序</title>
    <url>/article/caca35c0.html</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">    	System.out.print(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>寻找机器学习数据集</title>
    <url>/article/543367d4.html</url>
    <content><![CDATA[<blockquote>
<p>数据集是人工智能算法训练和测试的基础，不同专业的人工智能算法研究需要用到不同专业的数据集，如下为网上推荐的几种寻找机器学习数据集的方法，另附数据集资源。</p>
</blockquote>
<a id="more"></a>

<ol>
<li>Kaggle数据集</li>
</ol>
<p>数据集地址：<a href="https://www.kaggle.com/datasets">https://www.kaggle.com/datasets</a></p>
<ol start="2">
<li>Amazon数据集</li>
</ol>
<p>数据集地址：<a href="https://registry.opendata.aws/">https://registry.opendata.aws/</a></p>
<p>该数据源包含多个不同领域的数据集，如：公共交通、生态资源、卫星图像等。</p>
<p>网页中也有一个搜索框来帮助用户寻找想要的数据集，还有所有数据集的描述和使用示例，这些数据集信息丰富且易于使用！</p>
<p>数据集存储在Amazon Web Services (AWS)资源中，比如Amazon S3——云中的一个高度可伸缩的对象存储服务。</p>
<p>如果用户正在使用AWS进行机器学习实验和开发，这将非常方便，由于它是AWS网络的本地数据，因此数据集的传输将非常快。</p>
<ol start="3">
<li>UCI机器学习资源库</li>
</ol>
<p>数据集地址：<a href="http://archive.ics.uci.edu/ml/datasets">http://archive.ics.uci.edu/ml/datasets</a></p>
<p>另一个来自加州大学信息与计算机科学学院的大型资源库，包含100多个数据集。</p>
<p>用户可以找到单变量和多变量时间序列数据集，分类、回归或推荐系统的数据集。</p>
<p>有些UCI的数据集已经是被清洗过的。</p>
<ol start="4">
<li>谷歌数据集搜索引擎</li>
</ol>
<p>数据集地址：<a href="https://toolbox.google.com/datasetsearch">https://toolbox.google.com/datasetsearch</a></p>
<p>在2018年末，谷歌做了他们最擅长的事情，推出了另一项伟大的服务——它是一个可以按名称搜索数据集的工具箱。</p>
<p>他们的目标是统一成千上万个不同的数据集存储库，使这些数据能够且易被发现。</p>
<ol start="5">
<li>微软数据集</li>
</ol>
<p>数据集地址：<a href="https://msropendata.com/">https://msropendata.com/</a></p>
<p>2018年7月，微软与外部研究社区共同宣布推出“Microsoft Research Open Data”。</p>
<p>它在云中包含一个数据存储库，用于促进全球研究社区之间的协作。它提供了一系列用于已发表研究的、经过处理的数据集。</p>
<ol start="6">
<li>Awesome Public Datasets Collection</li>
</ol>
<p>数据集地址：<a href="https://github.com/awesomedata/awesome-public-datasets">https://github.com/awesomedata/awesome-public-datasets</a></p>
<p>这是一个按“主题”组织的数据集，比如生物学、经济学、教育学等。</p>
<p>这里列出的大多数数据集都是免费的，但是在使用任何数据集之前，用户需要检查一下许可要求。</p>
<ol start="7">
<li>政府数据集</li>
</ol>
<p>政府相关数据集也很容易找到的。</p>
<p>许多国家为了提高透明度，向公众分享了各种数据集。以下是一些例子：</p>
<p>欧盟开放数据门户：欧洲政府数据集。</p>
<p>数据集地址：<a href="https://data.europa.eu/euodp/data/dataset">https://data.europa.eu/euodp/data/dataset</a></p>
<p>美国政府数据：目前由于一些非政治性原因，暂时无法访问。</p>
<p>数据集地址：<a href="https://www.data.gov/">https://www.data.gov/</a></p>
<p>新西兰政府数据集：</p>
<p>数据集地址：<a href="https://catalogue.data.govt.nz/dataset">https://catalogue.data.govt.nz/dataset</a></p>
<p>印度政府数据集：</p>
<p>数据集地址：<a href="https://data.gov.in/">https://data.gov.in/</a></p>
<ol start="8">
<li>计算机视觉数据集</li>
</ol>
<p>数据集地址：<a href="https://www.visualdata.io/">https://www.visualdata.io/</a></p>
<p>Visual Data包含一些可以用来构建计算机视觉(CV)模型的大型数据集。</p>
<p>用户可以通过特定的CV主题查找特定的数据集，如语义分割、图像标题、图像生成，甚至可以通过解决方案(自动驾驶汽车数据集)查找特定的数据集。</p>
<p>参考链接：<br><a href="https://blog.csdn.net/Sophia_11/article/details/86617383">https://blog.csdn.net/Sophia_11/article/details/86617383</a><br><a href="https://towardsdatascience.com/top-sources-for-machine-learning-datasets-bb6d0dc3378b">https://towardsdatascience.com/top-sources-for-machine-learning-datasets-bb6d0dc3378b</a><br><a href="https://blog.csdn.net/mbdong/article/details/121383725">https://blog.csdn.net/mbdong/article/details/121383725</a><br><a href="https://www.zhihu.com/question/327740767">https://www.zhihu.com/question/327740767</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>DataSet</tag>
        <tag>ArtificialIntelligence</tag>
      </tags>
  </entry>
  <entry>
    <title>关于电子邮件协议</title>
    <url>/article/1f82cbab.html</url>
    <content><![CDATA[<blockquote>
<p>电子邮件是一种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费）、非常快速的方式（几秒钟之内可以发送到世界上任何指定的目的地），与世界上任何一个角落的网络用户联系。</p>
</blockquote>
<a id="more"></a>

<p>在企业中一般都会有自己的定制化的企业邮箱， 使用的邮箱功能模块可按需求定制，例如邮箱后缀用公司名字的，想多个地区分别管理的，跨团队沟通群发邮件、想要一个独立登录入口页面、想要全球收发，企业邮箱里的功能都能满足，其灵活性的配置，让员工高效协同办公。</p>
<p>在使用企业邮箱配置客户端的时候，这就会涉及到邮件服务器和端口的填写，如下使用是Foxmail邮箱客户端配置邮件服务器的参数，如果使用Outlook也可以参考使用这个参数的配置。另外QQ邮箱也可以开通OP3/IMAP/SMTP服务。</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/mail_protocol.png" alt="邮件服务器的配置"></p>
<h3 id="关于邮件协议"><a href="#关于邮件协议" class="headerlink" title="关于邮件协议"></a>关于邮件协议</h3><ul>
<li><p>IMAP/SMTP服务</p>
</li>
<li><p>POP3/SMTP服务</p>
</li>
</ul>
<blockquote>
<p>电子邮件协议有SMTP、POP3、IMAP4，它们都隶属于TCP/IP协议簇，默认状态下，分别通过TCP端口25、110和143建立连接。</p>
</blockquote>
<h3 id="什么是POP3、SMTP及IMAP"><a href="#什么是POP3、SMTP及IMAP" class="headerlink" title="什么是POP3、SMTP及IMAP"></a>什么是POP3、SMTP及IMAP</h3><ul>
<li><strong>POP3</strong></li>
</ul>
<p>POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准，<strong>POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件</strong>，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。</p>
<ul>
<li><strong>SMTP</strong></li>
</ul>
<p>SMTP的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。<br>SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。</p>
<ul>
<li><strong>IMAP</strong></li>
</ul>
<p>IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留 在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端 软件登录邮箱，看到的邮件以及状态都是一致的。</p>
<h3 id="IMAP和POP3有什么区别"><a href="#IMAP和POP3有什么区别" class="headerlink" title="IMAP和POP3有什么区别?"></a>IMAP和POP3有什么区别?</h3><p><strong>POP3</strong>协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。</p>
<p>而<strong>IMAP</strong>提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p>
<p>同时，<strong>IMAP</strong>像<strong>POP3</strong>那样提供了方便的邮件下载服务，让用户能进行离线阅读。<strong>IMAP</strong>提供的摘要浏览功能可以让你在阅读完所有的邮件到达时间、主题、发件人、大小等信息后才作出是否下载的决定。此外，<strong>IMAP</strong> 更好地支持了从多个不同设备中随时访问新邮件。</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/mail_protocol_table.jpg" alt="IMAP与POP3的区别"></p>
<p>总之，<strong>IMAP</strong> 整体上为用户带来更为便捷和可靠的体验。<strong>POP3</strong> 更易丢失邮件或多次下载相同的邮件，但 <strong>IMAP</strong> 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。</p>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>POP3/SMTP</tag>
        <tag>IMAP/SMTP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Photoshop的用法</title>
    <url>/article/b76e39db.html</url>
    <content><![CDATA[<blockquote>
<p>Adobe Photoshop，简称“PS”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑工作。ps有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>PS 如何使用“拉直”功能拉直图像</li>
</ul>
<p>在Photoshop 中，打开图片，点击“剪裁工具”。</p>
<p>然后在选项栏中，选择拉直工具，如图所示</p>
<p>鼠标单击图像一端，按住鼠标按钮，然后拖动到另一端。</p>
<p>松开鼠标按钮，会旋转图像以使其变直。</p>
<ul>
<li>移动图像</li>
</ul>
<p>1.选中你需要移动的图层，然后选择工具栏上的第2个工具“移动”工具移动即可；</p>
<p>2.点选“移动”工具，在属性栏会出现“自动选择”，在前面打勾√，后面下拉选择框中，选择“图层”，这样你就可以直接选中你图片任意拖动了，就无需点选图层面板里的图层！</p>
<ul>
<li>关于图层</li>
</ul>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>关于设计UI/UX/UED职能解释</title>
    <url>/article/198ad0b7.html</url>
    <content><![CDATA[<blockquote>
<p>百度百科上说UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。 关于设计或者产品经理或者开发者来说，我们经常听到UI/UX/UED/UCD等专有名词，却总是搞不清楚他们的区别，这里将说明他们各自的含义。百度百科上说UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。</p>
</blockquote>
<a id="more"></a>

<h2 id="UI-UID"><a href="#UI-UID" class="headerlink" title="UI/UID"></a>UI/UID</h2><p><strong>UI：User Interface  用户界面 / UID：User Interface Design 用户界面设计</strong></p>
<p>用户界面其实是一个比较广泛的概念，指人和机器互动过程中的界面，以车为例子，方向盘、仪表盘、换档器等都属于用户界面。</p>
<ul>
<li>现在一般把屏幕上显示的图形用户界面（GUI ：Graphic User Interface）都简单称为UI。</li>
<li>现在一般所说的UI设计师，也即是指GUI设计师。</li>
<li>用户界面设计（UID）不仅仅是做”漂亮的界面”，所以不可避免的会涉及到交互设计。所以广义来说，界面设计包含交互设计。  </li>
</ul>
<h2 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h2><p><strong>ID：Interaction design 交互设计</strong></p>
<p>交互指任何机器互动的过程，交互设计通过了解人的心理、目标和期望，使用有效的交互方式来让整个过程可用、易用。</p>
<ul>
<li>交互设计的主要对象是人机界面（UI），但不仅限于图形界面（GUI）。 </li>
<li>为了达到目标，交互设计师需要关注心理、文化、人体工程等许多方面的内容。</li>
</ul>
<h2 id="UE-UX"><a href="#UE-UX" class="headerlink" title="UE/UX"></a>UE/UX</h2><p><strong>UE/UX： User Experience 用户体验</strong> </p>
<p>用户体验指用户在使用产品过程中的个人主观感受。</p>
<ul>
<li>关注用户使用前、使用过程中、使用后的整体感受，包括行为、情感、成就等各个方面。 </li>
<li>用户体验是整体感受，所以不仅仅来自于用户界面，那只是其中的一部分。</li>
</ul>
<h2 id="UED"><a href="#UED" class="headerlink" title="UED"></a>UED</h2><p><strong>UED： User Experience Design 用户体验设计</strong></p>
<p>用户体验是个人主观感受，但是共性的体验是可以经由良好的设计提升的。用户体验设计旨在提升用户使用产品的体验。</p>
<ul>
<li>互联网企业中，一般将视觉界面设计，交互设计和前端设计都归为用户体验设计。 </li>
<li>但实际上用户体验设计贯穿于整个产品设计流程，是必然涉及到的，只是重视与否。 </li>
<li>一名优秀的用户体验设计师，实际上需要对界面、交互和实现技术都有深入的理解。</li>
</ul>
<h2 id="UCD"><a href="#UCD" class="headerlink" title="UCD"></a>UCD</h2><p><strong>UCD：User Centered Design 以用户为中心的设计</strong></p>
<p>UCD是一种设计模式，思维。强调在产品设计过程中，从用户角度出发来进行设计，用户优先。</p>
<ul>
<li>产品设计有个BTU三圈图（Business, Technique, User），即一个好的产品，应该兼顾商业盈利，技术实现和用户需求。</li>
<li>无论是B、T还是U为优先进入产品设计，都可以设计出好的产品。UCD只是强调用户优先。</li>
</ul>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>UX</tag>
        <tag>UED</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Jetpack系列库简介</title>
    <url>/article/23f0b0f3.html</url>
    <content><![CDATA[<blockquote>
<p>JetPack是Google推出的一些库的集合，是Android基础支持库SDK以外的部分，包含了组件、工具、架构方案等，最核心的出发点就是帮助开发者快速构建出稳定、高性能、测试友好同时向后兼容的APP。</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是Jetpack"><a href="#什么是Jetpack" class="headerlink" title="什么是Jetpack"></a>什么是Jetpack</h3><p>2018年谷歌I/O 发布了一系列辅助Android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。大体上，JetPack是Google推出的一些库的集合，是Android基础支持库SDK以外的部分，包含了组件、工具、架构方案等，开发者可以自主按需选择接入具体的哪个库。</p>
<ul>
<li><p>Goole IO 2017：Google 开始推出Architecture Component, ORM库Room, 用户生命周期管理的ViewModel/ListData。</p>
</li>
<li><p>Goole IO 2018：将Support lib 更名为androidx，Google将许多正确的方案集中起来，以高效的开发Android APP。</p>
</li>
</ul>
<p>以上种种，现在统称为JetPack.其最核心的出发点就是帮助开发者快速构建出稳定、高性能、测试友好同时向后兼容的APP。</p>
<p>使用Jetpack的优势：</p>
<ul>
<li>加快开发速度</li>
<li>消除样板代码</li>
<li>编译功能强大的优质应用</li>
</ul>
<h3 id="Jetpack的组成"><a href="#Jetpack的组成" class="headerlink" title="Jetpack的组成"></a>Jetpack的组成</h3><p>Android Jetpack 组件覆盖以下 4 个方面：Foundation （基础组件）、Architecture（架构组件）、Behavior（行为组件）、UI（界面组件）。</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack.png" alt="Android Jetpack"></p>
<ol>
<li>基础组件</li>
</ol>
<p>AppCompat：使得支持较低的 Android 版本。从以前继承 Activity 到现在继承 AppCompatActivity 就是属于这一部分<br>Android KTX：Kotlin 的扩展支持库<br>Multidex：多 dex 文件支持<br>Test：测试支持库</p>
<ol start="2">
<li>架构组件</li>
</ol>
<p>Data Binding：MVVM 的一种实践<br>Lifecycles：管理你的 Activity 和 Fragment 生命周期<br>LiveData：通过观察者模式感知数据变化，类比 RxJava<br>Navigation：处理 Fragment 导航相关逻辑<br>Paging：分页数据加载方案<br>Room：官方 ORM 库<br>ViewModel：通过数据驱动 V 视图发生改变<br>WorkManager：管理后台任务</p>
<ol start="3">
<li>行为组件</li>
</ol>
<p>DownloadManager：管理下载任务<br>Media App：多媒体播放和一些向后兼容的API。主要包含 MediaPlayer 和 ExoPlayer<br>Notifications：提供向后兼容的通知 API，支持 Wear 和 Auto<br>Permissions：权限管理，这个应该都接触过。用于检查和请求应用权限<br>Settings：Preference 相关 API。基本每个应用都会用到<br>Share Action：提供分享操作。这块在国内使用的不多，都是自己封装或者采用第三方方案<br>Slices：可以让应用通过外部（其他 APP）显示 APP 界面（通过设备自带的搜索，语音助手等）</p>
<ol start="4">
<li>界面组件</li>
</ol>
<p>Animations and Transitions：动画，界面转场等<br>Auto：针对车辆的标准化界面和模式<br>Emoji：表情符号相关<br>Fragment：基础概念<br>Layout：基础概念<br>Palette-Colors：调色板<br>TV：Android TV 开发相关<br>Wear：可穿戴设备（目前主要是手表）开发相关</p>
<h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><p><a href="https://blog.csdn.net/qq_34519487/article/details/103963912">https://blog.csdn.net/qq_34519487/article/details/103963912</a></p>
<p><a href="http://www.xiangxueketang.cn/enjoy/removal/article_6?sdclkid=AL2G15oN1526A6D6bo&amp;bd_vid=7921788666531507771">http://www.xiangxueketang.cn/enjoy/removal/article_6?sdclkid=AL2G15oN1526A6D6bo&amp;bd_vid=7921788666531507771</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Jetpack常用组件介绍</title>
    <url>/article/5ad2a15a.html</url>
    <content><![CDATA[<blockquote>
<p>JetPack架构组件:ViewModel、LiveData、ViewBinding、DataBinding、LifeCycle、Room等的介绍、使用场景和使用方法。</p>
</blockquote>
<a id="more"></a>


<h2 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h2><p>LifeCycle应用</p>
<blockquote>
<p>使用ltifecycle解耦页面与组件<br>使用LifecycleService解耦Service与组件<br>使用ProcessLifecycleOwner监听应用程序生命周期</p>
</blockquote>
<p>LifeCycle的好处</p>
<blockquote>
<p>1.帮助开发者建立可感知生命周期的组件<br>2.组件在其内部管理自己的生命周期，从而降低模块耦合度<br>3.降低内存泄漏发生的可能性<br>4.Activity、Fragment、Service、Application均有LifeCycle支持(LifecycleObserver、LifecycleService、ProcessLifecycleOwner)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">控件结合Lifecycle</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChronometer</span> <span class="keyword">extends</span> <span class="title">Chronometer</span> <span class="keyword">implements</span> <span class="title">Lifecycle0bserver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> elapsedTime;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyChronometer</span> <span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span> ( context, attrs) ;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span> (Lifecycle.Event.ONRESUME)   </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startMeter</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">		setpase (SystemClock.elapsedRealtime() - elapsedTime) ;</span><br><span class="line">        start ( );</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span> (Lifecycle.Event.ONSTOP)    </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopMeter</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">		elapsedTime = SystemClock.elapsedRealtime() - getBase();</span><br><span class="line">        stop () ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity添加监听</span></span><br><span class="line">getLifecycle().addOnserver(chronomter)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationService</span> <span class="keyword">extends</span> <span class="title">LifecycleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationService</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">		Log.d ( tag: <span class="string">&quot;ning&quot;</span> , msg: <span class="string">&quot;MyLocationService&quot;</span> ) ;</span><br><span class="line">		MyLocation0bserver observer = <span class="keyword">new</span> MyLocationObserver ( context: <span class="keyword">this</span>) ;</span><br><span class="line">        getLifecycle ( ) .addobserver (observer) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel的诞生</p>
<blockquote>
<p>瞬态数据丢失<br>异步调用的内存泄漏<br>类膨胀提高维护难度和测试难度</p>
</blockquote>
<p>ViewModel的作用</p>
<blockquote>
<p>1.它是介于View(视图）和Model（数据模型）之间的桥梁<br>2.使视图和数据能够分离，也能保持通信</p>
</blockquote>
<p>ViewModel的生命周期特性</p>
<blockquote>
<p>独立于配置变化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//旋转屏幕不会丢失数据</span></span><br><span class="line">MyViewModel extents ViewModel</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel</span></span><br><span class="line">viewModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>,<span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>，<span class="keyword">new</span> AndroidViewModelFactory(<span class="keyword">this</span>)).get(MViewModel.class))</span><br><span class="line">++ viewModel.num</span><br><span class="line">text.setText(viewModel.num)</span><br></pre></td></tr></table></figure>

<p>AndroidViewModel</p>
<blockquote>
<p>1.不要向ViewModel中传入Context，会导致内存泄漏<br>2.如果要使用Context，请使用AndroidViewModel中的Applications</p>
</blockquote>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>LiveData和ViewModel的关系</p>
<blockquote>
<p>在ViewModel中的数据发生变化时通知页面</p>
</blockquote>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_livedate.png" alt="Jetpack LiveData"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyviewModel</span> <span class="keyword">extends</span> <span class="title">viewModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MutableLiveData是LiveData子类</span></span><br><span class="line">	<span class="keyword">private</span> MutableLiveData&lt;Integer&gt; currentsecond;</span><br><span class="line">    <span class="comment">//private MutableLiveData&lt;Integer&gt; currentsecond = new MutableLiveData&lt;&gt;(0);</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title">getCurrentSecond</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(currentSecond == <span class="keyword">null</span>) &#123;</span><br><span class="line">			currentsecond = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">            currentsecond.setvalue (<span class="number">0</span>) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> currentSecond;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非UI线程使用postVaule(),UI线程使用setvalue()</span></span><br><span class="line">viewModel.getCurrentSecond().postValue</span><br><span class="line">    </span><br><span class="line"><span class="comment">//监听LiveData数据变化</span></span><br><span class="line">viewModel.getCurrentSecond().observe(<span class="keyword">this</span>,<span class="keyword">new</span> Observerr&lt;Interger&gt;()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(Interger i)</span></span>&#123;</span><br><span class="line">        textview.setText(String.valueOf(i));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>LiveData的优势</p>
<blockquote>
<p>确保界面符合数据状态<br>不会发生内存泄漏<br>不会因Activity停止而导致崩溃<br>不再需要手动处理生命周期<br>数据始终保持最新状态<br>适当的配置更改<br>共享资源</p>
</blockquote>
<h2 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h2><p>DataBinding的意义</p>
<blockquote>
<p>让布局文件承担了部分原本属于页面的工作，使页面与布局耦合度进一步降低</p>
</blockquote>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_databinding.png" alt="Jetpack DataBinding"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build配置</span></span><br><span class="line">dataBinding = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布局生成databinding layout</span></span><br><span class="line"><span class="comment">//导入方法：布局文件使用代码</span></span><br><span class="line"><span class="comment">//&lt;import type=&quot;com.dongnaoedu.databinding.star0tils&quot;/&gt;</span></span><br><span class="line">&lt;Layout</span><br><span class="line">&lt;data&gt;</span><br><span class="line"> &lt;variable</span><br><span class="line"> 	name=<span class="string">&quot;idol&quot;</span></span><br><span class="line"> 	type=<span class="string">&quot;com.dongnaoedu.databinding.Ido1&quot;</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//ActivityMainBinding由来</span></span><br><span class="line">ActivityMainBinding binding = DataBingingUtil.setcontentView(<span class="keyword">this</span>,R.layout.activity_main);</span><br><span class="line">Idol idol = <span class="keyword">new</span> Idol（<span class="string">&quot;name&quot;</span>,<span class="number">5</span>);</span><br><span class="line">binding.setIdol(idol);</span><br><span class="line"></span><br><span class="line"><span class="comment">//xml获取属性</span></span><br><span class="line">android:text=<span class="string">&quot;@&#123;idol.name&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按钮点击事件绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义点击事件监听类</span></span><br><span class="line">EventHandleListener&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">onclick</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加绑定</span></span><br><span class="line">binding。setEventHandleListener(<span class="keyword">new</span> EventHandleListener(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//布局文件添加事件类</span></span><br><span class="line">&lt;data&gt;</span><br><span class="line"> &lt;variable</span><br><span class="line"> 	name=<span class="string">&quot;eventHandle&quot;</span></span><br><span class="line"> 	type=<span class="string">&quot;com.dongnaoedu.databinding.EventHandleListener&quot;</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">    </span><br><span class="line">&lt;Button</span><br><span class="line">    click=<span class="string">&quot;@&#123;eventHandle.onclick&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二级页面的绑定:&lt;include&gt;标签引用二级页面</span><br><span class="line"><span class="comment">//使用下述方法传递</span></span><br><span class="line">app:idol = <span class="string">&quot;@&#123;idol&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>自定义BindingAdapter</p>
<blockquote>
<p>加载网络图片<br>方法重载，加载本地图片<br>多参数重载</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">自定义binding</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1.自定义</span></span><br><span class="line"><span class="comment">//public class ImageviewBindingAdapter</span></span><br><span class="line"><span class="comment">//加载网络图片 image注解</span></span><br><span class="line"><span class="meta">@BindingAdapter</span> ( <span class="string">&quot;image&quot;</span>)</span><br><span class="line"><span class="keyword">public</span>. .<span class="keyword">static</span>..<span class="keyword">void</span>..set Image.(ImageView...imageView..tring..url)&#123;</span><br><span class="line">	<span class="keyword">if</span>( !TextUtils.isEmpty (ur1))&#123;</span><br><span class="line">		Picasso-get(<span class="number">0</span> Picasso</span><br><span class="line">			.load (url) RequestCreator</span><br><span class="line">			.placeholder (R.drawable.ic_launcher_background).into (imageview) ;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		imageView.setBackgroundColor (color . GRAY) ;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.layout绑定</span></span><br><span class="line">&lt;data&gt;</span><br><span class="line"> &lt;variable</span><br><span class="line"> 	name=<span class="string">&quot;networkImage&quot;</span></span><br><span class="line"> 	type=<span class="string">&quot;String&quot;</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">            </span><br><span class="line">&lt;Imageview</span><br><span class="line">	android: id=<span class="string">&quot;@+id/imageView&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    app:image=&quot;</span>@ &#123;networkImage&#125;  <span class="comment">//image为注解</span></span><br><span class="line">    android: layout_width=<span class="string">&quot;300dip&quot;</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.绑定</span></span><br><span class="line">ActivityMainBinding binding = DataBingingUtil.setcontentView(<span class="keyword">this</span>,R.layout.activity_main);DataBindingUtil.setContentactivityMainBinding.setNetworkImage (<span class="string">&quot;https://gimg2.baidu.com/image_s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可选择</span></span><br><span class="line"><span class="meta">@BindingAdapter</span> (value = &#123; <span class="string">&quot;image&quot;</span>,<span class="string">&quot;defaultImageResource&quot;</span> &#125;, requireAll = <span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line">&lt;Imageview</span><br><span class="line">	android: id=<span class="string">&quot;@+id/imageView&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    app:image=&quot;</span>@ &#123;networkImage&#125;  <span class="comment">//image为注解</span></span><br><span class="line">    app:<span class="keyword">default</span>=<span class="string">&quot;@ &#123;localImage&#125;</span></span><br><span class="line"><span class="string">    android: layout_width=&quot;</span><span class="number">300d</span>ip<span class="string">&quot;            </span></span><br></pre></td></tr></table></figure>

<p>双向绑定</p>
<blockquote>
<p>BaseObservable与ObservableField</p>
</blockquote>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_databinding_baseobservable.png" alt="Jetpack DataBinding BaseObservable"></p>
<p>BaseObservable方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//User对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> string userName;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span> <span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserViewModel对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> <span class="keyword">extends</span> <span class="title">Base0bservable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserViewModel</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.user = <span class="keyword">new</span> User ( userName: <span class="string">&quot;Jack&quot;</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变对象的值View变化    </span></span><br><span class="line"><span class="meta">@Bindable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getUserName</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> user.userName ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当View变化时改变对象的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span> <span class="params">( String userName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; !userName. equals(user.userName) ) &#123;</span><br><span class="line">		user. userName = userName;</span><br><span class="line">		Log.d( tag: <span class="string">&quot;ning&quot;</span> , msg: <span class="string">&quot;set username :&quot;</span>+userName);</span><br><span class="line">        notifyPropertyChanged(BR. userName) ;<span class="comment">//通知对象的变化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;data&gt;</span><br><span class="line">	&lt;variable</span><br><span class="line">		name=<span class="string">&quot;userviewModel&quot;</span></span><br><span class="line">		type=<span class="string">&quot;com.dongnaoedu.databinding4.UserviewModel&quot;</span> /&gt;</span><br><span class="line">&lt;/ data&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向绑定@=&#123;&#125;</span></span><br><span class="line">&lt;EditText</span><br><span class="line">	android: id-<span class="string">&quot;e+id/editText&quot;</span></span><br><span class="line">	android : layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android: layout height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android : ems=<span class="string">&quot;10&quot;</span></span><br><span class="line">	android: inputType=<span class="string">&quot;textPersonName&quot;</span></span><br><span class="line">	android : text=<span class="string">&quot;@=&#123;userviewModel.userName)&quot;</span></span><br><span class="line"></span><br><span class="line">ContentactivityMainBinding.userviewModel (<span class="keyword">new</span> UserViewModel());</span><br></pre></td></tr></table></figure>

<p>ObservableField方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ObservableField&lt;User&gt; userobservableField;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserViewModel</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User ( userName: <span class="string">&quot;Jack &quot;</span> ) ;</span><br><span class="line">		userObservableField = <span class="keyword">new</span> ObservableField&lt;&gt; ();</span><br><span class="line">        userObservableField.set (user);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userObservableField.get ().userName;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span> <span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">		Log.d( tag: <span class="string">&quot;ning&quot;</span> , msg: <span class="string">&quot;userObservableField: &quot;</span>+userName) ;</span><br><span class="line">        userObservableField.get ().userName = userName ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RecycleView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//item xml布局：databinding layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span> <span class="params">(NonNull ViewGroup parent,<span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">	ItemBinding itemBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext (</span><br><span class="line">		R.layout.item,</span><br><span class="line">		parent,</span><br><span class="line">		attachToParent: <span class="keyword">false</span>) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyViewHolder (itemBinding) ;</span><br><span class="line">&#125;</span><br><span class="line">                                                                          </span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span> <span class="params">(<span class="meta">@NonNull</span> MyViewHolder holder，<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	Idol idol = idols.get (position) ;</span><br><span class="line">	holder.itemBinding.setIdol (idol) ;</span><br><span class="line">&#125;</span><br><span class="line">                                                                          </span><br><span class="line"><span class="comment">//设置适配器</span></span><br><span class="line">ActivityMainBinding binding = DatabinfingUtil.setContentView(<span class="keyword">this</span>,R.layout.activity_main);</span><br><span class="line">binding.recycleView.setLayoutManager(<span class="keyword">new</span> LinearLayputManager(<span class="keyword">this</span>))</span><br><span class="line">binding.recycleView.setAdapetr(<span class="keyword">new</span> RecycleAdapter())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>篮球计分：ViewModel + LiveData + Databinding</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">viewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; bTeamScore;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title">getbTeamScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(bTeamScore -= nul1)&#123;</span><br><span class="line">			bTeamscore = <span class="keyword">new</span> MutableLiveData&lt;&gt;();bTeanscore.setvalue (<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> bTeamScore;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bTeamAdd</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		saveLastscore() ;</span><br><span class="line">		bTeamScore.setValue (bTeamScore.getValue ()+ i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		aTeamscore.setValue (aLast);</span><br><span class="line">        bTeamScore.setValue(bLast) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xml：添加点击事件</span></span><br><span class="line">android: onClick=<span class="string">&quot;@&#123; ()-&gt;viewModel.undo ()&#125;&quot;</span> I</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主activity绑定binding</span></span><br><span class="line">ActivityMainBinding activityMainBinding m DataBindingUtil.setContentView( activity. <span class="keyword">this</span>,R.layout.acticity_main);</span><br><span class="line"><span class="comment">//设置viewmodel data</span></span><br><span class="line">MyViewWodel viewModel = <span class="keyword">new</span> ViewModelProvider ( owner. <span class="keyword">this</span>，<span class="keyword">new</span> ViewModelProvider.Android</span><br><span class="line">activityMainBinding.setViewModel (viewModel) ;</span><br><span class="line"><span class="comment">//感知生命周期</span></span><br><span class="line">activityMainBinding.setLifecycleowner(<span class="keyword">this</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DataBinding的优势</p>
<blockquote>
<p>不再需要findViewByld，项目更加简洁，可读性更高。<br>布局文件可以包含简单的业务逻辑。</p>
</blockquote>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_databinding_viewmodel.png" alt="Jetpack Databinding Viewmodel"></p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Room重要概念:</span><br><span class="line">Entity:实体类，对应的是数据库的一张表结构，使用注解@Entity标记&gt;</span><br><span class="line">Dao:包含访问一系列访问数据库的方法，使用注解@Dao标记。//Data Access Objects</span><br><span class="line">Database:数据库持有者，作为与应用持久化相关数据的底层连接的主要接入点。使用注解@Database标记，另外需满足以下条件:定义的类必须是一个继承于RoomDatabase的抽象类，在注解中需要定义与数据库相关联的实体类列表。包含一个没有参数的抽象方法并且返回一个Dao对象。</span><br></pre></td></tr></table></figure>

<p>app从Database得到get DAO,从DAO得到Entity，从Entity得到和设置对象值</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_room.png" alt="Jetpack Room"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.room: room-runtime: 2.2.5&#x27;</span></span><br><span class="line">//注解器：抽象类自动生成实现类</span><br><span class="line">annotationProcessor <span class="string">&#x27;androidx .room:room-compiler:2.2.5&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Entity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span> (tableName - <span class="string">&quot;student&quot;</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@PrimaryKey</span> (autoGenerate = <span class="keyword">true</span>)</span><br><span class="line">       <span class="meta">@ColumnInfo(name = &quot;id&quot;,typeAffinity = ColumnInfo.INTEGER)</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="meta">@ColumnInfo(name = &quot;name&quot;, typeAffinity = ColumnInfo.TEXT)</span></span><br><span class="line">       <span class="keyword">public</span> string name;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@columnInfo(name = &quot;name&quot;,typeAffinity = ColumnInfo.TEXT)</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">student</span> <span class="params">(<span class="keyword">int</span> id,String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">           <span class="keyword">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// Ignore注解 room会自动忽略此构造函数      </span></span><br><span class="line"><span class="meta">@Ignores</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">student</span> <span class="params">(string name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dao：增删查改接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span> <span class="params">(student. .- students)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deletestudent</span> <span class="params">(student. . . students)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span> <span class="params">(Student . . . students)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span> ( <span class="string">&quot;SELECT *FROMstudent&quot;</span>)</span><br><span class="line">	<span class="function">List&lt;Student&gt; <span class="title">getAllstudent</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span> (<span class="string">&quot;SELECT * FROM student WHERE id = :id&quot;</span>)</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Database</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database</span> (entities = &#123;Student.class&#125;, version = <span class="number">1</span>, exportSchema = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> string DATABASE_NAME= <span class="string">&quot;my_db. db&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyDatabase mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> MyDatabase <span class="title">getInstance</span> <span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mInstance == nul1) &#123;</span><br><span class="line">			mInstance = Room. databaseBuilder(context.getApplicationContext(),</span><br><span class="line">			MyDatabase.class,</span><br><span class="line">			DATABASE_NAME<span class="string">&#x27;).build() ;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return minstance;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	public abstract StudentDao getStudentDao ();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyDatabase database = MyDatabase.getInstance (<span class="keyword">this</span>);</span><br><span class="line">studentDao = database.getStudentDao ( ) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mlnsert</span> <span class="params">(View view)</span></span>&#123;</span><br><span class="line">	student s1 = <span class="keyword">new</span> Student ( name: <span class="string">&quot;Jack&quot;</span> , age: <span class="number">20</span>) ;</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student( name: <span class="string">&quot;Rose&quot;</span>,age: <span class="number">1</span> ;<span class="keyword">new</span> 		</span><br><span class="line">    InsertStudentTask (studentDao).execute (s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//room不允许在主线程执行数据库操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertStudentTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Student</span>, <span class="title">Void</span>,<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> studentDao studentDao;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsertStudentTask</span> <span class="params">(StudentDao studentDao)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span> . studentDao - studentDao;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span> <span class="params">(Student. . . students)</span> </span>&#123;</span><br><span class="line">		studentDao.insertStudent ( students) ;</span><br><span class="line">        rerurn <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步优化</p>
<blockquote>
<p>问题:每当数据库数据发生变化时，都需要开启一个工作线程去重新获取数据库中的数据。<br>解决:当数据发生变化时，通过LiveData通知View层，实现数据自动更新。</p>
</blockquote>
<p>Room+ViewModel+LiveData</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_viewmodel_room_livedata.png" alt="Jetpack Viewmodel Room Livedata"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Repository:通过Repository操作数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">studentRepository</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentRepository</span> <span class="params">(Context context)</span></span>&#123;</span><br><span class="line">		MyDatabase database = MyDatabase.getInstance ( context) ;</span><br><span class="line">        <span class="keyword">this</span>.studentDao = database.getStudentDao ( ) ;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStudent</span> <span class="params">(Student. . . students)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> InsertStudentTask(studentDao) .execute (students);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InsertStudentTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Student</span>, <span class="title">Void</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> studentDao studentDao;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">InsertStudentTask</span><span class="params">(StudentDao studentDao)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.studentDa</span><br><span class="line">			</span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span> <span class="params">(Student. . . students)</span> </span>&#123;</span><br><span class="line">				studentDao.insertstudent (students) ;</span><br><span class="line">				<span class="keyword">return</span> nul1;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewModel:ViewModel传递上下文对象需要用AndroidViewModel</span></span><br><span class="line"><span class="comment">//ViewModel保存数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">studentViewModel</span> <span class="keyword">extends</span> <span class="title">AndroidViewModel</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> studentRepository repository ;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentViewModel</span> <span class="params">( <span class="meta">@NonNull</span> Application application)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(application) ;</span><br><span class="line">		<span class="keyword">this</span>.repository = <span class="keyword">new</span> StudentRepository(application) ;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStudent</span> <span class="params">(Student. . . students)</span> </span>&#123;</span><br><span class="line">		repository.insertStudent(students) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity只需要和ViewModel交互即可</span></span><br><span class="line">studentViewModel = <span class="keyword">new</span> ViewModelProvider ( owner: <span class="keyword">this</span>, <span class="keyword">new</span></span><br><span class="line">ViewModelProvider.AndroidviewModelFactory(getApplication()).get(StudentViewModel.class)</span><br><span class="line"><span class="comment">//Livedata自动更新</span></span><br><span class="line">studentViewModel.getAllStudentsLive () .observe ( owner: <span class="keyword">this</span>，<span class="keyword">new</span> Observer&lt;List&lt;Student&gt;&gt;()</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span> <span class="params">(List&lt;Student&gt; students)</span></span>&#123;</span><br><span class="line">		adapter.setstudents ( students ) ;</span><br><span class="line">		adapter.notifyDataSetChanged ( );</span><br><span class="line">	&#125;);</span><br><span class="line"> &#125;</span><br><span class="line">                                          </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mInsert</span> <span class="params">(View view)</span> </span>&#123;</span><br><span class="line">	Student s1 = <span class="keyword">new</span> student ( name: <span class="string">&quot;Jack&quot;</span>, age: <span class="number">20</span>) ;</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student ( name: <span class="string">&quot;Rose&quot;</span>, age: <span class="number">18</span>);</span><br><span class="line">    studentviewModel .insertStudent (s1,s2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>room版本升级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>构造Migration</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_1_2 = <span class="keyword">new</span> Migration (<span class="number">1</span>,<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span> <span class="params">(<span class="meta">@NonNull</span> SupportSQLiteDatabase database)</span></span>&#123;</span><br><span class="line">		database.execSQL ( <span class="string">&quot;ALTERTABLE student ADD COLUMN sex INTEGER NOT NULLDEFAULT 1&quot;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>添加addMigrations</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> MyDatabase <span class="title">getInstance</span> <span class="params">(Context context)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( mInstance -= nul1)&#123;</span><br><span class="line">		mInstance = Room. databaseBuilder(context.getapplicationContext(),	</span><br><span class="line">                                          MyDatabase.class,</span><br><span class="line">                                          DATABASE_NAME)</span><br><span class="line">	.addMigrations (MIGRATION_1_2,MIGRATION_2_3)</span><br><span class="line">            .build () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mlnstance;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>修改注解</span><br><span class="line"><span class="meta">@Database</span> (entities = &#123;Student.class&#125;, version = <span class="number">2</span>, exportSchema = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<p>使用Migration升级数据库</p>
<blockquote>
<p>问题:如果用户设备上数据库版本为1，而当前要安装的App数据库版本为3，怎么办?<br>Room会先判断当前有没有直接从1到3的升级方案，如果有，就直接执行从1到3的升级方案，如果没有，那么Room会按照顺序先后执行Migration(1,2)、Migration(2,3)以完成升级。</p>
</blockquote>
<h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Navigation的主要元素</span><br><span class="line">1.Navigation Graph，一种新的XML资源文件，包含应用程序所有的页面以及页面间的关系。</span><br><span class="line">2.NavHostFragment，一个特殊的Fragment，可以将它看作是其他Fragment的容器，Navigation Graph中的Fragment正是通过NavHostFragment进行展示的。</span><br><span class="line">3.NavController，用于在代码中完成Navigation Graph中具体的页面切换工作。</span><br><span class="line"></span><br><span class="line">他们三责之间的关系当你想切换Fragment时，使用NavController对象，告诉它你想要去Navigation Graph中的哪个Fragment,NavController会将你想去的Fragment展示NavHostFragment中。</span><br><span class="line"></span><br><span class="line">创建顺序：</span><br><span class="line">Fragment -&gt; Navigation Graph -&gt; main_layout:NavHostFragment -&gt; -&gt;</span><br><span class="line"></span><br><span class="line">NavController navController = Navigation.findNavController( activity: this，R.id.fragment);</span><br><span class="line">NavigationUI.setupActionBarWithNavController( activity: this, navController);</span><br></pre></td></tr></table></figure>

<p>NavigationUl的作用</p>
<blockquote>
<p>Fragment的切换，除了Fragment页面本身的切换，通常还伴有App bar的变化。为了方便统一管理，Navigation组件引入了NavigationUI类。</p>
</blockquote>
<p>更多支持<br>App bar</p>
<blockquote>
<p>ActionBar<br>Toolbar<br>CollapsingToolbarLayout</p>
</blockquote>
<p>menu</p>
<blockquote>
<p>抽屉菜单 (DrawLayout+Navigation View)<br>底部菜单(（BottomNavigationView)</p>
</blockquote>
<h2 id="Jetpack-Kotlin-MVVM项目"><a href="#Jetpack-Kotlin-MVVM项目" class="headerlink" title="Jetpack+Kotlin+MVVM项目"></a>Jetpack+Kotlin+MVVM项目</h2><p>采用 <a href="https://developer.android.com/jetpack">Jetpack</a> +Kotlin <a href="https://github.com/Kotlin/kotlinx.coroutines">协程</a>实现的 MVVM 架构项目：<a href="https://github.com/VIPyinzhiwei/Eyepetizer">Eyepetizer)</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
        <tag>ViewModel</tag>
        <tag>DataBinding</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows修改DNS方法</title>
    <url>/article/7c78b42f.html</url>
    <content><![CDATA[<blockquote>
<p>DNS是域名系统，我们链接互联网的时候，仅仅有一个IP地址是不够的，还需要设置域名，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取IP数串。通过域名，最终得到该域名对应IP地址的过程叫做域名解析（或主机名解析）。</p>
</blockquote>
<a id="more"></a>

<p>修改DNS的好处就是可以适当提高上网速度；更换DNS可以访问某些因为域名解析存在问题而不能访问的网站；可以屏蔽运营商的广告，还可以帮助您避免被钓鱼的危险；</p>
<p>当然修改DNS也有可能带来副作用，比如无法访问页面或者访问的页面不是你想要的页面；访问速度没有你从运营商处获得的DNS访问分速度快，延时比较大；受到DNS劫持，插入广告和被钓鱼网站攻击。</p>
<h3 id="Windows修改DNS步骤"><a href="#Windows修改DNS步骤" class="headerlink" title="Windows修改DNS步骤"></a>Windows修改DNS步骤</h3><p>1.打开windows设置，找到并单击“网络和Internet”选项;</p>
<p>2.右侧下拉找到“更改适配器选项”，单击打开;</p>
<p>3.右键你的以太网，选择“属性”打开;</p>
<p>4.进入后下拉下方选项，找到“Internet 协议版本 4 (TCP/IPv4)”选项并选中，单击“属性”进入;</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/dns_ipv4.png" alt="TCP/IPV4属性"></p>
<p>5.进入后即可勾选为“使用下面的DNS服务器地址”选项，进行DNS服务器设置，确定保存即可。</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/dns_server.png" alt="DNS服务器设置"></p>
<p>6.返回桌面重启电脑或者重启网卡即可设置完成。</p>
<h3 id="常用的DNS服务器"><a href="#常用的DNS服务器" class="headerlink" title="常用的DNS服务器"></a>常用的DNS服务器</h3><ul>
<li><p>阿里的DNS是223.5.5.5和223.6.6.6</p>
</li>
<li><p>百度的DNS是180.76.76.76</p>
</li>
<li><p>114的DNS是114.114.114.114和114.114.115.115</p>
</li>
<li><p>谷歌的DNS是8.8.8.8和8.8.8.4</p>
</li>
<li><p>微软官方推荐使用的DNS服务器地址为4.2.2.1以及4.2.2.2</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端开发常用的开发工具</title>
    <url>/article/bdc11bc8.html</url>
    <content><![CDATA[<blockquote>
<p>分享的关于Web前端开发常用的十款很优秀的开发工具汇总。</p>
</blockquote>
<a id="more"></a>

<ol>
<li>Glitch<br><a href="https://glitch.com/">https://glitch.com</a><br>好的，这不仅仅是一个工具，还是一个非常棒的编码平台以及一个很棒的技术社区。我可以在内置代码编辑器的帮助下托管我的项目。支持多种语言，但最适合NodeJS。</li>
<li>Shadows<br><a href="https://brumm.af/shadows">https://brumm.af/shadows</a><br>这个网站提供生成平滑阴影的CSS代码，可以创建平滑的边框阴影。它看起来真的很流畅，令人满意。</li>
<li>Coolors<br><a href="https://coolors.co/">https://coolors.co</a><br>这是一款非常好的在线工具，可以为项目生成匹配的颜色方案。如果不喜欢当前的方案，按下空格键，它会重新生成一个配色方案，直到你满意~</li>
<li>Blobmaker<br><a href="https://blobmaker.app/">https://blobmaker.app</a><br>Blobmaker可帮助你随机生成各种尺寸，不同颜色和形状的SVG Blob。你可以用作背景或创建看起来很酷的动画。</li>
<li>Getwavs<br><a href="https://getwaves.io/">https://getwaves.io</a><br>与Blobmaker相似，Get Waves能够随机生成不同颜色和不同数量的波浪。用作网页的页脚或页眉看起来不错。</li>
<li>Undraw.co<br><a href="https://undraw.co/">https://undraw.co</a><br>开放源代码项目的SVG插图集，可用来做登录页面，404页面等，当然普通页面也能用!上面的插图可以不带归属地版权的使用，无需支付任何费用。</li>
<li>Marcdown<br><a href="https://liyasthomas.github.io/marcdown">https://liyasthomas.github.io/marcdown</a><br>由Liyas Thomas提供的在线实时的Markdown网页编辑器，它可预览Markdown代码，将其发布到GitHub上。它提供一个非常漂亮的暗黑模式。还可脱机工作，这使得它显得更出色。</li>
<li>postwoman<br><a href="https://postwoman.io/">https://postwoman.io</a><br>这是Liyas Thomas构建的另一个工具。Postwoman是一个API请求构建工作。开发者可以不使用代理来测试 API。这是一个渐进式Web应用程序，可以保存到桌面来用。它是轻量级的产品，基本上可以是Postman的在线替代品。</li>
<li>Screely.com<br><a href="https://screely.com/">https://screely.com</a><br>它可以帮助你创建超级漂亮的网站截图模型。如果你不是MacBook用户，但需要更好的网站图片作为自述文件，它非常适合我们。</li>
<li>CSS网格生成器<br><a href="https://cssgrid-generator.netlify.com/">https://cssgrid-generator.netlify.com/</a><br>这是Sarah Drasner的创建的优秀网站，它使用CSS创建动态网格布局。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Glitch</tag>
        <tag>Postman</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体视频处理工具FFmpeg</title>
    <url>/article/b3c1f4b1.html</url>
    <content><![CDATA[<blockquote>
<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。</p>
</blockquote>
<a id="more"></a>

<p>FFmpeg常用命令解析<br><a href="https://www.cnblogs.com/Dicky-Zhang/p/11838416.html">https://www.cnblogs.com/Dicky-Zhang/p/11838416.html</a></p>
<p>ffFFmpegpg处理视频<br>example：m3u8转mp4<br><a href="https://www.cnblogs.com/zhangceblogs/p/8514443.html">https://www.cnblogs.com/zhangceblogs/p/8514443.html</a></p>
<p><a href="https://github.com/FFmpeg/FFmpeg">https://github.com/FFmpeg/FFmpeg</a><br><a href="https://github.com/BtbN/FFmpeg-Builds">https://github.com/BtbN/FFmpeg-Builds</a><br>下载：ffmpeg-n-104327-g1902a60dda-win64-gpl.zip</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Java技能树-Java概述</title>
    <url>/article/761b2c7d.html</url>
    <content><![CDATA[<blockquote>
<p>Java概述：Java程序的Hello World、JDK安装和环境配置、Java的编译和运行、JVM虚拟机、Maven管理工具</p>
</blockquote>
<a id="more"></a>

<h2 id="编辑Java源代码"><a href="#编辑Java源代码" class="headerlink" title="编辑Java源代码"></a>编辑Java源代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWord&#123;</span><br><span class="line">    &#x2F;&#x2F;java程序的入口方法，程序将从这里开始执行</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;向控制台打印一条语句</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译Java程序"><a href="#编译Java程序" class="headerlink" title="编译Java程序"></a>编译Java程序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>

<h2 id="Java的运行机制"><a href="#Java的运行机制" class="headerlink" title="Java的运行机制"></a>Java的运行机制</h2><blockquote>
<p>🍎Java程序运行时,必须经过编译和运行两个步骤。<br>🍊 首先将后缀名为.java的源文件进行编译,最终生成后缀名为.class的字节码文件。然后Java虚拟机将字节码文件进行解释执行,并将结果显示出来<br>🍉Java程序的运行过程详细解释<br>🍋1、编写一个HelloWorld.java文件<br>🍋2、使用javac HelloWorld.java 命令开启Java编译器并进行编译。编译结束后,会自动生成一个HelloWorld.class的字节码文件<br>🍋3、使用java HelloWorld 命令启动Java虚拟机运行程序,Java虚拟机首先将编译好的字节码文件加载到内存,<strong>这个过程被称为类加载</strong>,它是由类加载器完成的,然后虚拟机针对加载到内存中的Java类进行解释执行,便可看到运行结果</p>
</blockquote>
<p>以下关于Java的运行机制中描述正确的是：</p>
<ol>
<li>ClassLoader 是 JVM 实现的一部分</li>
<li>Java 编译器会将程序编译为 Java 虚拟机可以执行的字节码</li>
<li>Java 虚拟机（Java Virutal Machine）简称 JVM ，用于执行 Java 字节码</li>
<li>Java 运行时环境（Java Runtime Evironment）简称 JRE ，用于运行 Java 程序，包含 JVM</li>
<li>Java 开发工具包（Java Development Kit）用于开发Java程序，包含JRE和 Java 编译工具等</li>
</ol>
<blockquote>
<p>Java语言具有”一次编写,到处运行(Write one , run anywhere)”的特点,有效地解释了程序设计语言在不同操作系统编译时产生不同机器代码的问题,大大降低了程序开发和维护的成本。需要注意的是,Java程序通过Java虚拟机可以达到跨平台特性,但Java虚拟机并不是跨平台的,也就是说,不同操作系统上的Java虚拟机是不同的,即Windows平台上的Java虚拟机不能使用在Linux平台上。</p>
</blockquote>
<h2 id="Java程序的环境配置"><a href="#Java程序的环境配置" class="headerlink" title="Java程序的环境配置"></a>Java程序的环境配置</h2><p>安装完JDK(Java Development Kit，Java开发套件)之后，可以在安装目录下找到两个子目录(bin目录和lib目录)。bin目录中包含着Java编译器等可执行文件。</p>
<p>如果要运行执行java命令，必须得执行java命令对应的可执行文件的路径，通常有两种方式：</p>
<ul>
<li>在%JAVA_HOME%目录下执行。</li>
<li>执行命令的时候，指明路径%JAVA_HOME%/bin/java</li>
</ul>
<p>但是，这样不是特别方便，这就是为什么配置环境变量。</p>
<p>JAVA_HOME环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_51\</span><br></pre></td></tr></table></figure>

<p>通常将下面的内容加到PATH环境变量的最左侧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%&#x2F;bin&#x2F;;%JAVA_HOME%&#x2F;jre&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>和PATH变量不同，CLASSPATH环境变量的作用是指定Java类所在的目录(或许它的意思就是<code>PATH of Class</code>)。</p>
<p>Java中通常将环境变量CLASSPATH配置为<code>.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar</code>。其中为何包含<code>.</code>，</p>
<p>dt.jar：运行环境类库，主要是Swing包，这一点通过用压缩软件打开dt.jar也可以看到。如果在开发时候没有用到Swing包，那么可以不用将dt.jar添加到CLASSPATH变量中。</p>
<p>tools.jar：工具类库，它跟我们程序中用到的基础类库没有关系。我们注意到在Path中变量值bin目录下的各个exe工具的大小都很小，一般都在27KB左右，这是因为它们实际上仅仅相当于是一层代码的包装，这些工具的实现所要用到的类库都在tools.jar中，用压缩软件打开tools.jar,你会发现有很多文件是和bin目录下的exe工具相对性的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c:\test&gt;type HelloWorld.java   #查看文本文件的内容</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                System.out.println(&quot;Hello World!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">c:\test&gt;javac HelloWorld.java   #因为配置了PATH环境变量，在任意目录下都可执行javac</span><br><span class="line"></span><br><span class="line">c:\test&gt;dir   #查看编译生成的class文件</span><br><span class="line">2016&#x2F;03&#x2F;28  22:13               427 HelloWorld.class</span><br><span class="line">2016&#x2F;03&#x2F;28  22:08               152 HelloWorld.java</span><br><span class="line">c:\test&gt;java HelloWorld   #运行HelloWorld(注意，不能加.class后缀)</span><br><span class="line">错误: 找不到或无法加载主类 HelloWorld</span><br></pre></td></tr></table></figure>

<h2 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h2><p>Maven的作用</p>
<p>maven本质上是一个项目管理工具，是将项目开发和管理过程抽象成一个项目对象模型（POM:project object model）</p>
<p>maven可以为我们进行项目构建(提供标准化，跨平台的zi’dong话项目构建方式)，依赖管理(方便快捷的管理项目的依赖资源jar包，避免资源及版本的冲突)，同意开发结构：提供标准统一的项目结构。</p>
<p>Maven的安装：maven属于是绿色软件，解压即安装</p>
<p><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>Maven文件结构：</p>
<ul>
<li>bin:maven的核心运行文件</li>
<li>boot：mavem的类加载器</li>
<li>conf：maven的核心配置</li>
<li>lib：maven的依赖jar包</li>
</ul>
<p>Maven环境变量配置</p>
<ul>
<li>依赖于java，需要配置JAVA_HOME</li>
<li>设置Maven自身的MAVEN_HOME</li>
<li>运行cmd输入mvn检测是否安装成功</li>
</ul>
<p>Maven的基础概念</p>
<p><strong>仓库</strong>：用于存储各种资源，包含各种jar包</p>
<p><img src="https://img-blog.csdnimg.cn/c67076183eeb4a2394e5ee869ffecc44.png" alt="img"></p>
<p>仓库分类：</p>
<ul>
<li>本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源</li>
<li>远程仓库：非自己电脑上的仓库，为本地仓库提供资源</li>
<li><ul>
<li>中央仓库：Maven团队维护，存储所有资源的仓库</li>
<li>私服：部门/公司范围内存储的仓库，从中央仓库获取资源</li>
</ul>
</li>
<li>私服的作用：</li>
<li><ul>
<li>保存具有版权的资源，包含自主研发或购买的jar(中央仓库的的jar包都是开源的，不能存储具有版权的资源)</li>
<li>一定范围内共享资源，仅对内部开放，不对外共享。</li>
</ul>
</li>
</ul>
<h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>坐标是用来在仓库中资源的位置的。</p>
<p><a href="https://repo1.maven.org/maven2/%E8%AF%A5%E9%93%BE%E6%8E%A5%E4%B8%AD%E6%98%AFmaven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E8%B5%84%E6%BA%90%E3%80%82">https://repo1.maven.org/maven2/该链接中是maven中央仓库资源。</a></p>
<p>maven坐标的组成：</p>
<ul>
<li>groupId:定义当前Maven项目隶属于组织的名称（通常是域名反写）</li>
<li>artifactld:定义当前Maven项目的名称（通常是模块名称，例如：CRM,SMS）</li>
<li>version:定义当前项目的版本号</li>
<li>packaging:定义当前项目的打包方式</li>
</ul>
<h4 id="本地仓库配置"><a href="#本地仓库配置" class="headerlink" title="本地仓库配置"></a>本地仓库配置</h4><ol>
<li><p>进入Maven的conf文件夹中的setting文件</p>
<ul>
<li><p>默认的仓库配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义自己的仓库位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;localRepository&gt;D:\maven\repository&lt;&#x2F;localRepository&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中央仓库的配置位置</p>
<p>在lib文件中随便找一个jar包用winrar打开，然后返回上一级目录搜索pom*.*,找到pom-4.0.0.xml文件，定位到。将文件拖出后打开。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/9f4df60aad1443bca569a9a81a7a0763.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3LTSJRym-1638532754173)(D:\Document\note\框架\maven\远程仓库.png)]"></p>
<ul>
<li><p>远程镜像仓库的配置（当需要访问中央仓库的时候，就会去访问镜像仓库。ps:中央仓库在国外，访问速度慢）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置具体仓库的下载镜像 --&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;!-- 此镜像的唯一标识符，用来区分不同的mirror元素 --&gt;</span><br><span class="line">    &lt;id&gt;ali-maven&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;!-- 对哪种仓库进行镜像，简单说就是代替哪个仓库 --&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">    &lt;!-- 镜像的名称 --&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;!-- 镜像的URL --&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="Maven项目构建命令"><a href="#Maven项目构建命令" class="headerlink" title="Maven项目构建命令"></a>Maven项目构建命令</h4><p>后面的命令在执行的时候都会执行前面的命令，如：在执行install的时候前面的生命周期都会执行。</p>
<ul>
<li><p>mvn -v 查看版本</p>
</li>
<li><p>mvn compile 编译(在src同级目录下生成一个target文件)</p>
</li>
<li><p>mvn clean 清理(删除target文件)</p>
</li>
<li><p>mvn test 测试(会在编译同时将test的部分也编译，并执行test内测试方法的内容，在surefile-reports中生成报告内容)</p>
</li>
<li><p>mvn package 打包(target文件中生成一个jar包)</p>
</li>
<li><p>mvn install 安装到自己本地仓库</p>
</li>
<li><p>mvn archetype: generate生成maven项目</p>
</li>
</ul>
<h4 id="idea使用maven命令"><a href="#idea使用maven命令" class="headerlink" title="idea使用maven命令"></a>idea使用maven命令</h4><p> 在idea的右边有一个maven选项，打开后点击声明周期可以运行maven的命令（与命令效果相同）</p>
<p>也可以点击上方的锤子选择Maven，添加命令在执行达到一样的效果（<strong>优点</strong>：可以使用debug模式运行）</p>
<h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    <span class="comment">//单个依赖</span></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;排除包含</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &#x2F;&#x2F;具体排除的依赖</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br></pre></td></tr></table></figure>

<h4 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h4><ul>
<li>依赖的jar默认可以在任何地方使用，可以通过scope标签设定其作用的范围</li>
<li>作用范围</li>
<li><ul>
<li>主程序范围内有效(main文件范围内)</li>
<li>测试程序范围内有效(test文件范围内)</li>
<li>是否参与打包(package指令范围内)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">scope</th>
<th align="left">主代码</th>
<th align="left">测试代码</th>
<th align="left">打包</th>
<th align="left">范例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">compolie(默认)</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">log4j</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left"></td>
<td align="left">Y</td>
<td align="left"></td>
<td align="left">junit</td>
</tr>
<tr>
<td align="left">provided</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left"></td>
<td align="left">servlet-api</td>
</tr>
<tr>
<td align="left">runtime</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">Y</td>
<td align="left">jdbc</td>
</tr>
</tbody></table>
<h3 id="项目的构建生命周期"><a href="#项目的构建生命周期" class="headerlink" title="项目的构建生命周期"></a>项目的构建生命周期</h3><p> Maven对项目构建生命周期分为三个阶段,不同阶段有不同的过程事件</p>
<ul>
<li>clean:清理工作</li>
<li><ul>
<li>pre-clean :执行一些需要在clean之前完成的工作</li>
<li>clean:移除上一次构建生成的文件</li>
<li>post-clean:执行一些在clean之后立即完成的工作</li>
</ul>
</li>
<li>defult:核心工作，例如编译，测试，打包，部署等</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/cc6ab85acf374e68a5cd5f1fda5348d6.png" alt="img"></p>
<ul>
<li>site:产生报告，发布站点</li>
<li><ul>
<li>pre-site:执行一些在生成站点文件前要完成的工作</li>
<li>site:生成项目的站点文件</li>
<li>post-site:执行一些需要在生成站点文件后完成的工作，为部署做准备</li>
<li>site-deploy:将生成的站点文档部署到特定的服务器上</li>
</ul>
</li>
</ul>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul>
<li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应插件功能</li>
<li>默认Maven的各个生命周期上绑定有预定的预设功能</li>
<li>通过插件可以自定义其他功能</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--具体插件：对test区域源代码的打jar--&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">    &lt;!--插件的行为--&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;!--具体行为--&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;!--目标：执行的结果，这里时打jar包，并未所有的插件都有--&gt;</span><br><span class="line">                &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">     			 &lt;!--可以打多个jar包--&gt;</span><br><span class="line">    			&lt;goal&gt;test-jar&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;!--在哪个阶段执行--&gt;</span><br><span class="line">            &lt;phase&gt;generate-test-sources&lt;/phase&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的几个重要特性</title>
    <url>/article/7f3a79dc.html</url>
    <content><![CDATA[<blockquote>
<p>Java应用中的几个重要特性：多态、泛型、反射、集合、正则、引用分类。</p>
</blockquote>
<a id="more"></a>

<h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1.多态"></a>1.多态</h3><p>多态就是同一个行为，使用不同的实例而发生不同的作用。在使用多态调用方法的时候，编译器检查父类中是否有该方法，如果有才能编译通过，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>&#123;动物叫&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>&#123;猫叫&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testVoice</span><span class="params">(Animals a)</span></span>&#123;</span><br><span class="line">    a.voice();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    testVoice(<span class="keyword">new</span> Cat())；</span><br><span class="line"></span><br><span class="line">    Animals a = <span class="keyword">new</span> Cat();</span><br><span class="line">    a.voice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猫继承自动物这个类，Animals a = new Cat()是向上转型（父类引用指向子类对象），实际的<strong>运行时类型</strong>还是Cat，也就是说a instanceof Cat 表达式为真，因此调用a的voice()方法是猫叫。结合C的指针和内存分析来理解多态。</p>
<h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2.泛型"></a>2.泛型</h3><ol>
<li>类型通配符</li>
</ol>
<ul>
<li>&lt;? extends T&gt;表示该通配符所代表的类型是T类型的子类。</li>
<li>&lt;? super T&gt;表示该通配符所代表的类型是T类型的父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Closable&gt; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T temp:a)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>泛型不能用在静态属性上</li>
<li>指定的类型不能为基本类型</li>
</ol>
<h3 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h3><ol>
<li>获取目标类型的Class对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; a = Object.getClass();</span><br><span class="line">Class&lt;?&gt; b = T.class;</span><br><span class="line">Class&lt;?&gt; c = Class.forName(...);</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象<ul>
<li>不带 “Declared”的方法支持取出包括继承、公有（Public） &amp; 不包括有（Private）的构造函数</li>
<li>带 “Declared”的方法是支持取出包括公共（Public）、保护（Protected）、默认（包）访问和私有（Private）的构造方法，但不包括继承的构造函数</li>
</ul>
</li>
</ol>
<ul>
<li>Constructor</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.获取指定的构造函数（公共/继承）</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//b.获取所有的构造函数（公共/继承） </span></span><br><span class="line">Constructor&lt;?&gt;[] getConstructors(); </span><br><span class="line"><span class="comment">//c.获取指定的构造函数（不包括继承）</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//d.获取所有的构造函（不包括继承）</span></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors(); </span><br></pre></td></tr></table></figure>

<ul>
<li>Field</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.获取指定的属性（公共/继承）</span></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//b.获取所有的属性（公共/继承）</span></span><br><span class="line">Field[] getFields();</span><br><span class="line"><span class="comment">//c.获取指定的所有属性（不包括继承）</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//d.获取所有的所有属性（不包括继承）</span></span><br><span class="line">Field[] getDeclaredFields();</span><br></pre></td></tr></table></figure>

<ul>
<li>Method</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.获取指定的方法（公共/继承）</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//b.获取所有的方法（公共/继承）</span></span><br><span class="line">Method[] getMethods();</span><br><span class="line"><span class="comment">//c.获取指定的方法 （不包括继承）</span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//d.获取所有的方法（不包括继承）</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br></pre></td></tr></table></figure>

<h3 id="4-集合"><a href="#4-集合" class="headerlink" title="4. 集合"></a>4. 集合</h3><ol>
<li>迭代器遍历ArrayList</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;TAG&quot;</span>,ite.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历Map</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种：map.keySet()</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; value= &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：map.entrySet().iterator()</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; value= &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//第三种：map.entrySet()</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; value= &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//第四种：map.values()</span></span><br><span class="line"><span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历 hashMap() 时 entrySet() 方法是将 key 和 value 全部取出来,所以性能开销是可以预计的, 而 keySet() 方法进行遍历的时候是根据取出的 key 值去查询对应的 value 值, 所以如果 key 值是比较简单的结构(如 1,2,3…)的话性能消耗上是比 entrySet() 方法低, 但随着 key 值得复杂度提高 entrySet() 的优势就会显露出来。</li>
<li>在只遍历 key 的时候使用 keySet(), 在只遍历 value 的时候使用 values(), 在遍历 key-value 的时候使用 entrySet()。</li>
</ol>
<h3 id="5-正则"><a href="#5-正则" class="headerlink" title="5.正则"></a>5.正则</h3><p>RegexBuddy</p>
<ol>
<li>转义字符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\n  \t  \\  \^  \$  \(  \)  \&#123;  </span><br><span class="line">\&#125;  \?  \+  \*  \|  \[  \]</span><br></pre></td></tr></table></figure>

<ol>
<li>标准字符集合（大写取反）</li>
</ol>
<table>
<thead>
<tr>
<th align="left">\d</th>
<th align="left">0~9的任意一个数字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\w</td>
<td align="left">A<del>Z, a</del>z, 0~9, _中任意一个</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">空格、制表符、换行符等空白符的任意一个</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意一个字符</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">匹配方括号中任意一个字符</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">方括号取反</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">方括号中表示范围</td>
</tr>
<tr>
<td align="left">{}</td>
<td align="left">花括号前正则表达式的重复次数，{m,n}至少m次，最多n次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">花括号后加，非贪婪模式。非花括号后加，相当于{0,1}</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">前面的正则表达式至少出现一次，相当于{1,}</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">表达式不出现或出现多次，相当于{0,}</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">与字符串开始的地方匹配</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">与字符串结束的地方匹配</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个字符边界</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">匹配左边或者右边</td>
</tr>
<tr>
<td align="left">(?=exp)</td>
<td align="left">断言自身出现的位置的后面能匹配表达式exp</td>
</tr>
<tr>
<td align="left">(?&lt;=exp)</td>
<td align="left">断言自身出现的位置的前面能匹配表达式exp</td>
</tr>
<tr>
<td align="left">(?!exp)</td>
<td align="left">断言此位置的后面不能匹配表达式exp</td>
</tr>
<tr>
<td align="left">(?&lt;!exp)</td>
<td align="left">断言此位置的前面不能匹配表达式exp</td>
</tr>
</tbody></table>
<h3 id="6-引用分类"><a href="#6-引用分类" class="headerlink" title="6.引用分类"></a>6.引用分类</h3><ol>
<li>强引用:StrongReference:引用指向对象，gc运行时不回收</li>
<li>软引用:SoftReference:gc运行时回收，（jvm内存不够）</li>
<li>弱引用:WeakReference:gc运行时立即回收</li>
<li>虚引用:PhantomReference:跟踪对象被回收的状态，必须与ReferenceQueue一起使用</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java技能树-基本语法和变量及常量</title>
    <url>/article/d37d704e.html</url>
    <content><![CDATA[<blockquote>
<p>基本语法和变量及常量：Java的语法格式、注释、关键字、数据类型、常量和变量的声明及其作用域。</p>
</blockquote>
<a id="more"></a>

<h2 id="Java的基本语法"><a href="#Java的基本语法" class="headerlink" title="Java的基本语法"></a>Java的基本语法</h2><h3 id="Java的基本语法格式"><a href="#Java的基本语法格式" class="headerlink" title="Java的基本语法格式"></a>Java的基本语法格式</h3><p>每一种编程语言都有一套自己的语法规范,Java 语言也不例外,同样需要遵从一定的语法规范,如代码的书写、标识符的定义、关键字的应用等。因此要学好 Java 语言,首先需要熟悉它的基本语法。本节将针对 Java 的基本语法进行详细讲解。</p>
<p>Java 的基本语法格式</p>
<p>编写 Java 程序代码必须先声明一个类然后在类中编写实现需求的业务代码。类需变使用 class 关键字定鸟,在 class 前面可以有一些修饰符,其语法格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写 Java 程序代码时,需要特别注意几个关键点,具体如下。</p>
<p>(1) Java 中的程序可分为结构定义语句和功能执行语句。其中,结构定义语句用于声明一个类或方法,功能执行语句用于实现具体的功能。每条功能执行语句的结尾都必须用</p>
<p>英文分号(;)结束。如下面的语句:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;这是第一个Java程序&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>值得注意的是,在程序中不要将英文的分号(;)误写成中文的分号(;)。如果写成中文的分号,编译器会报告“Invalid Character(无效字符)”错误信息。</p>
<p>(2) Java 语言是严格区分大小写的。例如,在程序中定义一个 computer 的同时,还有以定义一个 Computer,computer 和 Computer 是两个完全不同的符号,在使用时务必注意</p>
<p>(3)在编写 Java 代码时,为了便于阅读,通常会使用一种良好的格式进行排版,但这并不是必需的,也可以在两个单词或符号之间任意地换行,例如下面这段代码的编排方式也是可以的。</p>
<p>虽然 Javn 没有严格要求用什么样的格式来编排程序代码,但是,出于程序可读性和美观性的考虑,应该让自己编写的程序代码整齐美观、层次清晰,通常会使用下面这种形式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;这是第一个 Java 程序!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)Java 程序中一个连续的字符串不能分开在两行中书写,例如,下面这条语句在编译时将会出错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;这是第一个</span></span><br><span class="line"><span class="string">                    Java 程序！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果为了便于阅读,想将一个太长的字符串分开在两行中书写,可以先将这个字符串分成两个字符串,然后用加号(十)将这两个字符串连起来,在加号(十)处断行,上面的语句可以修改成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out,println(<span class="string">&quot;这是第一个&quot;</span>+<span class="string">&quot;Java 程序!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>小提示：Java 代码基本格式中涉及的类、修饰符、编译器等专业性的词汇,读者可以先不必深究其具体含义,在本节只需要重点掌握 Java 代码的基本格式即可，在后续学习 Java 的过程中,会对这些专业词汇进行详细讲解。</p>
<h3 id="Java中的注释"><a href="#Java中的注释" class="headerlink" title="Java中的注释"></a>Java中的注释</h3><p>Java中的注释</p>
<p>在编写程序时,为了使代码易于阅读,通常会在实现功能的同时为代码添加一些注释。注释是对程序的某个功能或者某行代码的解释说明,它能够让开发者在后期阅读和使用代码时能更容易理解代码的作用。</p>
<p>注释只在Java 源文件中有效,在编译程序时编译器会忽略这些注释信息,不会将其编译到 class 字节码文件中。</p>
<p>Java 中的注释有三种类型,具体如下。</p>
<p>1.单行注释</p>
<p>单行注释通常用于对程序中的某一行代码进行注释，用符号”//“表示，”//“后面为注释说明的内容，具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c=<span class="number">10</span>;   <span class="comment">//定义一个整型变量c</span></span><br></pre></td></tr></table></figure>

<p>2.多行注释</p>
<p>多行注释顾名思义就是可以同时注释多行内容，它以符号”/<em>“开头，并以符号”</em>/“结尾，具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义一个整型变量x</span></span><br><span class="line"><span class="comment">将5赋值给变量x*/</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>3.文档注释</p>
<p>文档注释通常是对程序中某个类或类中的方法进行的系统性的解释说明,开发人员可以使用 JDK 提供的 javadoc 工具将文档注释提取出来生成一份 API 帮助文档。文档注释以符号“/*<em>”开头,并以符号“</em>/”结尾,具体示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Title:HelloNorid类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> srx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这是一个 main ()方法人口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args 参数名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out .printitln(<span class="string">&quot;这是第一个 Java程序!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留心：</p>
<p>在java中，有的注释可以嵌套使用，有的则不可以，下面列举两种具体的情况。</p>
<p>（1）多行注释”/<em>….</em>/“中可以嵌套使用单行注释”//“，具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*int c=10;    //定义一个整型的c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  int x=5;*/</span></span><br></pre></td></tr></table></figure>

<p>(2)多行注释”/<em>…..</em>/“中不能嵌套多行注释”/<em>…</em>/“,具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    /*int c=10;*/</span></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>4.如果编写java源代码的过程中添加了文档注释吗，然后通过JDK提供的javac工具可以直接将源代码里的文档注释提取程一份系统的API文档。</p>
<p>javadoc 工具软件识别以下标签：</p>
<table>
<thead>
<tr>
<th align="left"><strong>标签</strong></th>
<th align="left"><strong>描述</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">@author</td>
<td align="left">标识一个类的作者</td>
<td align="left">@author description</td>
</tr>
<tr>
<td align="left">@deprecated</td>
<td align="left">指名一个过期的类或成员</td>
<td align="left">@deprecated description</td>
</tr>
<tr>
<td align="left">{@docRoot}</td>
<td align="left">指明当前文档根目录的路径</td>
<td align="left">Directory Path</td>
</tr>
<tr>
<td align="left">@exception</td>
<td align="left">标志一个类抛出的异常</td>
<td align="left">@exception exception-name explanation</td>
</tr>
<tr>
<td align="left">{@inheritDoc}</td>
<td align="left">从直接父类继承的注释</td>
<td align="left">Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td align="left">{@link}</td>
<td align="left">插入一个到另一个主题的链接</td>
<td align="left">{@link name text}</td>
</tr>
<tr>
<td align="left">{@linkplain}</td>
<td align="left">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td align="left">Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td align="left">@param</td>
<td align="left">说明一个方法的参数</td>
<td align="left">@param parameter-name explanation</td>
</tr>
<tr>
<td align="left">@return</td>
<td align="left">说明返回值类型</td>
<td align="left">@return explanation</td>
</tr>
<tr>
<td align="left">@see</td>
<td align="left">指定一个到另一个主题的链接</td>
<td align="left">@see anchor</td>
</tr>
<tr>
<td align="left">@serial</td>
<td align="left">说明一个序列化属性</td>
<td align="left">@serial description</td>
</tr>
<tr>
<td align="left">@serialData</td>
<td align="left">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td align="left">@serialData description</td>
</tr>
<tr>
<td align="left">@serialField</td>
<td align="left">说明一个ObjectStreamField组件</td>
<td align="left">@serialField name type description</td>
</tr>
<tr>
<td align="left">@since</td>
<td align="left">标记当引入一个特定的变化时</td>
<td align="left">@since release</td>
</tr>
<tr>
<td align="left">@throws</td>
<td align="left">和 @exception标签一样.</td>
<td align="left">The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td align="left">{@value}</td>
<td align="left">显示常量的值，该常量必须是static属性。</td>
<td align="left">Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td align="left">@version</td>
<td align="left">指定类的版本</td>
<td align="left">@version info</td>
</tr>
</tbody></table>
<p>javadoc 输出什么?</p>
<p>javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件。</p>
<p>每一个类的信息将在独自的HTML文件里。javadoc 也可以输出继承的树形结构和索引。</p>
<p>由于 javadoc 的实现不同，工作也可能不同，你需要检查你的 Java 开发系统的版本等细节，选择合适的 Javadoc 版本。</p>
<h3 id="java中的关键字"><a href="#java中的关键字" class="headerlink" title="java中的关键字"></a>java中的关键字</h3><p>2.1.3 Java 中的关键字</p>
<p>关键字(keyword)是编程语言里事先定义好并赋予了特殊含义的单词,也称作保留字。和其他语言一样,Java 中保留了许多关键字.例如 class.public等。JDK 8 中有 50 个关键字,这些关键字都是小写的，具体如表：</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>assert</th>
<th>boolean</th>
<th>break</th>
<th>byte</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>catch</td>
<td>char</td>
<td>class</td>
<td>const</td>
</tr>
<tr>
<td>continue</td>
<td>default</td>
<td>do</td>
<td>double</td>
<td>else</td>
</tr>
<tr>
<td>enum</td>
<td>extends</td>
<td>final</td>
<td>finally</td>
<td>float</td>
</tr>
<tr>
<td>for</td>
<td>goto</td>
<td>if</td>
<td>implements</td>
<td>import</td>
</tr>
<tr>
<td>instanceof</td>
<td>int</td>
<td>interface</td>
<td>long</td>
<td>native</td>
</tr>
<tr>
<td>new</td>
<td>package</td>
<td>private</td>
<td>protected</td>
<td>public</td>
</tr>
<tr>
<td>return</td>
<td>strictfp</td>
<td>short</td>
<td>static</td>
<td>super</td>
</tr>
<tr>
<td>switch</td>
<td>synchronized</td>
<td>this</td>
<td>throw</td>
<td>throws</td>
</tr>
<tr>
<td>transient</td>
<td>try</td>
<td>void</td>
<td>volatile</td>
<td>while</td>
</tr>
</tbody></table>
<p>上面列举的关键字中.每个关键字都有特殊的作用,例如 package美键字用于包的声明，import 关键字用于引人包，class 关键字用于类的声明。</p>
<h3 id="关键字总结"><a href="#关键字总结" class="headerlink" title="关键字总结"></a>关键字总结</h3><h4 id="1-abstract"><a href="#1-abstract" class="headerlink" title="1.abstract"></a>1.abstract</h4><ul>
<li>修饰类：</li>
</ul>
<p>abstract修饰类，这个类就是抽象类，抽象类中可以有非抽象变量和成员变量，也可以有普通方法、构造方法。但是不能实例化，只能被子类继承。<br>如果子类不是抽象类，则必须重写父类的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰方法:</li>
</ul>
<p>abstract修饰方法，这个方法就是抽象方法。抽象方法必须存在于抽象类中。抽象方法不能有具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-assert"><a href="#2-assert" class="headerlink" title="2.assert"></a>2.assert</h4><p>assert表示“断言”，有两种使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> 表达式;</span><br></pre></td></tr></table></figure>

<p>若表达式为真，程序继续执行；若表达式为假，则抛出一个AssertionError异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> 表达式:错误信息;</span><br></pre></td></tr></table></figure>

<p>与第一种方法相同，只是异常中带有错误信息。<br>使用assert时不能在表达式中完成任何程序实际所需的行为（只能做判断）。因为正常发布的代码都是断言无效的，即正常发布的代码中断言语句都不不执行的。</p>
<h4 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h4><p>boolean是Java的基本类型之一（默认值false）。只有两个值：true和false。区别C的判断句，Java不能直接使用1和0来表示真假，且boolean类型也不能强转到其他基本类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-break"><a href="#4-break" class="headerlink" title="4.break"></a>4.break</h4><ol>
<li>break在switch中用于跳出switch块，停止switch向下穿透的现象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> value:expression;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>break在循环中用于跳出循环。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>break也可以在后面接标签，用来跳出一些嵌套比较复杂的循环中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag:</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">break</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-byte"><a href="#5-byte" class="headerlink" title="5.byte"></a>5.byte</h4><p>byte是Java的基本类型之一（默认值0）。表示8位有符号整数。</p>
<p>范围：-128~127</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-case"><a href="#6-case" class="headerlink" title="6.case"></a>6.case</h4><p>case用于switch中，用于判断和执行语句。用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量值:语句;</span><br></pre></td></tr></table></figure>

<p>若变量值和switch(变量值)<br>中的变量值相等，就执行后面的语句。执行完后继续执行下一个case语句。</p>
<h4 id="7-catch"><a href="#7-catch" class="headerlink" title="7.catch"></a>7.catch</h4><p>catch用于捕获异常。<br>用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(异常类型 异常)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在try/catch语句块中，catch捕获发生的异常，并应对错误做一些处理。<br>当catch捕获到异常后，try中执行的语句终止，并跳到catch后的语句中。</p>
<h4 id="8-char"><a href="#8-char" class="headerlink" title="8.char"></a>8.char</h4><p>char是Java的基本类型之一（默认值\u000）。表示16位、在Unicode编码表中的字符。使用单引号来表示字符常量，例如’A’。</p>
<p>范围：0-65535</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="9-class"><a href="#9-class" class="headerlink" title="9.class"></a>9.class</h4><p>class表示类。用于声明一个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问控制] (<span class="keyword">abstract</span>) <span class="class"><span class="keyword">class</span> 类名 (<span class="keyword">implements</span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-const"><a href="#10-const" class="headerlink" title="10.const"></a>10.const</h4><p>const是Java的一个保留关键字，没有实际意义，但是不能用于做变量名（因为被保留作为关键字了）。在C语言中表示常量，类似Java的final。</p>
<h4 id="11-continue"><a href="#11-continue" class="headerlink" title="11.continue"></a>11.continue</h4><ol>
<li>continue用于在循环中跳过本次循环。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>continue也可以在后面接标签，在一些嵌套比较复杂的循环中跳过一次循环。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag:</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">continue</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-default"><a href="#12-default" class="headerlink" title="12.default"></a>12.default</h4><p>default关键字：</p>
<ol>
<li>用于switch做默认分支：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>:语句；</span><br></pre></td></tr></table></figure>

<ol>
<li>用于接口,让接口实现具体的方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        具体方法;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default用于接口时，必须要有具体实现。<br>(API&gt;=24)</p>
<h4 id="13-do"><a href="#13-do" class="headerlink" title="13. do"></a>13. do</h4><p>do用于和while组成循环，do/while循环不同于while循环，属于先执行循环体再判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(...)</span><br></pre></td></tr></table></figure>

<h4 id="14-double"><a href="#14-double" class="headerlink" title="14.double"></a>14.double</h4><p>double是Java的基本类型之一（默认值0.0d），表示双精度、64位的浮点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">0.1d</span>;</span><br></pre></td></tr></table></figure>

<h4 id="15-else"><a href="#15-else" class="headerlink" title="15.else"></a>15.else</h4><p>else用于分支结构中的判断。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断<span class="number">2</span>)&#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-enum"><a href="#16-enum" class="headerlink" title="16.enum"></a>16.enum</h4><p>enum表示枚举，用于限制变量值的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title">Alpha</span> <span class="params">(implements 接口)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>)a,b,c,d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规定Color的实例只能为a,b,c,d其中之一。</p>
<p><strong>枚举类中可以有成员变量和方法。</strong></p>
<h4 id="17-extends"><a href="#17-extends" class="headerlink" title="17.extends"></a>17.extends</h4><p>extends表示继承。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span>父类</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Java中的继承是单继承，即子类只能有一个直接父类。<br>除了private，子类可以访问父类的方法和成员变量。</p>
<h4 id="18-final"><a href="#18-final" class="headerlink" title="18.final"></a>18.final</h4><ol>
<li>修饰变量：<br>将变量变为常量，在初始化变量后不能再改变值。</li>
<li>修饰方法：<br>被final修饰的方法不能被子类重写。</li>
<li>修饰类：<br>被final修饰的类不能被继承。</li>
</ol>
<h4 id="19-finally"><a href="#19-finally" class="headerlink" title="19.finally"></a>19.finally</h4><p>finally在try/catch语句块中处理一些后续的工作。例如关闭网络连接和输入输出流等。</p>
<ul>
<li>如果在try/catch中使用return，则finally会撤销这个return，无论如何都会执行finally中的语句。</li>
</ul>
<h4 id="20-float"><a href="#20-float" class="headerlink" title="20.float"></a>20.float</h4><p>float是Java的基本类型之一（默认值0.0f）。表示单精度、32位的浮点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">0.1f</span>;</span><br></pre></td></tr></table></figure>

<h4 id="21-for"><a href="#21-for" class="headerlink" title="21.for"></a>21.for</h4><p>for用于循环:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化循环变量; 判断执行条件;更新循环变量)&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(变量:数组)&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-goto"><a href="#22-goto" class="headerlink" title="22.goto"></a>22.goto</h4><p>Java中的保留关键字，没有实际意义，但是不能用做变量名。在C中表示无条件跳转语句。</p>
<h4 id="23-if"><a href="#23-if" class="headerlink" title="23.if"></a>23.if</h4><p>if用于分支结构中的判断。常与else和else if使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;语句&#125;</span><br></pre></td></tr></table></figure>

<p>若表达式为真，则执行后面的语句。</p>
<h4 id="24-implements"><a href="#24-implements" class="headerlink" title="24.implements"></a>24.implements</h4><p>implements用于接入接口。接上接口的类必须实现接口的抽象方法（可以不实现默认方法和静态方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">do</span>()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-import"><a href="#25-import" class="headerlink" title="25.import"></a>25.import</h4><p>用于导入包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br></pre></td></tr></table></figure>

<h4 id="26-instanceof"><a href="#26-instanceof" class="headerlink" title="26.instanceof"></a>26.instanceof</h4><p>instanceof用于判断类与对象的关系。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> b</span><br></pre></td></tr></table></figure>

<p>若a是b的一个实例(或子类对象)，则整个表达式的结果是true，否则结果为false。</p>
<h4 id="27-int"><a href="#27-int" class="headerlink" title="27.int"></a>27.int</h4><p>int是Java的基本类型之一（默认值为0）。表示32位、有符号的整数。</p>
<p>范围：[-231,231-1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="28-interface"><a href="#28-interface" class="headerlink" title="28.interface"></a>28.interface</h4><p>interface用于声明一个接口，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明a为一个接口，若接上该接口，则必须实现其中的抽象方法b。<br>接口中的成员变量是static、final、public的。接口中的方法为静态方法或默认方法和静态方法(API&gt;=24)。</p>
<h4 id="29-long"><a href="#29-long" class="headerlink" title="29.long"></a>29.long</h4><p>long是Java的基本类型之一（默认值为0L），表示64位、有符号的整数。</p>
<p>范围：[-263,263)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">3216846849646L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="30-native"><a href="#30-native" class="headerlink" title="30.native"></a>30.native</h4><p>native可以让Java运行非Java实现的方法。例如c语言，要编译后用javah产生一个.h文件。导入该.h文件并且实现native方法，编译成动态链接库文件。在Java加载动态链接库文件，这个native方法就可以在Java中使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">aVoid</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="31-new"><a href="#31-new" class="headerlink" title="31.new"></a>31.new</h4><p>new用于生成类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object a = <span class="keyword">new</span> Object()；</span><br></pre></td></tr></table></figure>

<h4 id="32-package"><a href="#32-package" class="headerlink" title="32.package"></a>32.package</h4><p>package用于规定当前文件的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.zhangyijun.testdefactivity;</span><br></pre></td></tr></table></figure>

<h4 id="33-private"><a href="#33-private" class="headerlink" title="33.private"></a>33.private</h4><p>访问控制的一种。<br>私有的方法和变量只能在本类中访问。类和接口不能为私有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-protected"><a href="#34-protected" class="headerlink" title="34.protected"></a>34.protected</h4><p>访问控制的一种。<br>受保护的方法和变量只能给子类和基类访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-public"><a href="#35-public" class="headerlink" title="35.public"></a>35.public</h4><p>访问控制的一种。<br>公有的方法、类、变量、接口能够被任何其他类访问。</p>
<h4 id="36-return"><a href="#36-return" class="headerlink" title="36.return"></a>36.return</h4><p>方法中返回数据，并结束方法。</p>
<h4 id="37-strictfp"><a href="#37-strictfp" class="headerlink" title="37.strictfp"></a>37.strictfp</h4><p>使用strictfp关键字来声明一个类、接口或者方法时，那么该类、接口或者方法会遵循IEEE-754标准来执行，提高浮点运算的精度，并且减少不同硬件平台之间由于浮点运算带来的差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">strictfp</span> <span class="keyword">double</span> <span class="title">aDouble</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="38-short"><a href="#38-short" class="headerlink" title="38.short"></a>38.short</h4><p>short是Java的基本类型之一（默认值0）,表示16位、有符号的整数。</p>
<p>范围：[-215,215)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="39-static"><a href="#39-static" class="headerlink" title="39.static"></a>39.static</h4><p>static修饰的语句块存放在堆的方法区中。</p>
<ol>
<li>静态变量：依附在类中的变量，可以被类的所有的实例共用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态方法：依附在类中的方法。静态方法只能访问类中的静态变量和静态方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">publlic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态块：在类加载的时候执行块中的语句，块中不能访问非静态变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态内部类：用static修饰内部类。</li>
</ol>
<h4 id="40-super"><a href="#40-super" class="headerlink" title="40.super"></a>40.super</h4><p>super即超类</p>
<ol>
<li>引用父类的的成员：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.xxx</span><br></pre></td></tr></table></figure>

<ol>
<li>变量或方法重名时用super调用父类的成员或方法。</li>
<li>调用父类的构造方法:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>(xxx);</span><br></pre></td></tr></table></figure>

<h4 id="41-switch"><a href="#41-switch" class="headerlink" title="41.switch"></a>41.switch</h4><p>switch用于分支结构，判断某个变量与一系列值是否相等。switch 语句中的变量类型可以是： byte、short、int 、char、String、enum。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line">	<span class="keyword">case</span> value1:语句<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> value2:语句<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>若变量和case后的值相等则执行语句。</li>
<li>当语句执行到break时跳到switch块后，如果没有break会产生穿透现象。</li>
<li>default分支必须为最后一个分支，在没有值和case变量相等时执行该语句。</li>
</ol>
<h4 id="42-synchronized"><a href="#42-synchronized" class="headerlink" title="42.synchronized"></a>42.synchronized</h4><p>synchronized关键字用于保证线程安全。由这个关键字修饰的方法或者代码块保证了同一时刻只有一个线程执行该代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程访问同步代码块时，检查obj是否有锁，如果有就挂起。如果没有就获得这个obj的锁，也就是把其他线程锁在了外面。当代码执行完毕时释放该锁，其他线程获得锁继续执行代码。</p>
<h4 id="43-this"><a href="#43-this" class="headerlink" title="43.this"></a>43.this</h4><ol>
<li>指向当前对象：<a href="http://this.xxx/">this.xxx</a></li>
<li>形参和成员名字重名时时用this区分。</li>
<li>引用构造函数。</li>
</ol>
<h4 id="44-throw"><a href="#44-throw" class="headerlink" title="44.throw"></a>44.throw</h4><p>用于抛出一个异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> (Exception);</span><br></pre></td></tr></table></figure>

<h4 id="45-throws"><a href="#45-throws" class="headerlink" title="45.throws"></a>45.throws</h4><p>在方法中将发生的异常抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[控制访问](返回类型)(方法名)([参数列表])[<span class="keyword">throws</span>(异常类)]&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="46-transient"><a href="#46-transient" class="headerlink" title="46.transient"></a>46.transient</h4><p>类接上序列化接口后，可以通过transient关键字将某些变量变得无法序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="47-try"><a href="#47-try" class="headerlink" title="47.try"></a>47.try</h4><p>在try/catch中，将可能出现异常的语句放在try{}块中，出现异常之后代码将会终止并跳到catch中继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="48-void"><a href="#48-void" class="headerlink" title="48.void"></a>48.void</h4><p>修饰方法，表示方法没有返回值。</p>
<h4 id="49-volatile"><a href="#49-volatile" class="headerlink" title="49.volatile"></a>49.volatile</h4><p>volatile关键字修饰的变量在多线程中保持同步。相比synchronized效率要高，不会阻塞线程。但只能保证数据的可见性，不能保证数据的原子性。例如在处理i++的时候另外一个线程修改i的值，那么i的值将会发生错误，这是原子性导致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<h4 id="50-while"><a href="#50-while" class="headerlink" title="50.while"></a>50.while</h4><p>while用于两种循环结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(判读语句)&#123;</span><br><span class="line">    循环体...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体...</span><br><span class="line">&#125;<span class="keyword">while</span>(判读语句)</span><br></pre></td></tr></table></figure>

<h3 id="java中的标识符"><a href="#java中的标识符" class="headerlink" title="java中的标识符"></a>java中的标识符</h3><p>在编程过程中，经常需要在程序中定义一些符号来标记一些名称，如包名、类名、方法名、参数名、变量名等，这些符号被称为标识符。标识符可以由任意顺序的大小写字母、数字、下画线(_)和美元符号($ )组成，但标识符不能以数字开头，也不能是Java 中的关键字。</p>
<p>下面的这些标识符都是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username</span><br><span class="line"></span><br><span class="line">username123</span><br><span class="line"></span><br><span class="line">user_name</span><br><span class="line"></span><br><span class="line">_username</span><br><span class="line"></span><br><span class="line">$username</span><br></pre></td></tr></table></figure>

<p>下面的这些标识符是不合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>username       <span class="comment">//不能以数字开头</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>             //不能是关键字</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Hello</span> <span class="title">World</span>       //不能包含空格特殊字符</span></span><br></pre></td></tr></table></figure>

<p>在Java程序中,定义的标识符必须严格遵守上面列出的规范,否则程序在编译时会报错。</p>
<p>为了增强代码的可读性和美观性。除了要求初学者要严格按照上面列出的规范来定义标识符外,还建议初学者在定义标识符时要遵循以下几点规范。</p>
<p>1.包名所有字母一律小写,例如 com.itheima. example01。</p>
<p>2.类名和接口名每个单词的首字母都要大写,例如 ArrayList、Iterator。</p>
<p>3.常量名所有字母都大写,单词之间用下画线连接,例如 DAY_OF_MONTH。</p>
<p>4.变量名和方法名的第一个单词首字母小写,从第二个单词开始每个单词首字母大写,例如 lineNumber、getLineNumber。</p>
<p>5.在程序中,应该尽量使用有意义的英文单词来定义标识符,使得程序便于阅读,例如,使用 userName 表示用户名.password 表示密码。</p>
<h2 id="Java中的变量和常量"><a href="#Java中的变量和常量" class="headerlink" title="Java中的变量和常量"></a>Java中的变量和常量</h2><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><p>在Java语言中，主要是利用final关键字（在Java类中灵活使用Static关键字）来定义常量。</p>
<p>一是常量在定义的时候，就需要对常量进行初始化。</p>
<p>二是final关键字使用的范围。这个final关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</p>
<p>三是需要注意常量的命名规则。如在给常量取名的时候，一般都用大写字符。在Java语言中，大小写字符是敏感的。之所以采用大写字符，主要是跟变量进行区分。虽然说给常量取名时采用小写字符，也不会有语法上的错误。但是，为了在编写代码时能够一目了然的判断变量与常量，最好还是能够将常量设置为大写字符。另外，在常量中，往往通过下划线来分隔不同的字符。而不想对象名或者类名那样，通过首字符大写的方式来进行分隔。</p>
<blockquote>
<p>当利用static这个关键字来修饰一个变量的时候，在创建对象之前就会为这个变量在内存中创建一个存储空间。以后创建对对象如果需要用到这个静态变量，那么就会共享这一个变量的存储空间。也就是说，在创建对象的时候，如果用到这个变量，那么系统不会为其再分配一个存储空间，而只是将这个内存存储空间的地址赋值给他。如此做的好处就是可以让多个对象采用相同的初始变量。当需要改变多个对象中变量值的时候，只需要改变一次即可。</p>
</blockquote>
<p>常量：在程序运行期间，固定不变的量。</p>
<p>常量的分类：<br>1.字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：“abc”、“Hello”、“123”。<br>2.整数常量：直接写上数字，没有小数点。例如：100，200,0，-250。<br>3.浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.0。<br>4.字符常量：凡是用单引号引起来的单个字符，就是字符常量。例如：‘A’、‘b’、‘9’、‘中’。<br>5.布尔常量：只有两种取值。true、false。<br>6.空常量：null。代表没有任何数据。</p>
<p>注意：<br>1.两个单引号中间必须有且仅有一个字符，没有不行。<br>2.两个单引号中间必须有且仅有一个字符，有两个不行。<br>3.空常量不能直接用来打印输出。</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>Java数据类型图：</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/java_data_type.png" alt="数据类型"></p>
<h4 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h4><p>　　基本数据类型，也称内置类型，是可以在栈直接分配内存的，Java保留基本数据类型最大的原因也在此：性能。关于这一点可以参考：<a href="http://www.importnew.com/11915.html">Java为什么需要保留基本数据类型</a>。<br>　　另外，要注意，Java是基于JVM的，所以，其所占字节固定，与机器平台无关，所有地方统一占用内存大小（除了boolean，以及byte/short/boolean数组的时候每个单元所占的内存是由各个JVM自己实现的）。<br>　　总共有四类八种基本数据类型（注1）：<br>1).整型：全部是有符号类型。<br>1.<strong>byte</strong>：1字节（8bit），高位为符号位，其余7位为数据位，范围：-2^7 ~ 2^7-1（1111,1111 ~ 0111,1111），即-128 ~ 127（下面的计算方式相同）；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：byte类型虽然在语义（逻辑）上是占用1字节，但实际上，JVM中是将其当做int看</span><br><span class="line">的，也就是事实上是占用了32位，4字节的，所以其运算效率和int没区别，short也一样。</span><br><span class="line">之所以要有byte&#x2F;short类型，一是因为某些地方要明确使用这些范围类型，二是，</span><br><span class="line">在byte[]数组中，JVM存储的则是真的1字节，short[]2字节。（但也有的JVM其byte[]</span><br><span class="line">数组也是4字节1位）</span><br></pre></td></tr></table></figure>

<p>2.<strong>short</strong>：2字节（16bit），高位为符号位，其余15位为数据位，范围：-2^15 ~ 2^15-1，即<code>-32768~32767</code>；</p>
<p>3.<strong>int</strong>：4字节（32bit），范围-2^31 ~ 2^31-1；Java默认的整型类型，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long l &#x3D; 0xfffffffffff;&#x2F;&#x2F;0x表示这个数是16进制数，0表示8进制。</span><br><span class="line">&#x2F;&#x2F;编译器报错，因为右边默认是int，但其超出了范围（没超出int范围的话</span><br><span class="line">&#x2F;&#x2F;编译器会隐式将int转为long），故报错（同样的错误也会出现在float）。</span><br></pre></td></tr></table></figure>

<p>同样的还有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short s &#x3D; 123;&#x2F;&#x2F;（这个123也是int类型，这里，&#x3D; 操作编译器能隐式转换） </span><br><span class="line">s &#x3D; s + 123;&#x2F;&#x2F;编译器报错，那是因为s+1是int类型（编译器先将s转化为int，再+1），</span><br><span class="line">&#x2F;&#x2F;这里，+ 操作编译器不能隐式转换（会提示失真，即精度可能会受损），正确的做法：</span><br><span class="line">s &#x3D; (short)(s + 123)&#x2F;&#x2F;注意，不是(short)s + 123。</span><br></pre></td></tr></table></figure>

<p>类型转化详见：<a href="http://blog.csdn.net/a327369238/article/details/52367968">Java 数据类型转化</a>。<br>4.<strong>long</strong>：8字节（64bit），范围：-2^63 ~ 2^63-1；声明大的long方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long l &#x3D; 0xfffffffffffL;&#x2F;&#x2F;即在后面加上L或l。</span><br><span class="line">&#x2F;&#x2F;（强制转化：long l &#x3D; (long)0xfffffffffff也没用）</span><br></pre></td></tr></table></figure>

<p>2).浮点型<br>5.<strong>float</strong>：4字节（32bit），单精度，数据范围：(-2^128) ~ (-2^(-23-126))-(0)-(2^-149) ~ 2^128。浮点数，通俗来说就是小数，但是，这是有精度要求的，即在这区间float可不是能表达任意小数的，而是在一定精度下，比如float有效位7 ~ 8位（包括整数位和小数位，有效小数位是6 ~ 7位，这里为什么是7 ~ 8（6 ~ 7），参考：<a href="http://blog.csdn.net/a327369238/article/details/52354811">Java中float/double取值范围与精度</a>），即0.123456789后面的9JVM是不认识的（8能认识，整数位为0则不算是有效位，例如12.1234567后面的7也不认识，只有6位有效小数位（注意，看的是有效位，不是有效小数位，float有7~8位有效位）），即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(0.123456781f &#x3D;&#x3D; 0.123456789f)&#123;&#x2F;&#x2F;注意后面加f&#x2F;F，否则就是double</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印结果：true</span><br><span class="line">&#x2F;&#x2F;事实上，浮点数值的比较是不能直接用&#x3D;&#x3D;判断的，这里原因就要追究到浮点数的内存结构</span><br><span class="line">&#x2F;&#x2F;浮点数比较可以用一个差值，但这种情况只是近似的比较</span><br><span class="line">&#x2F;&#x2F;如果想要精确，可以使用BigDecimal</span><br><span class="line">System.out.println(Float.MIN_VALUE);&#x2F;&#x2F;1.4E-45 &#x3D; 2^-149</span><br><span class="line">&#x2F;&#x2F;这里的“最小值”意味float能表示的最小小数，实际上float最小值等于最大值取负</span><br><span class="line">System.out.println(Float.MAX_VALUE);&#x2F;&#x2F;3.4028235E38 &#x3D; 2^128</span><br></pre></td></tr></table></figure>

<p>6.<strong>double</strong>：8字节（64bit），双精度，范围：-2^1024 ~ (-2^(-1022-52))-0-(2^－1074) ~ 2^1024，Java默认的浮点类型，即若后面不加f/F，默认是double类型，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float f &#x3D; 1.23;&#x2F;&#x2F;编译报错，因为</span><br><span class="line">float f &#x3D; 1.23f;&#x2F;&#x2F;或float f &#x3D; 1.23F;</span><br><span class="line">&#x2F;&#x2F;默认是double，1.23(double)转成float，做隐式转换，但是double转成float是</span><br><span class="line">&#x2F;&#x2F;取值范围大的转成取值范围小的会损失精度，因此不能转换（详见Java数据类型转换）</span><br><span class="line">&#x2F;&#x2F;那为什么，int可以转换成byte、short，int范围更大不是？</span><br><span class="line">&#x2F;&#x2F;前面已经说过了，byte、short实际在JVM上就是int，因此编译器是不会认为会损失精度的</span><br><span class="line">&#x2F;&#x2F;但是int是不能转换成boolean，虽然boolean也是4字节（一般JVM），但在JVM认为这</span><br><span class="line">&#x2F;&#x2F;两者完全是两个东西，当然不能转换（强制也不行，你不能把猫强制转换成鸟，完全两个物种），而byte、short都是整型，同int是一个类型</span><br></pre></td></tr></table></figure>

<p>3).字符型<br>7.<strong>char</strong>：2字节（16bit），表示一个字符（可以是汉字），字符编码采用Unicode（说的更准确点，字符集（charset）采用UCS-2，编码（encoding）采用UTF-16），实际上就是一个16位的无符号整型，但是，要注意的是，因为随着发展，char所能代表的字符个数（UCS-2字符集）被限定死了，所以并不推荐使用。（更多内容，以及关于Unicode、UTF8/16参考：Unicode、UTF8以及Java char。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c &#x3D; 3+5;&#x2F;&#x2F;正确，char是无符号整型，但不能这样</span><br><span class="line">int a1 &#x3D; 3;int a2 &#x3D; 5;char c0 &#x3D; a1+a2;&#x2F;&#x2F;这里需要强制转换才行</span><br><span class="line">char c1 &#x3D; -3;&#x2F;&#x2F;编译错误，char不能表示负数，即使</span><br><span class="line">char c2 &#x3D; (char)-3;&#x2F;&#x2F;编译正确，但无意义（乱码）</span><br><span class="line">char c3 &#x3D; &#39;3&#39;;&#x2F;&#x2F;正确，输出字符3</span><br><span class="line">char c4 &#x3D; &quot;3&quot;;&#x2F;&#x2F;编译错误，双引号，表示的是字符串</span><br><span class="line">char c5 &#x3D; &#39;65&#39;;&#x2F;&#x2F;编译错误，这里65是两个字符</span><br></pre></td></tr></table></figure>

<p>4).布尔型<br>8.<strong>boolean</strong>：逻辑上：1bit，但是实际上，boolean并没有具体规定，完全是看各个JVM实现，不过《Java虚拟机规范》给出了4个字节（同byte解释）和boolean数组一个字节的定义。</p>
<p>注1：<br>(1).这种分法是一种比较流行的分法，事实上应该为两种：数值类型与布尔型。数值类型分为整型和浮点型。整型包括：byte、short、int、long、char；浮点型：float、double；布尔型boolean。之所以将char认为是整型是因为char在JVM就是以无符号整型存在的。<br>(2).事实上Java中除去这8种以及对象类型，还有一种比较特殊的类型存在，那就是Void。java.lang.Void，是一个占位符类，不可实例化，保存着Java关键字void的Class对象。为什么说它特殊呢？明明是一个类，难道不是对象类型？那是因为void.class.isPrimitive()（这个方法是用来判断一个Class对象是否是基本类型的）返回的是true，所以Void也算是基本类型的一个了（错了），只不过它比较特殊，不能算是一种数据，只是一种象征。<br>20160921 改：上面弄错了，把Void和void两个混为一体了，事实上，可以简单的把这两者的关系看成类似包装类和基本类型的关系，像Integer和int的关系，java.lang.Void是一个不可实例化的占位符类来保存一个引用代表了Java关键字void的Class对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final Class&lt;Void&gt; TYPE &#x3D; Class.getPrimitiveClass(&quot;void&quot;);</span><br></pre></td></tr></table></figure>

<p>而Integer也有类似的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final Class&lt;Integer&gt;  TYPE &#x3D; (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);</span><br></pre></td></tr></table></figure>

<p>区别只是，Void仅仅是为void服务，即所谓的占位符类，不做他用。所以Void类只是一个普通类，而void则可以认作为如同int一样的基本类型。</p>
<h4 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h4><p>简要提一下引用数据类型：字符串、数组、类、接口、Lambda。</p>
<p>也称对象变量类型，复合数据类型，包含类、接口、数组（除了基本类型外，就是引用类型）。引用类型与基本类型最大的区别在于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 5;&#x2F;&#x2F;这里的a是对象（严格来说不算是对象，只是个符号标识），5是数值</span><br><span class="line">Integer a &#x3D; 5;&#x2F;&#x2F;这里的a是一个引用，5才是一个对象，更形象常见的是：</span><br><span class="line">Object o &#x3D; new Object();&#x2F;&#x2F;o是引用（栈中），new Object()是对象（堆中）</span><br><span class="line">&#x2F;&#x2F;第二行代码中，5被自动包装成Integer对象</span><br></pre></td></tr></table></figure>

<p>这里的引用有点像C/C ++中的指针，但是同指针不同的是，你不能通过改变它的值从而去改变它所指向的值。即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassA p &#x3D; new ClassA();&#x2F;&#x2F;C++中，这个时候是可以这样操作的：</span><br><span class="line">p &#x3D; p + 1;&#x2F;&#x2F;向前移动一个单元，Java则不能</span><br><span class="line">&#x2F;&#x2F;这种操作，其实是对内存直接的操作，很显然，Java是不允许程序员做这种操作的</span><br></pre></td></tr></table></figure>

<p>　　其实质就是，Java的引用不支持对内存直接操作，而指针则可以，所以，Java用起来更安全，但不够灵活，而指针，自由度大，但同时，要更加小心因为指针操作不当而引起的各种内存问题。在Java中，任何对象都需要通过引用才能访问到，没有引用指向的对象被视为垃圾对象，将会被回收（GC）。<br>　　引用，其实质同指针一样（可以理解为受限制的指针），存放的是一个地址，至于是实例对象的地址，还是一个指向句柄池的地址（这里可以参考：<a href="http://blog.csdn.net/a327369238/article/details/52094738">(3) Java内存结构</a>），完全是看各个JVM的实现了。<br>　　Java中的枚举类型，都是Enum类的子类，算是类中的一种，也是引用类型。<br>　　引用类型又称为对象变量类型，是相对于基本数据类型来说的（基本数据类型不是对象），而又被称为复合数据类型，可以这样理解，引用类型的数据最终都是由基本数据类型构成的。而像接口，接口是不能实例化的，最终的实现还是由类实现的；数组在JVM中的实现也是通过类实现的，每个类型的一维数组，二维数组……都是一个类，只是这是一个特殊的类，它的对象头有别于一般对象的对象头（最主要的就是，数组对象头有对象长度）。<br>　　另外，关于Java引用可以参考：<a href="http://blog.csdn.net/a327369238/article/details/52384649">Java中的引用</a>。</p>
<p>取值范围与内存占用不相关，就比如说图中的long占用8个字节而单精度浮点数float只占用四个字节，但是float的取值范围却比long的取值范围大很多，这是因为float采用的是科学计数法计算省空间。</p>
<p>注意事项：<br>1.字符串不是基本类型，而是引用类型。<br>2.浮点型可能只是一个近似值，并非精确值。<br>3.数据范围与字节数不一定相关。例如：float数据范围比long更加广泛，但是float是4字节，long是8字节。<br>4.浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。<br>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。大小写后缀都可以，推荐使用大写字母后缀。</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量：程序运行期间，内容可以发生改变的量。</p>
<p>创建一个变量并且使用的格式：数据类型 变量名称; 变量名称 = 数据值;</p>
<p>一步到位的格式：数据类型 变量名称 = 数据值;//在创建一个变量的同时，立刻放入指定的数据值。</p>
<p>用long 和 float时要加后缀。例如：long num = 30000000000L; float num = 2.5F;</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>当数据类型不一样时，将会发生数据类型转换。</p>
<p>数据类型转换分为两类：</p>
<p> 自动类型转换（隐式）<br>  1.特点：代码不需要进行特殊处理，自动完成。<br>  2.规则：数据范围从小到大。</p>
<p> 强制类型转换（显式）<br>  1.特点：代码需要进行特殊的格式处理，不能自动完成。<br>  2.格式：范围小的数据类型 范围小的变量名 = （范围小的类型）原本范围大的数据; 例如：int num = (int) 100L;</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>规定了变量所能使用的范围，只有在作用域范围内变量才能被使用。根据变量声明地点的不同，变量的作用域也不同。<br>根据作用域的不同，一般将变量分为不同的类型：类变量、局部变量、方法参数变量及异常处理参数变量。</p>
<ul>
<li>类变量<br>类变量也称为成员变量，声明在类中，不属于任何一个方法，作用域是整个类。</li>
<li>局部变量<br>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。</li>
<li>方法参数变量<br>作为方法参数声明的变量的作用域是整个方法。</li>
<li>异常处理参数变量<br>异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Variable</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>企业项目开发流程</title>
    <url>/article/a73689f8.html</url>
    <content><![CDATA[<blockquote>
<p>一般情况下，企业开发软件时会按照基线和定制两块并行方式执行项目开发工作。无论什么公司，都需要遵从一套成熟的产品研发过程体系，才能做出质量较好的产品。因此，如果出现项目较多的情况，应该合理地安排基线和定制之前的里程碑，让基线产品能够尽量多地收集用户的通用型需求，为定制项目进度实现技术支撑，减少定制项目中大量更改代码、需要新增模块情况发生。此外，产品研发过程体系也需要按照业务实际时间要求变化，不要拘泥于一定要按照瀑布方式，或是敏捷方式进行管理，凡事都需要找到契合自己的方式。</p>
</blockquote>
<a id="more"></a>

<h3 id="Web项目流程"><a href="#Web项目流程" class="headerlink" title="Web项目流程"></a>Web项目流程</h3><p>1.需求分析<br>2.设计（概要设计、详细设计)<br>3.技术选型<br>4.初始化/引入需要的技术<br>5.写Demo<br>6.写代码（实现业务逻辑)<br>7.测试(单元测试)<br>8.代码提交&amp;代码评审<br>9.部署<br>10.发布</p>
<p><strong>关于技术选型</strong><br>前端:三件套＋React +组件库Ant Design + Umi + Ant Design Pro(现成的管理系统)</p>
<blockquote>
<p>Umi 自动生成代码工具<br>packages.json 依赖和脚本<br>yarn 包管理器：//npm install -g yarn //yarn –version</p>
</blockquote>
<p>后端: java +spring + springmvc + mybatis + mybatis-plus + springboot + mysql<br>部署:服务器/容器（平台)</p>
<blockquote>
<p>mvnrepository:<a href="https://mvnrepository.com/">https://mvnrepository.com/</a><br><a href="https://search.maven.org/">https://search.maven.org/</a><br>mybatis-plus <a href="https://baomidou.com/">https://baomidou.com/</a><br>springboot官方生成器：<a href="https://start.spring.io/">https://start.spring.io/</a></p>
</blockquote>
<p><strong>关于依赖：</strong><br>Spring Boot DevTools //热更新<br>Lombok 注解<br>Spring Configuration Processor<br>mysql 数据库<br>spring web //接口<br>mybatis //数据库访问<br>junit //单元测试swagger //api文档</p>
<h3 id="App开发流程"><a href="#App开发流程" class="headerlink" title="App开发流程"></a>App开发流程</h3><p>1.产品经理:功能需求，竞品分析，抄同类产品的好功能<br>2.UI设计：寻找灵感，抄同类产品设计<br>3.程序员：代码审查，百度论坛找解决办法<br>4.测试：测试体验，多种手机对比</p>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Lambda 表达式</title>
    <url>/article/8e84b9d0.html</url>
    <content><![CDATA[<blockquote>
<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
</blockquote>
<a id="more"></a>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda 表达式的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression 或 (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<h3 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h3><p>Lambda 表达式的简单例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>

<p>在 Java8Tester.java 文件输入以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Java8Tester tester = <span class="keyword">new</span> Java8Tester();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 类型声明</span></span><br><span class="line">      MathOperation addition = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用类型声明</span></span><br><span class="line">      MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">      MathOperation multiplication = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">      MathOperation division = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a / b;</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用括号</span></span><br><span class="line">      GreetingService greetService1 = message -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 用括号</span></span><br><span class="line">      GreetingService greetService2 = (message) -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      greetService2.sayMessage(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">MathOperation</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, MathOperation mathOperation)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">10 + 5 &#x3D; 15</span><br><span class="line">10 - 5 &#x3D; 5</span><br><span class="line">10 x 5 &#x3D; 50</span><br><span class="line">10 &#x2F; 5 &#x3D; 2</span><br><span class="line">Hello Runoob</span><br><span class="line">Hello Google</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 Lambda 表达式需要注意以下两点：</p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
</ul>
</blockquote>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul>
<li>Lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</li>
</ul>
<blockquote>
<p>我们也可以直接在 Lambda 表达式中访问外层的局部变量，Lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）。</p>
</blockquote>
<ul>
<li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Android文件存储媒体库库MediaStore</title>
    <url>/article/5bfb2f95.html</url>
    <content><![CDATA[<blockquote>
<p>MediaStore是android系统提供的一个多媒体数据库，专门用于存放多媒体信息的，通过ContentResolver即可对数据库进行操作。媒体库提供来自任何附加存储设备的常见媒体类型的索引集合，例如Audio、Video和。Images每个集合都是根据底层内容的主要 MIME 类型组织的；例如，image/*内容在Images. 该Files集合提供了所有集合的广泛视图，并且不按 MIME 类型进行过滤。</p>
</blockquote>
<a id="more"></a>

<h3 id="关于MediaStore"><a href="#关于MediaStore" class="headerlink" title="关于MediaStore"></a>关于MediaStore</h3><p>MediaStore是android系统提供的一个多媒体数据库，专门用于存放多媒体信息的，通过ContentResolver即可对数据库进行操作。</p>
<p>MediaStore.Files: 共享的文件,包括多媒体和非多媒体信息；<br>MediaStore.Audio: 存放音频信息；<br>MediaStore.Image: 存放图片信息；<br>MediaStore.Vedio: 存放视频信息；</p>
<p>每个内部类中都又包含了Media,Thumbnails和相应的MediaColumns，分别提供了媒体信息，缩略信息和操作字段。</p>
<p>MediaStore 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentResolver contentResolver = <span class="keyword">this</span>.getContentResolver();</span><br><span class="line">Uri imgUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">Uri firstImgUri = <span class="keyword">null</span>;</span><br><span class="line">Cursor cursor = contentResolver.query( imgUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span> );</span><br><span class="line"><span class="keyword">if</span>(cursor!=<span class="keyword">null</span>&amp;&amp;cursor.getCount()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    cursor.moveToFirst();</span><br><span class="line">    firstImgUri = Uri.fromFile(<span class="keyword">new</span> File(cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA))));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;img cursor data=&quot;</span> + cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA))</span><br><span class="line">                + <span class="string">&quot;;\nimg cursor type=&quot;</span></span><br><span class="line">                + cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.MIME_TYPE)));</span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">Log.d(TAG,<span class="string">&quot;firstImgUri=&quot;</span>+firstImgUri);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ParcelFileDescriptor parcelFileDescriptor = contentResolver.openFileDescriptor(firstImgUri, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        Bitmap bitmap = contentResolver.loadThumbnail(firstImgUri, <span class="keyword">new</span> Size(<span class="number">200</span>, <span class="number">200</span>), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;exception: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用MediaStore-API"><a href="#常用MediaStore-API" class="headerlink" title="常用MediaStore API"></a>常用MediaStore API</h3><p>1.查询媒体文件：query()</p>
<p>用 MediaStore 提供的 Uri 指定设备，selection 参数指定过滤条件，通过 ContentResolver.query 接口查询文件 Uri。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uri external &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line"></span><br><span class="line">ContentResolver resolver &#x3D; context.getContentResolver();</span><br><span class="line"></span><br><span class="line">String selection &#x3D; MediaStore.Images.Media.TITLE + &quot;&#x3D;?&quot;;</span><br><span class="line">String[] args &#x3D; new String[] &#123;&quot;Image&quot;&#125;;</span><br><span class="line">String[] projection &#x3D; new String[] &#123;MediaStore.Images.Media._ID&#125;;</span><br><span class="line">Cursor cursor &#x3D; resolver.query(external, projection, selection, args, null);</span><br><span class="line">Uri imageUri &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">    imageUri &#x3D; ContentUris.withAppendedId(external, cursor.getLong(0));</span><br><span class="line">    cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.打开媒体文件：openFileDescriptor()</p>
<p>3.添加媒体文件：Uri songContentUri = resolver.insert(audioCollection, songDetails);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">audioCollection = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">ContentValues songDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,<span class="string">&quot;My Workout Playlist.mp3&quot;</span>);</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>4.更新媒体文件：resolver.update(item, values, null, null);</p>
<p>5.单个媒体文件的缩略图，调用loadThumbnail()。</p>
<h3 id="MediaStore文件操作示例"><a href="#MediaStore文件操作示例" class="headerlink" title="MediaStore文件操作示例"></a>MediaStore文件操作示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打开媒体文件</span><br><span class="line">用于打开媒体文件的具体逻辑取决于媒体内容最佳表示形式是文件描述符、文件流还是直接文件路径：</span><br><span class="line"></span><br><span class="line">文件描述符</span><br><span class="line">如需使用文件描述符打开媒体文件，请使用类似于以下代码段所示的逻辑：</span><br><span class="line"><span class="comment">// Open a specific media item using ParcelFileDescriptor.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;rw&quot; for read-and-write;</span></span><br><span class="line"><span class="comment">// &quot;rwt&quot; for truncating or overwriting existing file contents.</span></span><br><span class="line">String readOnlyMode = <span class="string">&quot;r&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (ParcelFileDescriptor pfd =</span><br><span class="line">        resolver.openFileDescriptor(content-uri, readOnlyMode)) &#123;</span><br><span class="line">    <span class="comment">// Perform operations on &quot;pfd&quot;.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">文件流</span><br><span class="line">如需使用文件流打开媒体文件，请使用类似于以下代码段所示的逻辑：</span><br><span class="line"><span class="comment">// Open a specific media item using InputStream.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"><span class="keyword">try</span> (InputStream stream = resolver.openInputStream(content-uri)) &#123;</span><br><span class="line">    <span class="comment">// Perform operations on &quot;stream&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接文件路径</span><br><span class="line">如果您没有任何与存储空间相关的权限，您可以访问应用专属目录中的文件，并可使用 File API 访问归因于您的应用的媒体文件。  </span><br><span class="line">    </span><br><span class="line">性能</span><br><span class="line">当您使用直接文件路径依序读取媒体文件时，其性能与 MediaStore API 相当。</span><br><span class="line">但是，当您使用直接文件路径随机读取和写入媒体文件时，进程的速度可能最多会慢一倍。在此类情况下，我们建议您改为使用 MediaStore API。</span><br><span class="line"></span><br><span class="line">DATA 列</span><br><span class="line">当您访问现有媒体文件时，您可以使用您的逻辑中 DATA 列的值。这是因为，此值包含有效的文件路径。但是，不要假设文件始终可用。请准备好处理可能发生的任何基于文件的 I/O 错误。</span><br><span class="line">另一方面，如需创建或更新媒体文件，请勿使用 DATA 列的值。请改用 DISPLAY_NAME 和 RELATIVE_PATH 列的值。</span><br><span class="line"></span><br><span class="line">分享</span><br><span class="line">某些应用允许用户彼此分享媒体文件。例如，用户可以通过社交媒体应用与朋友分享照片和视频。</span><br><span class="line">如需共享媒体文件，请按照 </span><br><span class="line">[content provider 创建指南]:</span><br><span class="line">https:<span class="comment">//developer.android.google.cn/guide/topics/providers/content-provider-creating?hl=fr</span></span><br><span class="line">中的建议使用 `content:<span class="comment">//` URI。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">添加项目</span><br><span class="line">如需将媒体项添加到现有集合，请调用类似于以下内容的代码。此代码段可在搭载 Android <span class="number">10</span> 或更高版本的设备上访问 VOLUME_EXTERNAL_PRIMARY 卷。这是因为在这些设备上，您只能修改主要卷的内容，如存储卷部分所述。</span><br><span class="line"><span class="comment">// Add a specific media item.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all audio files on the primary external storage device.</span></span><br><span class="line">Uri audioCollection;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media</span><br><span class="line">            .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish a new song.</span></span><br><span class="line">ContentValues newSongDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">newSongDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,</span><br><span class="line">        <span class="string">&quot;My Song.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keeps a handle to the new song&#x27;s URI in case we need to modify it</span></span><br><span class="line"><span class="comment">// later.</span></span><br><span class="line">Uri myFavoriteSongUri = resolver</span><br><span class="line">        .insert(audioCollection, newSongDetails);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">切换媒体文件的待处理状态</span><br><span class="line">如果您的应用执行可能非常耗时的操作（例如写入媒体文件），那么在处理文件时对其进行独占访问非常有用。在搭载 Android <span class="number">10</span> 或更高版本的设备上，您的应用可以通过将 IS_PENDING 标记的值设为 <span class="number">1</span> 来获取此独占访问权限。如此一来，只有您的应用可以查看该文件，直到您的应用将 IS_PENDING 的值改回 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">以下代码段基于前面的代码段进行构建。以下代码段显示了在与 MediaStore.Audio 集合对应的目录中存储一首较长的歌曲时如何使用 IS_PENDING 标记：</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a media item that other apps shouldn&#x27;t see until the item is</span></span><br><span class="line"><span class="comment">// fully written to the media store.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all audio files on the primary external storage device.</span></span><br><span class="line">Uri audioCollection;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media</span><br><span class="line">            .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ContentValues songDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,</span><br><span class="line">        <span class="string">&quot;My Workout Playlist.mp3&quot;</span>);</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Uri songContentUri = resolver</span><br><span class="line">        .insert(audioCollection, songDetails);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (ParcelableFileDescriptor pfd =</span><br><span class="line">        resolver.openFileDescriptor(songContentUri, <span class="string">&quot;w&quot;</span>, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="comment">// Write data into the pending audio file.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that we&#x27;re finished, release the &quot;pending&quot; status, and allow other apps</span></span><br><span class="line"><span class="comment">// to play the audio track.</span></span><br><span class="line">songDetails.clear();</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">0</span>);</span><br><span class="line">resolver.update(songContentUri, songDetails, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更新项目</span><br><span class="line">如需更新应用拥有的媒体文件，请运行类似于以下内容的代码：</span><br><span class="line"><span class="comment">// Updates an existing media item.</span></span><br><span class="line"><span class="keyword">long</span> mediaId = <span class="comment">// MediaStore.Audio.Media._ID of item to update.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// When performing a single item update, prefer using the ID</span></span><br><span class="line">String selection = MediaStore.Audio.Media._ID + <span class="string">&quot; = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// By using selection + args we protect against improper escaping of</span></span><br><span class="line"><span class="comment">// values. Here, &quot;song&quot; is an in-memory object that caches the song&#x27;s</span></span><br><span class="line"><span class="comment">// information.</span></span><br><span class="line">String[] selectionArgs = <span class="keyword">new</span> String[] &#123; getId().toString() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update an existing song.</span></span><br><span class="line">ContentValues updatedSongDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updatedSongDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,</span><br><span class="line">        <span class="string">&quot;My Favorite Song.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the individual song&#x27;s URI to represent the collection that&#x27;s</span></span><br><span class="line"><span class="comment">// updated.</span></span><br><span class="line"><span class="keyword">int</span> numSongsUpdated = resolver.update(</span><br><span class="line">        myFavoriteSongUri,</span><br><span class="line">        updatedSongDetails,</span><br><span class="line">        selection,</span><br><span class="line">        selectionArgs);</span><br><span class="line"></span><br><span class="line">注意：您可以在调用 update() 的过程中通过更改 MediaColumns.RELATIVE_PATH 或 MediaColumns.DISPLAY_NAME 在磁盘上移动文件。</span><br></pre></td></tr></table></figure>

<h3 id="关于MediaStore-Pending"><a href="#关于MediaStore-Pending" class="headerlink" title="关于MediaStore Pending"></a>关于MediaStore Pending</h3><p>Android Q 上，MediaStore 中添加了一个 IS_PENDING Flag，用于标记当前文件是 Pending 状态。</p>
<p>其他 APP 通过 MediaStore 查询文件，如果没有设置 setIncludePending 接口，就查询不到设置为 Pending 状态的文件，这就能使 APP 专享此文件。</p>
<p>这个 flag 在一些应用场景下可以使用，例如在下载文件的时候：下载中，文件设置为 Pending 状态；下载完成，把文件 Pending 状态置为 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(MediaStore.Images.Media.DISPLAY_NAME, <span class="string">&quot;myImage.PNG&quot;</span>);</span><br><span class="line">values.put(MediaStore.Images.Media.MIME_TYPE, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">values.put(MediaStore.Images.Media.IS_PENDING, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ContentResolver resolver = context.getContentResolver();</span><br><span class="line">Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">Uri item = resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ParcelFileDescriptor pfd = resolver.openFileDescriptor(item, <span class="string">&quot;w&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// write data into the pending image.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    LogUtil.log(<span class="string">&quot;write image fail&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear IS_PENDING flag after writing finished.</span></span><br><span class="line">values.clear();</span><br><span class="line">values.put(MediaStore.Images.Media.IS_PENDING, <span class="number">0</span>);<span class="comment">//释放，使其他应用可以访问</span></span><br><span class="line">resolver.update(item, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>IS_PENDING独占</strong>：Android 10以后，当写入磁盘时 应用可以通过IS_PENDING标志实现对媒体文件的独占访问。</p>
<h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><p>[1] 安卓 11 使用 MediaRecorder 录制视频，由于新的分区存储特性（Scoped Storage，APP 产生的文件只能通过 MediaStore API 写入磁盘），存储路径无法直接使用外部 SD 卡的路径。<br><a href="https://www.jianshu.com/p/edaa0d9df93e">https://www.jianshu.com/p/edaa0d9df93e</a></p>
<p>[2] 重命名由android 10中的应用程序创建的Mediastore的文件<br><a href="https://codingdict.com/questions/107164">https://codingdict.com/questions/107164</a></p>
<p>[3] Android 10、11 存储完全适配！<br><a href="https://blog.csdn.net/fitaotao/article/details/119700579">https://blog.csdn.net/fitaotao/article/details/119700579</a></p>
<p>[4] Android10_存储之scoped storage&amp;媒体文件-分区存储权限变更及适配<br><a href="https://blog.csdn.net/u010227042/article/details/104507886">https://blog.csdn.net/u010227042/article/details/104507886</a></p>
<p>[5] *Android Q 存储新特性适配脑壳疼？指南来了！<br><a href="https://www.163.com/dy/article/EL0CD9QG0511IFOV.html">https://www.163.com/dy/article/EL0CD9QG0511IFOV.html</a><br><a href="https://mp.weixin.qq.com/s/aiDMyAfAZvaYIHuIMLAlcg">https://mp.weixin.qq.com/s/aiDMyAfAZvaYIHuIMLAlcg</a></p>
<p>[6] *访问共享存储空间中的媒体文件<br><a href="https://developer.android.google.cn/training/data-storage/shared/media?hl=fr">https://developer.android.google.cn/training/data-storage/shared/media?hl=fr</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MediaStore</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多线程使用</title>
    <url>/article/123e7dd4.html</url>
    <content><![CDATA[<blockquote>
<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程的应用在开发中非常常见。</p>
</blockquote>
<a id="more"></a>

<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>Android多线程实现的基础使用包括：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>Handler</li>
</ul>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><img src="https://img-blog.csdnimg.cn/2019111311265420.png" alt="继承Thread类"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 步骤1：创建线程类 （继承自Thread类）</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：复写run（），内容 = 定义线程行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ... <span class="comment">// 定义的线程行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤3：创建线程对象，即 实例化线程类</span></span><br><span class="line">  MyThread mt=<span class="keyword">new</span> MyThread(“线程名称”);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤4：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止</span></span><br><span class="line">    <span class="comment">// 此处采用 start（）开启线程</span></span><br><span class="line">  mt.start();</span><br></pre></td></tr></table></figure>

<p>开发者会选择一种更加方便的方法去创建线程：匿名类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：采用匿名类，直接 创建 线程类的实例</span></span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="string">&quot;线程名称&quot;</span>) &#123;</span><br><span class="line">                 <span class="comment">// 步骤2：复写run（），内容 = 定义线程行为</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">                  <span class="comment">// 步骤3：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止   </span></span><br><span class="line">                      &#125;.start();</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><img src="https://img-blog.csdnimg.cn/20191113141230159.png" alt="实现Runnable接口"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 步骤1：创建线程辅助类，实现Runnable接口</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 步骤2：复写run（），定义线程行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤3：创建线程辅助对象，即 实例化 线程辅助类</span></span><br><span class="line">  MyThread mt=<span class="keyword">new</span> MyThread();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤4：创建线程对象，即 实例化线程类；线程类 = Thread类；</span></span><br><span class="line">    <span class="comment">// 创建时通过Thread类的构造函数传入线程辅助类对象</span></span><br><span class="line">    <span class="comment">// 原因：Runnable接口并没有任何对线程的支持，我们必须创建线程类（Thread类）的实例，从Thread类的一个实例内部运行</span></span><br><span class="line">  Thread td=<span class="keyword">new</span> Thread(mt);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤5：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止</span></span><br><span class="line">    <span class="comment">// 当调用start（）方法时，线程对象会自动回调线程辅助类对象的run（），从而实现线程操作</span></span><br><span class="line">  td.start();</span><br></pre></td></tr></table></figure>

<p>开发者会选择一种更加方便的方法去创建线程：匿名类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：通过匿名类 直接 创建线程辅助对象，即 实例化 线程辅助类</span></span><br><span class="line">    Runnable mt = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="comment">// 步骤2：复写run（），定义线程行为</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 步骤3：创建线程对象，即 实例化线程类；线程类 = Thread类；</span></span><br><span class="line">                Thread mt1 = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">           </span><br><span class="line">                <span class="comment">// 步骤4：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止</span></span><br><span class="line">                mt1.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java中真正能创建新线程的只有Thread类对象，通过实现Runnable的方式，最终还是通过Thread类对象来创建线程，所以对于实现了Runnable接口的类，称为线程辅助类；Thread类才是真正的线程类。</p>
</blockquote>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><img src="https://img-blog.csdnimg.cn/20191113165713433.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20191113165928918.png" alt="在这里插入图片描述"></p>
<p>Handler的使用方式 因发送消息到消息队列的方式不同而不同，共分为2种：使用Handler.sendMessage（）、使用Handler.post（）</p>
<p>Handler.sendMessage（）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">      * 方式1：新建Handler子类（内部类）</span><br><span class="line">      *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 步骤1：自定义Handler子类（继承Handler类） &amp; 复写handleMessage（）方法</span><br><span class="line">    class mHandler extends Handler &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 通过复写handlerMessage() 从而确定更新UI的操作</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">         ...&#x2F;&#x2F; 需执行的UI操作</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤2：在主线程中创建Handler实例</span><br><span class="line">        private Handler mhandler &#x3D; new mHandler();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤3：创建所需的消息对象</span><br><span class="line">        Message msg &#x3D; Message.obtain(); &#x2F;&#x2F; 实例化消息对象</span><br><span class="line">        msg.what &#x3D; 1; &#x2F;&#x2F; 消息标识</span><br><span class="line">        msg.obj &#x3D; &quot;AA&quot;; &#x2F;&#x2F; 消息内容存放</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span><br><span class="line">    &#x2F;&#x2F; 可通过sendMessage（） &#x2F; post（）</span><br><span class="line">    &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤5：开启工作线程（同时启动了Handler）</span><br><span class="line">    &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;** </span><br><span class="line">  * 方式2：匿名内部类</span><br><span class="line">  *&#x2F;</span><br><span class="line">   &#x2F;&#x2F; 步骤1：在主线程中 通过匿名内部类 创建Handler类对象</span><br><span class="line">            private Handler mhandler &#x3D; new  Handler()&#123;</span><br><span class="line">                &#x2F;&#x2F; 通过复写handlerMessage()从而确定更新UI的操作</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(Message msg) &#123;</span><br><span class="line">                        ...&#x2F;&#x2F; 需执行的UI操作</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 步骤2：创建消息对象</span><br><span class="line">    Message msg &#x3D; Message.obtain(); &#x2F;&#x2F; 实例化消息对象</span><br><span class="line">      msg.what &#x3D; 1; &#x2F;&#x2F; 消息标识</span><br><span class="line">      msg.obj &#x3D; &quot;AA&quot;; &#x2F;&#x2F; 消息内容存放</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 步骤3：在工作线程中 通过Handler发送消息到消息队列中</span><br><span class="line">  &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br><span class="line">   mHandler.sendMessage(msg);</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 步骤4：开启工作线程（同时启动了Handler）</span><br><span class="line">  &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告提示：This Handler class should be static or leaks might occur (anonymous android.os.Handler)</p>
<p>官方解决方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
</blockquote>
<p>Handler.post（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：在主线程中创建Handler实例</span></span><br><span class="line">    <span class="keyword">private</span> Handler mhandler = <span class="keyword">new</span> mHandler();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容</span></span><br><span class="line">    <span class="comment">// 需传入1个Runnable对象</span></span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ... <span class="comment">// 需执行的UI操作 </span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤3：开启工作线程（同时启动了Handler）</span></span><br><span class="line">    <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br></pre></td></tr></table></figure>

<h2 id="复合使用"><a href="#复合使用" class="headerlink" title="复合使用"></a>复合使用</h2><p>Android多线程实现的复合使用包括：</p>
<ul>
<li>AsyncTask</li>
<li>HandlerThread</li>
<li>IntentService</li>
</ul>
<p>称为”复用“的主要原因是：这3种方式的本质原理都是Android多线程基础实现（继承Thread类、实现Runnable接口、Handler）的组合实现。下面，我将详细讲解。</p>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p><img src="https://img-blog.csdnimg.cn/20191119160207922.png" alt="AsyncTask"></p>
<blockquote>
<p>AsyncTask类属于抽象类，即使用时需实现子类</p>
<p>AsyncTask的使用步骤</p>
<ol>
<li>创建 AsyncTask 子类 &amp; 根据需求实现核心方法</li>
<li>创建 AsyncTask子类的实例对象（即 任务实例）</li>
<li>手动调用execute(（）从而执行异步线程任务</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 步骤1：创建AsyncTask子类</span></span><br><span class="line"><span class="comment">  * 注： </span></span><br><span class="line"><span class="comment">  *   a. 继承AsyncTask类</span></span><br><span class="line"><span class="comment">  *   b. 为3个泛型参数指定类型；若不使用，可用java.lang.Void类型代替</span></span><br><span class="line"><span class="comment">  *   c. 根据需求，在AsyncTask子类内实现核心方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        ....</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法1：onPreExecute（）</span></span><br><span class="line">      <span class="comment">// 作用：执行 线程任务前的操作</span></span><br><span class="line">      <span class="comment">// 注：根据需求复写</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法2：doInBackground（）</span></span><br><span class="line">      <span class="comment">// 作用：接收输入参数、执行任务中的耗时操作、返回 线程任务执行的结果</span></span><br><span class="line">      <span class="comment">// 注：必须复写，从而自定义线程任务</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            ...<span class="comment">// 自定义的线程任务</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（）</span></span><br><span class="line">             publishProgress(count);</span><br><span class="line">              </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法3：onProgressUpdate（）</span></span><br><span class="line">      <span class="comment">// 作用：在主线程 显示线程任务执行的进度</span></span><br><span class="line">      <span class="comment">// 注：根据需求复写</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progresses)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法4：onPostExecute（）</span></span><br><span class="line">      <span class="comment">// 作用：接收线程任务执行结果、将执行结果显示到UI组件</span></span><br><span class="line">      <span class="comment">// 注：必须复写，从而自定义UI操作</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         ...<span class="comment">// UI操作</span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法5：onCancelled()</span></span><br><span class="line">      <span class="comment">// 作用：将异步任务设置为：取消状态</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 步骤2：创建AsyncTask子类的实例对象（即 任务实例）</span></span><br><span class="line"><span class="comment">  * 注：AsyncTask子类的实例必须在UI线程中创建</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  MyTask mTask = <span class="keyword">new</span> MyTask();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 步骤3：手动调用execute(Params... params) 从而执行异步线程任务</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *    a. 必须在UI线程中调用</span></span><br><span class="line"><span class="comment">  *    b. 同一个AsyncTask实例对象只能执行1次，若执行第2次将会抛出异常</span></span><br><span class="line"><span class="comment">  *    c. 执行任务中，系统会自动调用AsyncTask的一系列方法：onPreExecute() 、doInBackground()、onProgressUpdate() 、onPostExecute() </span></span><br><span class="line"><span class="comment">  *    d. 不能手动调用上述方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  mTask.execute()；</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20191119161139902.png" alt="AsyncTask参数"></p>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p><img src="https://img-blog.csdnimg.cn/20191119173637458.png" alt="HandlerThread"></p>
<p>HandlerThread的本质：继承Thread类 &amp; 封装Handler类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">   HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">   mHandlerThread.start();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">  Handler workHandler = <span class="keyword">new</span> Handler( handlerThread.getLooper() ) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                ...<span class="comment">//消息处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤4：使用工作线程Handler向工作线程的消息队列发送消息</span></span><br><span class="line"><span class="comment">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line">  <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">  Message msg = Message.obtain();</span><br><span class="line">  msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">  msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">  <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">  workHandler.sendMessage(msg);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">  mHandlerThread.quit();</span><br></pre></td></tr></table></figure>

<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>Android里的一个封装类，继承四大组件之一的Service</p>
<blockquote>
<p>作用：处理异步请求 &amp; 实现多线程<br>使用场景：线程任务需按顺序、在后台执行</p>
<ul>
<li>最常见的场景：离线下载</li>
<li>不符合多个数据同时请求的场景：所有的任务都在同一个Thread looper里执行</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤<span class="number">1</span>：定义 IntentService的子类:传入线程名称、复写onHandleIntent()方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 在构造函数中传入线程名字</span></span><br><span class="line"><span class="comment">    **/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="comment">// 参数 = 工作线程的名字</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;myIntentService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onHandleIntent()方法</span></span><br><span class="line"><span class="comment">     * 根据 Intent实现 耗时任务 操作</span></span><br><span class="line"><span class="comment">     **/</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根据 Intent的不同，进行不同的事务处理</span></span><br><span class="line">        String taskName = intent.getExtras().getString(<span class="string">&quot;taskName&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (taskName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;task1&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;do task1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;task2&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;do task2&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onStartCommand()方法</span></span><br><span class="line"><span class="comment">     * 默认实现 = 将请求的Intent添加到工作队列里</span></span><br><span class="line"><span class="comment">     **/</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onStartCommand&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onDestroy&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">2</span>：在Manifest.xml中注册服务</span><br><span class="line">&lt;service android:name=<span class="string">&quot;.myIntentService&quot;</span>&gt;</span><br><span class="line">            &lt;intent-filter &gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;cn.scu.finch&quot;</span>/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;    </span><br><span class="line">                    </span><br><span class="line">步骤<span class="number">3</span>：在Activity中开启Service服务</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 同一服务只会开启1个工作线程</span></span><br><span class="line">            <span class="comment">// 在onHandleIntent（）函数里，依次处理传入的Intent请求</span></span><br><span class="line">            <span class="comment">// 将请求通过Bundle对象传入到Intent，再传入到服务里</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 请求1</span></span><br><span class="line">            Intent i = <span class="keyword">new</span> Intent(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task1&quot;</span>);</span><br><span class="line">            i.putExtras(bundle);</span><br><span class="line">            startService(i);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 请求2</span></span><br><span class="line">            Intent i2 = <span class="keyword">new</span> Intent(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            Bundle bundle2 = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle2.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line">            i2.putExtras(bundle2);</span><br><span class="line">            startService(i2);</span><br><span class="line"> </span><br><span class="line">            startService(i);  <span class="comment">//多次启动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="线程池（ThreadPool）"><a href="#线程池（ThreadPool）" class="headerlink" title="线程池（ThreadPool）"></a>线程池（ThreadPool）</h3><p><img src="https://img-blog.csdnimg.cn/20191119184102293.png" alt="ThreadPool"></p>
<p>1、ThreadPoolExecutor 创建基本线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建基本线程池</span></span><br><span class="line"><span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本线程池使用:设置一个按钮mThreadPoolExecute，并在点击事件中使用线程池</span></span><br><span class="line"> mThreadPoolExecute.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> finali = i;</span><br><span class="line">                    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                                Log.d(<span class="string">&quot;Thread&quot;</span>, <span class="string">&quot;run: &quot;</span>+finali);</span><br><span class="line">                                Log.d(<span class="string">&quot;当前线程：&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    threadPoolExecutor.execute(runnable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>其他几种常见的线程池</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20191119185404571.png" alt="在这里插入图片描述"></p>
<p>2.FixedThreadPool (可重用固定线程数)</p>
<p>3.CachedThreadPool (按需创建)</p>
<p>4.SingleThreadPool(单个核线的fixed)</p>
<p>5.ScheduledThreadPool(定时延时执行)</p>
<blockquote>
<p>[1] <a href="https://blog.csdn.net/u013773608/article/details/124329942">https://blog.csdn.net/u013773608/article/details/124329942</a></p>
<p>[2] <a href="https://blog.csdn.net/qq_41648631/article/details/102871630">https://blog.csdn.net/qq_41648631/article/details/102871630</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Thread</tag>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的反射机制</title>
    <url>/article/5337b80a.html</url>
    <content><![CDATA[<blockquote>
<p>Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。Java 的这一能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一特性。</p>
</blockquote>
<a id="more"></a>

<h2 id="Java的类加载"><a href="#Java的类加载" class="headerlink" title="Java的类加载"></a>Java的类加载</h2><ul>
<li>编译：java文件编译后生成class字节码文件</li>
<li>类加载机制：JVM把class文件加载到内存，并对数据进行校验、准备、解析、初始化，最终形成JVM可以直接使用的Java类型的过程。<br><img src="https://img-blog.csdnimg.cn/cc40b19fbce5410f877a062d3f225fca.png" alt="类加载机制"><h2 id="Java的反射机制"><a href="#Java的反射机制" class="headerlink" title="Java的反射机制"></a>Java的反射机制</h2>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取、调用对象方法的功能称为Java语言的反射机制。</li>
</ul>
<p>Java的反射就是利用上面第二步加载到JVM中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。</p>
<p>总体来说，反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。例如一个类有成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<blockquote>
<p>反射的必要性：<br>1.反射机制是很多java框架的基石。<br>2.有时候要适应某些需求，Java类里面不一定能直接调用另外的方法，这时候也可以通过反射机制来实现。</p>
<p>反射的缺点：<br>反射的代码比正常调用的代码更多，性能也慢，所以应避免使用反射。</p>
</blockquote>
<h2 id="Java反射获取对象"><a href="#Java反射获取对象" class="headerlink" title="Java反射获取对象"></a>Java反射获取对象</h2><blockquote>
<p>Class类：代表一个类<br>Constructor类：代表类的构造方法<br>Field类：代表类的成员变量（类的属性）<br>Method类：代表类的方法</p>
</blockquote>
<h3 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取Class对象的三种方式</span><br><span class="line"><span class="number">1.</span>通过对象获取      对象名.getClass()</span><br><span class="line"><span class="number">2.</span>通过类名获取      类名.class </span><br><span class="line"><span class="number">3.</span>通过全类名获取    Class.forName(全类名)   </span><br><span class="line"></span><br><span class="line">三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三中方式获取Class对象</span></span><br><span class="line">Class stuClass = Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">System.out.println(stuClass.getName());</span><br></pre></td></tr></table></figure>
<h3 id="2-获取Constructor构造方法对象"><a href="#2-获取Constructor构造方法对象" class="headerlink" title="2.获取Constructor构造方法对象"></a>2.获取Constructor构造方法对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>获取构造方法：</span><br><span class="line"><span class="number">1</span>).批量的方法：</span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors()：所有<span class="string">&quot;公有的&quot;</span>构造方法</span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line">     </span><br><span class="line"><span class="number">2</span>).获取单个的方法，并调用：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span>:获取单个的&quot;公有的&quot;构造方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>:获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">调用构造方法：</span></span><br><span class="line"><span class="function">Constructor--&gt;<span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2.newInstance是 Constructor类的方法（管理构造函数的类）</span></span><br><span class="line"><span class="function">api的解释为：<span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function">使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</span></span><br><span class="line"><span class="function">它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3.Constructor con </span>= clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">1</span>)因为是无参的构造方法所以类型是一个<span class="keyword">null</span>,不写也可以：这里需要的是一个参数的类型，切记是类型</span><br><span class="line"><span class="number">2</span>)返回的是描述这个无参构造函数的类对象。</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1.加载Class对象</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);</span><br><span class="line">Constructor  con = clazz.getDeclaredConstructor(<span class="keyword">char</span>.class);</span><br><span class="line">System.out.println(con);</span><br><span class="line"><span class="comment">//调用构造方法</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"><span class="comment">//Student stu = (Student)obj;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-获取Field成员变量对象"><a href="#3-获取Field成员变量对象" class="headerlink" title="3.获取Field成员变量对象"></a>3.获取Field成员变量对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取成员变量并调用：</span><br><span class="line"><span class="number">1.</span>批量的</span><br><span class="line">Field[] getFields():获取所有的<span class="string">&quot;公有字段&quot;</span></span><br><span class="line">Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span><br><span class="line"><span class="number">2.</span>获取单个的：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String fieldName)</span>:获取某个&quot;公有的&quot;字段；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String fieldName)</span>:获取某个字段<span class="params">(可以是私有的)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">设置字段的值：</span></span><br><span class="line"><span class="function">Field --&gt; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj,Object value)</span>:</span></span><br><span class="line"><span class="function">第一个参数：要传入设置的对象，第二个参数：要传入实参</span></span><br><span class="line"><span class="function">参数说明：</span></span><br><span class="line"><span class="function">1.obj:要设置的字段所在的对象；</span></span><br><span class="line"><span class="function">2.value:要为字段设置的值；</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//1.获取Class对象</span></span></span><br><span class="line"><span class="function">Class stuClass </span>= Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);</span><br><span class="line">Field f = stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//获取一个对象</span></span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();<span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line"><span class="comment">//为字段设置值</span></span><br><span class="line">f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line"><span class="comment">//验证</span></span><br><span class="line">Student stu = (Student)obj;</span><br><span class="line">System.out.println(<span class="string">&quot;验证姓名：&quot;</span> + stu.name);</span><br></pre></td></tr></table></figure>
<h3 id="4-获取Method成员方法对象"><a href="#4-获取Method成员方法对象" class="headerlink" title="4.获取Method成员方法对象"></a>4.获取Method成员方法对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取成员方法并调用：</span><br><span class="line"><span class="number">1.</span>批量的：</span><br><span class="line"><span class="keyword">public</span> Method[] getMethods():获取所有<span class="string">&quot;公有方法&quot;</span>；（包含了父类的方法也包含Object类）</span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span><br><span class="line"><span class="number">2.</span>获取单个的：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name,Class&lt;?&gt;... parameterTypes)</span>:</span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">name : 方法名；</span></span><br><span class="line"><span class="function">Class ... : 形参的Class类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name,Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">调用方法：</span></span><br><span class="line"><span class="function">Method --&gt; <span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj,Object... args)</span>:</span></span><br><span class="line"><span class="function">参数说明：</span></span><br><span class="line"><span class="function">obj : 要调用方法的对象；</span></span><br><span class="line"><span class="function">args:调用方式时所传递的实参；</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//1.获取Class对象</span></span></span><br><span class="line"><span class="function">Class stuClass </span>= Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);</span><br><span class="line">Method m = stuClass.getMethod(<span class="string">&quot;show1&quot;</span>, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">//m.setAccessible(true);//解除私有限定</span></span><br><span class="line"><span class="comment">//实例化一个Student对象</span></span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">Object result = m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1] <a href="https://www.cnblogs.com/tech-bird/p/3525336.html">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflection</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenAPI的介绍及其使用</title>
    <url>/article/f7f06827.html</url>
    <content><![CDATA[<blockquote>
<p>API的全称是应用编程接口（Application Programming Interface），这并不是一个新概念，在计算机操作系统出现的早期就已经存在了。在互联网时代，把网站的服务封装成一系列计算机易识别的数据接口开放出去，供第三方开发者使用，这种行为就叫做开放网站的API，与之对应的，所开放的API就被称作openAPI。</p>
</blockquote>
<a id="more"></a>

<h2 id="OSCHINA-API的使用"><a href="#OSCHINA-API的使用" class="headerlink" title="OSCHINA API的使用"></a>OSCHINA API的使用</h2><p>OSCHINA API：<a href="https://www.oschina.net/openapi/docs">https://www.oschina.net/openapi/docs</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 什么是token</span><br><span class="line">token（令牌）是一串唯一的字符串，通常由服务端生成，在注册完成时返回给客户端，用来标识此用户，客户端将此字符串存储在本地。在以后的网络请求时，客户端先查询本地的token，如果有则直接使用此令牌进行网络请求，没有则提示未登录，转到登陆注册界面。</span><br><span class="line">此外，还可以在服务端或者客户端添加过期判别机制。</span><br><span class="line"></span><br><span class="line">- token的作用</span><br><span class="line">token可以显著减少服务端对用户表的查询，同时使用户不必每次都登陆，提高了系统的可用性与健壮性。</span><br><span class="line"></span><br><span class="line">- 使用SharedPreferences保存token</span><br></pre></td></tr></table></figure>

<p>1.创建应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">状态		正在审核</span><br><span class="line">应用ID	GCqPUbrIaoe7nUScRlet</span><br><span class="line">应用私钥	YFJDhiYsnyI6qW8nzdAHYIPocZsPEff1</span><br><span class="line">应用首页	https://fangjian98.github.io/    </span><br><span class="line">回调地址	http://192.168.0.106/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/oschina_api.png" alt="OSCHINA API"></p>
<p>2.OAuth2 获取 AccessToken，应用通过 AccessToken 访问 OpenApi 使用用户数据。<br>采用 OAuth2 协议 认证，开放 osc 移动 app 版本所有接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line"><span class="comment"># 用户授权码的回调地址直接获取code</span></span><br><span class="line"><span class="comment"># 构造Uri：/action/oauth2/authorize</span></span><br><span class="line"><span class="comment"># client_id(应用ID)和redirect_uri(回调地址)</span></span><br><span class="line">https://www.oschina.net/action/oauth2/authorize?response_type=code&amp;client_id=GCqPUbrIaoe7nUScRlet&amp;redirect_uri=http://192.168.0.106/</span><br><span class="line"><span class="comment"># 返回用户授权码code</span></span><br><span class="line">http://192.168.0.106/?code=iap9LL&amp;state=</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line"><span class="comment"># 应用服务器使用 oauth2_token API 向 OSChina 认证服务器发送用户授权码以及回调地址，OSChina 认证服务器返回 AccessToken</span></span><br><span class="line"><span class="comment"># 构造Uri:/action/openapi/token</span></span><br><span class="line"><span class="comment"># client_id(应用ID)和redirect_uri(回调地址)和client_secret(应用私钥)和code(用户授权码)</span></span><br><span class="line">https://www.oschina.net/action/openapi/token?client_id=GCqPUbrIaoe7nUScRlet&amp;client_secret=YFJDhiYsnyI6qW8nzdAHYIPocZsPEff1&amp;grant_type=authorization_code&amp;code=pZ6Ye2&amp;redirect_uri=http://192.168.0.106/&amp;dataType=json</span><br><span class="line"><span class="comment"># 返回AccessToken</span></span><br><span class="line">&#123;<span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;09a10176-7772-4577-8856-1b396f86e83b&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;da728b79-3b0d-4062-961b-bd67c09ecbcd&quot;</span>,<span class="string">&quot;uid&quot;</span>:4470181,<span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,<span class="string">&quot;expires_in&quot;</span>:604799&#125;</span><br><span class="line"></span><br><span class="line">3.使用AccessToken请求：参考OpenAPI文档即可</span><br><span class="line"><span class="comment"># 新闻news_list</span></span><br><span class="line"><span class="comment"># 构造Uri:/action/openapi/news_list</span></span><br><span class="line"><span class="comment"># access_token catalog page pageSize dataType</span></span><br><span class="line">https://www.oschina.net/action/openapi/news_list?access_token=09a10176-7772-4577-8856-1b396f86e83b&amp;catalog=2&amp;page=1&amp;pageSize=10&amp;dataType=json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				必选	类型及范围	说明				默认值</span><br><span class="line">access_token	<span class="literal">true</span>	string	oauth2_token获取的access_token	</span><br><span class="line">catalog			<span class="literal">true</span>	int		1-所有|2-综合新闻|3-软件更新		1</span><br><span class="line">page/pageIndex	<span class="literal">true</span>	int		页数	1</span><br><span class="line">pageSize		<span class="literal">true</span>	int		每页条数	20</span><br><span class="line">dataType		<span class="literal">true</span>	string	返回数据类型[<span class="string">&#x27;json&#x27;</span>|<span class="string">&#x27;jsonp&#x27;</span>|<span class="string">&#x27;xml&#x27;</span>]	json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新闻news_detail</span></span><br><span class="line"><span class="comment"># 构造Uri:/action/openapi/news_detail</span></span><br><span class="line"><span class="comment"># id access_token</span></span><br><span class="line">https://www.oschina.net/action/openapi/news_detail?id=188164&amp;access_token=6983b81e-5e2e-4685-888f-36abcf3f2da7&amp;dataType=json</span><br><span class="line"></span><br><span class="line">				必选	类型及范围	说明	默认值</span><br><span class="line">id				<span class="literal">true</span>	long	新闻编号	空</span><br><span class="line">access_token	<span class="literal">false</span>	string	oauth2_token获取的access_token 传则显示是否收藏 用户未登录则不传	</span><br><span class="line">dataType		<span class="literal">false</span>	string	返回数据类型 [<span class="string">&#x27;json&#x27;</span>|<span class="string">&#x27;jsonp&#x27;</span>|<span class="string">&#x27;xml&#x27;</span>]	json</span><br></pre></td></tr></table></figure>

<h2 id="其他平台开放API"><a href="#其他平台开放API" class="headerlink" title="其他平台开放API"></a>其他平台开放API</h2><ul>
<li>CODING OPEN API：<a href="https://help.coding.net/openapi">https://help.coding.net/openapi</a></li>
<li>有道云笔记API：<a href="http://note.youdao.com/open/index.html">http://note.youdao.com/open/index.html</a></li>
<li><a href="https://www.cnblogs.com/trackingmore/p/7156877.html">常用精品API接口汇总</a></li>
</ul>
<h2 id="Json解析"><a href="#Json解析" class="headerlink" title="Json解析"></a>Json解析</h2><p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON格式取代了xml给网络传输带来了很大的便利，是最常见的数据返回类型。</p>
<p>常见的Json解析库</p>
<ul>
<li>org.json库</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Android给我们提供的Json解析类，官方提供的JSONArray与JSONObject</span><br><span class="line">这些API都存在于org.json包下，而我们用到的类有下面这些：</span><br><span class="line">JSONObject： Json对象，可以完成Json字符串与Java对象的相互转换</span><br><span class="line">JSONArray： Json数组，可以完成Json字符串与Java集合或对象的相互转换</span><br><span class="line">JSONStringer： Json文本构建类，这个类可以帮助快速和便捷的创建JSON text， 每个</span><br><span class="line">JSONStringer实体只能对应创建一个JSON text</span><br><span class="line">JSONTokener：Json解析类</span><br><span class="line">JSONException：Json异常</span><br></pre></td></tr></table></figure>

<ul>
<li>fastjson</li>
<li>gson</li>
</ul>
<blockquote>
<p>[1] <a href="https://www.cnblogs.com/lushimei/p/13436096.html">https://www.cnblogs.com/lushimei/p/13436096.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于应用容器引擎Docker</title>
    <url>/article/9ca11197.html</url>
    <content><![CDATA[<blockquote>
<p>Docker 是一个开源的应用容器引擎，优点是开箱即用，快速部署，可移植性强，环境隔离。</p>
</blockquote>
<a id="more"></a>

<p>Docker三要素</p>
<ul>
<li>镜像(Image) : </li>
</ul>
<p>​    Docker 镜像就是一个只读的模板，镜像可以用来创建Docker容器。Docker提供了一个很简单的机制来创建镜    像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。镜像是一种文    件结构。Dockerfile中的每条命令都会在文件系统中创建一个新的层次结构，文件系统在这些层次上构建起来，    镜像就构建于这些联合的文件系统之上。Docker官方网站专门有一个页面来存储所有可用的镜像，</p>
<p>​    网址是: index.docker.io。</p>
<ul>
<li><p>容器( Container)</p>
<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的Linux环境，Docker利用容器来运行应用。</p>
</li>
<li><p>仓库(Repository)</p>
<p>仓库是集中存放镜像文件的场所,仓库注册服务器(Registry)上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)。目前，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SMB通信协议</title>
    <url>/article/67e1ad8.html</url>
    <content><![CDATA[<blockquote>
<p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>samba</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2.安装 samba</span><br><span class="line">sudo apt-get install samba</span><br><span class="line">3. 创建共享文件夹</span><br><span class="line">mkdir 777 /home/share</span><br><span class="line">4. 修改共享文件夹权限</span><br><span class="line">chmod 777 /home/share</span><br><span class="line">5. 编辑smb.conf</span><br><span class="line">vim /etc/samba/smb.conf (先检查vim是否安装，如果没有安装先安装sudo apt-get install vim)</span><br><span class="line">在文档的最后加入</span><br><span class="line">[share]</span><br><span class="line">path=/home/share</span><br><span class="line">available=yes</span><br><span class="line">browseable=yes</span><br><span class="line">public=yes</span><br><span class="line">writable=yes //这条只表明客户端可以创建文件并且能修改,但是却不能修改服务端创建出来的文件.</span><br><span class="line"></span><br><span class="line">6.重启samba服务</span><br><span class="line">service smbd restart</span><br><span class="line">7. 访问</span><br><span class="line">windows中，win+r 输入\ip</span><br><span class="line">或在工作组计算机中找到ubuntu主机即可访问</span><br><span class="line">ubuntu中，connect to server smb://ip/即可访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原因是客户端创建出来的文件所属user是nobdoy, group是nogroup, 而服务端的user/group是kris/kris.</span><br><span class="line">两个不同用户和不同组不能相互修改.</span><br><span class="line"></span><br><span class="line">网上资料一般提供的方法都是直接将共享目录下的所有文件权限修改:</span><br><span class="line"><span class="comment"># chmod -R 777 /home/kris</span></span><br><span class="line"></span><br><span class="line">可是如果使用git,这种情况下用git status去查看会是一片红啊!</span><br><span class="line">而且如果服务端再新增文件呢,又要去改权限...</span><br><span class="line"></span><br><span class="line">其实smb.conf提供了另外一个配置叫force user, 它表示客户端默认创建的文件所属用户,</span><br><span class="line">只要和服务端设置成一样,那么就直接可以创建和修改所有文件了.</span><br><span class="line"></span><br><span class="line">最终添加的配置如下:</span><br><span class="line">[kris]</span><br><span class="line">comment=<span class="string">&quot;Kris&#x27;s Home&quot;</span></span><br><span class="line">path=/home/kris</span><br><span class="line">available = yes</span><br><span class="line">browseable = yes</span><br><span class="line">public = yes</span><br><span class="line">writable = yes</span><br><span class="line">create mask = 0644    //创建文件属性</span><br><span class="line">force user = kris    //和服务端用户一样</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>Samba</tag>
      </tags>
  </entry>
  <entry>
    <title>关于TEX、LATEX、KATEX的关系</title>
    <url>/article/2b2380bd.html</url>
    <content><![CDATA[<blockquote>
<p>TEX是一个电子排版系统，它的出现给印刷出版业带来了一场革命。但TEX对于使用者的要求比较高，所以出现了LATEX使得使用者可以更方便的利用TEX的强大功能。KATEX则是一种LATEX的一个快速web数学公式渲染器，使得LATEX的公式可以快速渲染出来。</p>
</blockquote>
<a id="more"></a>

<h2 id="TEX"><a href="#TEX" class="headerlink" title="TEX"></a>TEX</h2><p>说到排版系统不得不提的就是TEX。TEX是一种排版系统，是基于宏的流行的文本格式化程序。它提供了一套功能强大并且十分灵活的排版语言，多达900多条指令，而且有宏功能，用户可以不断地定义自己适用的新命令来扩展TEX系统的功能。<br>TEX系统的排版结果DVI文件与输出设备无关，DVI文件可以显示、打印、照排，几乎可以在所有的输出设备上输出。利用TEX可以很容易地生成高质量的dvi文件，打印输出。<br>它在学术界十分流行，特别是数学、物理学、统计学与计算机科学界。被普遍认为是一个很好的排版工具，特别是在处理复杂的数学公式时。<br>利用TEX提供的宏定义功能可以对TEX进行二次开发。它是包括LaTeX和teTeX在内的其它的此类格式化程序的基础。利用诸如LaTeX等终端软件，TEX就能够排版出精美的文本。通过CTAN上的宏包可以扩展其功能，可以做幻灯片，定义模板。中文支持可以由CCT、CJK、ctex等来完成。<br>TEX有几种常见的格式：</p>
<p>Plain TEX：TEX的作者设计了Plain TEX的基本格式，以与低层的TEX互应。这种格式是用TEX处理文本时相当基本的部分，以致于我们有时都分不清到底那条指令是真正处理程序TEX的，哪条是这个特殊格式的。Plain TEX也是其他格式的基础，有些人认为TEX和Plain TEX是同一件事。<br>LATEX：Plain TEX的重点还只是在于如何排版的层次上，而不是从一位作者的观点的观点出发。当然对它的深层功能的进一步发掘，需要相当丰富的编程技巧。因此它的应用就需要高级排版和程序设计人员。正是由此种种原因，开发了LATEX格式，这种格式提供了一组生成复杂文档所需的更高级命令。利用这种格式，即使使用者没有排版和程序设计的只是也可以充分发挥由TEX所提供的强大功能。对于生成复杂表格和数学公式，这一点表现得尤为突出。LATEX相对于其基础Plain TEX而言，更像一个包装语言。它可以在作者根本不知道所以然的条件下，自动给出标题，章节，表格目录，交叉索引，公式编号，文献引用，浮动图表。版面布局信息包含在类文件中，这些类文件并不是位于源文件中的。这些布局可以改动，也可以直接采用。<br>LATEX2ϵ \epsilonϵ:由于LATEX相当普及，以及它在许多原本没想象到的领域中的扩展，再加上计算机技术的日新月异，特别是价格低廉，但功能强大的激光打印机的出现，使得相当广泛的一类格式都冠以LATEX的标签。为了尝试建立一个真正的改进标准，创立了LATEX3项目，目标是建立一个最优的，有效的命令集合，这些命令是来自于各种软件包为了实现某一目的而设计出来的。朝向这个目标迈进的第一步是发行了LATEX2ϵ \epsilonϵ。也就是LATEX的当前版本。<br>TEX的优点：</p>
<p>高质量的输出：TEX遵循传统的排版规则，以排版的质量为最重要的目标。<br>超常的稳定性：自从TEX出现以来，只有一些微小的改动。也就是说，十几年前的TEX文件用现在的TEX系统排版得到的结果与十几年前得到的结果是一样的。稳定性还体现在TEX系统极少会崩溃，可以处理任意大小的文件，即使你的计算机的内存很少，TEX也可自如的工作。<br>TEX是可编程的，TEX是一种宏命令编程语言：你可以用很少的命令来完成非常复杂的工作。如果需要的话，你也可以重新定义TEX的所有命令来得到特殊的效果。<br>高度的灵活性：TEX自从数显以来其内核只有微小的改动。但是由于其内核的设计方式，世界上的TEX使用者可以让TEX做几乎任何工作。你可以用TEX来排版英文文本，也可以排版德文、俄文、中文等多种语言。你还可以用TEX来排版乐谱，象棋，围棋棋谱等等。<br>简单方便TEX文档是ASCII码的文本文件：因此，即使你手边没有TEX系统，你也可以看懂绝大部分内容。TEX文件的这种特点使得它占用很少的存储空间，也可以很方便的用email来传输。<br>目前为止，TEX几乎在所有的计算机操作系统平台上得到实现：如Atari，Apple，Macintosh，Unix，VMS，MS-DOS，MS-Windows和OS/2等等。TEX的源文件可在不同的平台之间自由的交换，而得到的输出是完全相同的。<br>TEX是免费软件，它的源程序也是免费的：你可能仅需要制服邮费，甚至一分不花得得到适合你的TEX系统。<br>超级技术支持：由于TEX并不是被某个公司垄断开发，所以世界各地的使用者设计了统一的技术支持方式。<br>TEX是一种乐趣：使用TEX不仅仅是一种工作手段，也是一种乐趣。它有挑战，也有荣誉。很多人在熟悉TEX之后都开始把使用TEX作为一种爱好，而不是一件枯燥无味的劳动。</p>
<h2 id="LATEX"><a href="#LATEX" class="headerlink" title="LATEX"></a>LATEX</h2><p>在上面的介绍中已经提到过，LATEX使用TEX作为格式化引擎，当前的版本是LATEX2ϵ \epsilonϵ。<br>LATEX是当今世界上最流行和使用最广泛的TEX宏集。它构筑在Plain TEX的基础上，并加进了很多的功能以使得使用者可以更方便的利用TEX的强大功能。<br>使用LATEX基本不需要使用者自己设计命令和宏等。因为LATEX已经替你做好了。因此，即使使用者并不是很了解TEX，也可以在短短的时间内生成高质量的文档。对于生成复杂的数学公式，LATEX表现的更为出色。</p>
<p>也就是说，LATEX是TEX中的一种格式，是建立在TEX基础上的宏语言，每一个LATEX命令实际上最后都会被转换解释称几个甚至上百个TEX命令。但是，普通用户可以无需知道这中间复杂的联系。就像变成的时候如果使用一些已经编译好的函数库和模版可以使我们仅仅用几个命令就实现很多功能一样。LATEX根据人们排版文章的习惯，定义了许多命令和模版，我们可以很快的得到漂亮的排版结果。</p>
<blockquote>
<p>一份不太简短的 LaTeX2ε 介绍【中文资料】（lshort中文版 <a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf%EF%BC%89">https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf）</a><br>LaTeX for Complete Novices【英文资料】（pdf, 源代码, <a href="http://www.dickimaw-books.com/latex/novices/%EF%BC%89">http://www.dickimaw-books.com/latex/novices/）</a><br>黄正华老师 LaTeX 教学首页.<a href="http://aff.whu.edu.cn/huangzh/">http://aff.whu.edu.cn/huangzh/</a></p>
</blockquote>
<h2 id="KATEX"><a href="#KATEX" class="headerlink" title="KATEX"></a>KATEX</h2><p>KaTeX： 可汗学院出品，号称“最快”的数学公式渲染库，支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8~IE11。</p>
<p>KATEX是一个web数学公式渲染器。我们日常写博客用的markdown并不支持数学公式编辑，这些公式仅靠编辑器自带的排版功能是难以表示的，所以需要掌握网页公式编辑方案。<br>目前比较流行的网页公式编辑方案是采用TEX/LATEX语法编辑，知名的有MathJax、KATEX。与前者相比，KATEX方案的渲染速度高，虽然支持不够全面，但仍能满足大多数的使用环境。<br>我们可以在KATEX官网来在线渲染我们写好的LATEX公式，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190817152527198.png" alt="在这里插入图片描述"></p>
<h2 id="LaTeX写作软件"><a href="#LaTeX写作软件" class="headerlink" title="LaTeX写作软件"></a>LaTeX写作软件</h2><p>LaTeX（LTEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统</p>
<p>1.一款Latex在线编辑器<br><a href="https://www.overleaf.com/">https://www.overleaf.com/</a><br>Latex常用模版<br><a href="https://www.overleaf.com/latex/templates">https://www.overleaf.com/latex/templates</a></p>
<p>2.新一代LaTeX协作平台<br><a href="https://www.slager.cn/#/Home">https://www.slager.cn/#/Home</a></p>
<p>3.TeX Live 是 TUG (TeX User Group) 发布并维护的的 TeX 系统，可以称得上是TeX的官方系统。对于任何阶段的TeX用户，都可以使用TeX Live， 以保持在跨操作系统、跨用户的TeX文件一致性。</p>
<p><a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></p>
<h2 id="关于CTAN"><a href="#关于CTAN" class="headerlink" title="关于CTAN"></a>关于CTAN</h2><p>CTAN是“Comprehensive TeX Archive Network”的首字缩写，为世界上最主要的TeX资源集散网站，搜集了关于TeX的各种文件与软件等等。Perl的资源集散网站CPAN即是基于<em>CTAN</em>的模式诞生与运作。</p>
<p><a href="https://ctan.org/">https://ctan.org/</a></p>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>TeX</tag>
        <tag>LaTeX</tag>
        <tag>KaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX数学表达式</title>
    <url>/article/f107c406.html</url>
    <content><![CDATA[<blockquote>
<p>作为一个作者，在博客中公式的编辑总是难免的。markdown并不支持数学公式编辑，这些公式仅靠编辑器自带的排版功能是难以表示的，所以需要我们掌握网页公式编辑方案。目前比较流行的网页公式编辑方案是采用TEX/LATEX语法编辑，知名的有MathJax、KATEX。</p>
</blockquote>
<a id="more"></a>

<h3 id="关于KaTeX"><a href="#关于KaTeX" class="headerlink" title="关于KaTeX"></a>关于KaTeX</h3><p><a href="https://katex.org/">KaTex</a> - The fastest math typesetting library for the web.</p>
<p>可汗学院出品，号称“最快”的数学公式渲染库，支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8~IE11。</p>
<p>KaTex的优势</p>
<ul>
<li><p>快速：并发渲染，无需重排页面。根据这个测试，性能绝对秒杀MathJax。</p>
</li>
<li><p>渲染效果好：采用TeX语法，渲染效果达到印刷出版级别。</p>
</li>
<li><p>无依赖：不依赖其它库。</p>
</li>
<li><p>支持服务器端渲染：例如，服务器端的Node.js程序调用KaTeX，把渲染好的HTML片段直接发送给客户端。</p>
</li>
</ul>
<p>KaTeX官方文档</p>
<p><a href="https://katex.org/docs/supported.html">Supported Functions · KaTeX</a></p>
<p><a href="https://katex.org/docs/support_table.html">Support Table · KaTeX</a></p>
<p>overleaf数学表达式</p>
<p><a href="https://cn.overleaf.com/learn/latex/Mathematical_expressions">https://cn.overleaf.com/learn/latex/Mathematical_expressions</a></p>
<p>MyScript手绘公式</p>
<p><a href="https://webdemo.myscript.com/">https://webdemo.myscript.com/</a></p>
<p>Tex 科学公式语言 (TeX/LaTeX)示例</p>
<p><a href="https://pandao.github.io/editor.md/examples/katex.html">https://pandao.github.io/editor.md/examples/katex.html</a></p>
<p>LaTeX 数学表达式</p>
<p><a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference</a></p>
<h3 id="LaTeX示例"><a href="#LaTeX示例" class="headerlink" title="LaTeX示例"></a>LaTeX示例</h3><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p>
<p><img src="https://www.zhihu.com/equation?tex=%5CGamma(z)%20=%20%5Cint_0%5E%5Cinfty%20t%5E%7Bz-1%7De%5E%7B-t%7Ddt%5C,." alt="CodeCogsEqn"></p>
<p>渲染LaTeX数学表达式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<h3 id="LaTeX书籍"><a href="#LaTeX书籍" class="headerlink" title="LaTeX书籍"></a>LaTeX书籍</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf">https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf</a></p>
<p><a href="https://www.latex-project.org/help/documentation/amsldoc.pdf">https://www.latex-project.org/help/documentation/amsldoc.pdf</a></p>
<h3 id="LATEX语法"><a href="#LATEX语法" class="headerlink" title="LATEX语法"></a>LATEX语法</h3><p>在LaTeX数学模式中，公式有两种形式——行内公式和行间公式。前者公式嵌入在行内，适用于简单短小的公式；后者居中独占一行，适用于比较长或重要的公式。科学公式 TeX(KaTeX)</p>
<p><strong>行内公式</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ f(x) = a+b $</span><br></pre></td></tr></table></figure>

<p>效果： <img src="https://www.zhihu.com/equation?tex=f(x)+=+a+b" alt="[公式]"></p>
<p><strong>行间公式</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ f(x) = a+b $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=f(x)+=+a+b+" alt="[公式]"></p>
<p><strong>手动编号</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ f(x) = a - b \tag&#123;1.1&#125; $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=f(x)+=+a+-+b+%5Ctag%7B1.1%7D" alt="[公式]"></p>
<p><strong>公式组合</strong></p>
<p>通过cases环境实现公式的组合，&amp;分隔公式和条件，还可以通过\limits来让x→0位于lim的正下方而非默认在lim符号的右下方显示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$D(x) = \begin&#123;cases&#125;</span><br><span class="line">\lim\limits_&#123;x \to 0&#125; \frac&#123;a^x&#125;&#123;b+c&#125;, &amp; x&lt;3 \\</span><br><span class="line">\pi, &amp; x=3 \\</span><br><span class="line">\int_a^&#123;3b&#125;x_&#123;ij&#125;+e^2 \mathrm&#123;d&#125;x,&amp; x&gt;3 \\</span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/equation.svg" alt="[公式]"></p>
<p><strong>拆分单个公式</strong></p>
<p>通过split环境实现公式拆分</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;split&#125;</span><br><span class="line">\cos 2x &amp;= \cos^2x - \sin^2x \\</span><br><span class="line">&amp;=2\cos^2x-1</span><br><span class="line">\end&#123;split&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/equation_split.svg" alt="[公式]"></p>
<p><strong>简单运算</strong></p>
<p>拉丁字母、阿拉伯数字和 +-*/= 运算符均可以直接输入获得，命令\cdot表示乘法的圆点，命令\neq表示不等号，命令\equiv表示恒等于，命令\bmod表示取模</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ x+2-3*4/6=4/y + x\cdot y $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=x+2-3*4/6=4/y+++x%5Ccdot+y" alt="[公式]"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ 0 \neq 1 \quad x \equiv x \quad 1 = 9 \bmod 2 $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=0+%5Cneq+1+%5Cquad+x+%5Cequiv+x+%5Cquad+1+=+9+%5Cbmod+2" alt="[公式]"></p>
<p><strong>上下标</strong></p>
<p>语法_表示下标、^表示上标，但上下标内容不止一个字符时，需用大括号括起来。单引号’表示求导</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ a_&#123;ij&#125;^&#123;2&#125; + b^3_&#123;2&#125;=x^&#123;t&#125; + y&#x27; + x&#x27;&#x27;_&#123;12&#125; $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=a_%7Bij%7D%5E%7B2%7D+++b%5E3_%7B2%7D=x%5E%7Bt%7D+++y%27+++x%27%27_%7B12%7D" alt="[公式]"></p>
<p><strong>根号、分式</strong></p>
<p>命令：\sqrt表示平方根，\sqrt[n]表示n次方根，\frac表示分式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$\sqrt&#123;x&#125; + \sqrt&#123;x^&#123;2&#125;+\sqrt&#123;y&#125;&#125; = \sqrt[3]&#123;k_&#123;i&#125;&#125; - \frac&#123;x&#125;&#123;m&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bx%7D+++%5Csqrt%7Bx%5E%7B2%7D+%5Csqrt%7By%7D%7D+=+%5Csqrt%5B3%5D%7Bk_%7Bi%7D%7D+-+%5Cfrac%7Bx%7D%7Bm%7D" alt="[公式]"></p>
<p><strong>上下标记</strong></p>
<p>命令：\overline, \underline 分别在表达式上、下方画出水平线</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$\overline&#123;x+y&#125; \qquad \underline&#123;a+b&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Coverline%7Bx+y%7D%5Cqquad%5Cunderline%7Ba+b%7D" alt="[公式]"></p>
<p>命令：\overbrace, \underbrace 分别在表达式上、下方给出一个水平的大括号</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$\overbrace&#123;1+2+\cdots+n&#125;^&#123;n个&#125; \qquad \underbrace&#123;a+b+\cdots+z&#125;_&#123;26&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Coverbrace%7B1+2+%5Ccdots+n%7D%5E%7Bn%E4%B8%AA%7D+%5Cqquad+%5Cunderbrace%7Ba+b+%5Ccdots+z%7D_%7B26%7D" alt="[公式]"></p>
<p><strong>向量</strong></p>
<p>命令：\vec表示向量，\overrightarrow表示箭头向右的向量，\overleftarrow表示箭头向左的向量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$\vec&#123;a&#125; + \overrightarrow&#123;AB&#125; + \overleftarrow&#123;DE&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cvec%7Ba%7D+++%5Coverrightarrow%7BAB%7D+++%5Coverleftarrow%7BDE%7D" alt="[公式]"></p>
<p><strong>积分、极限、求和、乘积</strong></p>
<p>命令：\int表示积分，\lim表示极限， \sum表示求和，\prod表示乘积，^、_表示上、下限</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$  \lim_&#123;x \to \infty&#125; x^2_&#123;22&#125; - \int_&#123;1&#125;^&#123;5&#125;x\mathrm&#123;d&#125;x + \sum_&#123;n=1&#125;^&#123;20&#125; n^&#123;2&#125; = \prod_&#123;j=1&#125;^&#123;3&#125; y_&#123;j&#125;  + \lim_&#123;x \to -2&#125; \frac&#123;x-2&#125;&#123;x&#125; $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Cto+%5Cinfty%7D+x%5E2_%7B22%7D+-+%5Cint_%7B1%7D%5E%7B5%7Dx+%5Cmathrm%7Bd%7D+x+++%5Csum_%7Bn=1%7D%5E%7B20%7D+n%5E%7B2%7D+=+%5Cprod_%7Bj=1%7D%5E%7B3%7D+y_%7Bj%7D++++%5Clim_%7Bx+%5Cto+-2%7D+%5Cfrac%7Bx-2%7D%7Bx%7D" alt="[公式]"></p>
<p><strong>三圆点</strong></p>
<p>命令：\ldots点位于基线上，\cdots点设置为居中，\vdots使其垂直，\ddots对角线排列</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ x_&#123;1&#125;,x_&#123;2&#125;,\ldots,x_&#123;5&#125;  \quad x_&#123;1&#125; + x_&#123;2&#125; + \cdots + x_&#123;n&#125; $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=x_%7B1%7D,x_%7B2%7D,%5Cldots,x_%7B5%7D++%5Cquad+x_%7B1%7D+++x_%7B2%7D+++%5Ccdots+++x_%7Bn%7D" alt="[公式]"></p>
<p><strong>重音符号</strong></p>
<p>常用命令如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ \hat&#123;x&#125; $</span><br></pre></td></tr></table></figure>

<p>效果： <img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D" alt="[公式]"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ \bar&#123;x&#125; $</span><br></pre></td></tr></table></figure>

<p>效果： <img src="https://www.zhihu.com/equation?tex=%5Cbar%7Bx%7D" alt="[公式]"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ \tilde&#123;x&#125; $</span><br></pre></td></tr></table></figure>

<p>效果： <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D" alt="[公式]"></p>
<p><strong>矩阵</strong></p>
<p>其采用矩阵环境实现矩阵排列，常用的矩阵环境有matrix、bmatrix、vmatrix、pmatrix，其区别为在于外面的括号不同：</p>
<p><img src="https://pic1.zhimg.com/80/v2-684e48900e810dff360c23b4ffe99680_720w.jpg" alt="img"></p>
<p>下列代码中，&amp;用于分隔列，\用于分隔行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; \cdots \\</span><br><span class="line">67 &amp; 95 &amp; \cdots \\</span><br><span class="line">\vdots  &amp; \vdots &amp; \ddots \\</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/matrix.svg" alt="[公式]"></p>
<p><strong>希腊字母</strong></p>
<p>希腊字母无法直接通过美式键盘输入获得。在LaTeX中通过反斜杠\加上其字母读音实现，将读音首字母大写即可输入其大写形式，详见下表</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ \alpha^&#123;2&#125; + \beta = \Theta  $$</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Calpha%5E%7B2%7D+++%5Cbeta+=+%5CTheta" alt="[公式]"></p>
<p><img src="https://pic1.zhimg.com/80/v2-da3e717cf670582fbfbdddee33073524_720w.jpg" alt="img"></p>
<p><strong>三角函数</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-2527327da18ba3cd4d9cfa9483bcbe1f_720w.jpg" alt="img"></p>
<p><strong>设置颜色</strong></p>
<p>字体颜色：{\color{色调} 表达式}</p>
<p>背景颜色：{\pagecolor{色调} 表达式}</p>
<p>示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\color&#123;red&#125;&#123;\text red&#125;$</span><br><span class="line">$\color&#123;#FF0000&#125;&#123;\text 红色字\;&#125;$</span><br><span class="line">$\color&#123;rgb(255,255,0)&#125;&#123;黄色字\;&#125;$</span><br></pre></td></tr></table></figure>




<blockquote>
<p><a href="https://blog.csdn.net/m0_53793870/article/details/122514409">https://blog.csdn.net/m0_53793870/article/details/122514409</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/110756681">https://zhuanlan.zhihu.com/p/110756681</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/261750408?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/261750408?utm_source=wechat_session</a></p>
<p><a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455">https://blog.csdn.net/mingzhuo_126/article/details/82722455</a></p>
<p><a href="https://blog.csdn.net/PolarisRisingWar/article/details/121333303">https://blog.csdn.net/PolarisRisingWar/article/details/121333303</a></p>
<p><a href="https://blog.csdn.net/u013210620/article/details/81938733">https://blog.csdn.net/u013210620/article/details/81938733</a></p>
<p>LaTeX数学公式 <a href="https://blog.csdn.net/qq_20602929/article/details/50983697">https://blog.csdn.net/qq_20602929/article/details/50983697</a></p>
<p>Markdown 中 LaTex 数学公式命令 <a href="https://www.jianshu.com/p/0ea47ae02262">https://www.jianshu.com/p/0ea47ae02262</a></p>
<p>LaTeX新手入门教程（3）数学公式 <a href="https://www.cnblogs.com/GarfieldEr007/p/5536138.html">https://www.cnblogs.com/GarfieldEr007/p/5536138.html</a></p>
<p>online latex editor <a href="http://latex.codecogs.com/eqneditor/editor.php">http://latex.codecogs.com/eqneditor/editor.php</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术流</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>KaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习模型训练全流程</title>
    <url>/article/79f5c2dd.html</url>
    <content><![CDATA[<blockquote>
<p>机器学习模型训练全流程：数据集、探索性数据分析、数据预处理、数据分割、模型建立、机器学习等。</p>
</blockquote>
<a id="more"></a>

<h1 id="最全的机器学习模型训练全流程"><a href="#最全的机器学习模型训练全流程" class="headerlink" title="最全的机器学习模型训练全流程"></a>最全的机器学习模型训练全流程</h1><h2 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h2><p>发现一个很有趣的<a href="https://so.csdn.net/so/search?q=%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE&spm=1001.2101.3001.7020">开源项目</a>，作者用手绘图的方式讲解了机器学习模型构建的全流程，逻辑清晰、生动形象。想给大家分享一下。<br>项目地址:<a href="https://github.com/dataprofessor/infographic">https://github.com/dataprofessor/infographic</a><br><img src="https://img-blog.csdnimg.cn/img_convert/e948159b0b0628d8fc360aed3f4debaa.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>全文如下：</strong></p>
<p>感觉学习数据科学枯燥无味，那如何能让学习数据科学变得有趣而简单呢？带着这个目标，我开始在iPad上涂鸦建立<a href="https://so.csdn.net/so/search?q=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&spm=1001.2101.3001.7020">机器学习</a>模型所需的流程。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5c1b5e14d98c75c44799dfb8b33238ec.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1. 数据集"></a>1. <a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020">数据集</a></h2><p>数据集是你构建机器学习模型历程中的起点。简单来说，数据集本质上是一个M×N<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a>，其中M代表列（特征），N代表行（样本）。</p>
<p>列可以分解为X和Y，首先，X是几个类似术语的同义词，如特征、独立变量和输入变量。其次，Y也是几个术语的同义词，即类别标签、因变量和输出变量。<br><img src="https://img-blog.csdnimg.cn/img_convert/a589e7727e877b7d740feea5db65fd3d.png#pic_center" alt="在这里插入图片描述"><br>图1. 数据集的卡通插图</p>
<p>应该注意的是，一个可以用于监督学习的数据集（可以执行回归或分类）将同时包含X和Y，而一个可以用于无监督学习的数据集将只有X。</p>
<p>此外，如果Y包含定量值，那么数据集（由X和Y组成）可以用于回归任务，而如果Y包含定性值，那么数据集（由X和Y组成）可以用于分类任务。</p>
<h2 id="2-探索性数据分析（EDA）"><a href="#2-探索性数据分析（EDA）" class="headerlink" title="2. 探索性数据分析（EDA）"></a>2. 探索性数据分析（EDA）</h2><p>进行探索性数据分析（EDA）是为了获得对数据的初步了解。在一个典型的数据科学项目中，我会做的第一件事就是通过执行EDA来 “盯住数据”，以便更好地了解数据。</p>
<p>我通常使用的三大EDA方法包括：</p>
<ul>
<li>描述性统计：平均数、中位数、模式、标准差。</li>
<li>数据可视化：热力图（辨别特征内部相关性）、箱形图（可视化群体差异）、散点图（可视化特征之间的相关性）、主成分分析（可视化数据集中呈现的聚类分布）等。</li>
<li>数据整形：对数据进行透视、分组、过滤等。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ddfd472f1ff1a8eb7669594baaa3c5c3.png#pic_center" alt="在这里插入图片描述"><br>图2. NBA球员统计数据的箱形图示例</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/65c30dba2762c047d4985a673a2c143e.png#pic_center" alt="在这里插入图片描述"><br>图3. NBA球员统计数据的相关热力图示例<br><img src="https://img-blog.csdnimg.cn/img_convert/e9c973782708a005becb0370dfd34529.png#pic_center" alt="在这里插入图片描述"><br>图4. NBA球员统计数据的直方图示例</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e958e7afe50f95c4e3d7a8bd6c3ccb63.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3. 数据预处理"></a>3. 数据预处理</h2><p><strong>数据预处理(又称数据清理、数据整理或数据处理)是指对数据进行各种检查和审查的过程，以纠正缺失值、拼写错误、使数值正常化/标准化以使其具有可比性、转换数据(如对数转换)等问题。</strong></p>
<p>“Garbage in, Garbage out.”</p>
<p>正如上面的引言所说，数据的质量将对生成模型的质量产生很大的影响。因此，为了达到最高的模型质量，应该在数据预处理阶段花费大量精力。一般来说，数据预处理可以轻松地占到数据科学项目所花费时间的80%，而实际的模型建立阶段和后续的模型分析仅占到剩余的20%。</p>
<h2 id="4-数据分割"><a href="#4-数据分割" class="headerlink" title="4. 数据分割"></a>4. 数据分割</h2><h3 id="4-1-训练–测试集分割"><a href="#4-1-训练–测试集分割" class="headerlink" title="4.1 训练–测试集分割"></a>4.1 训练–测试集分割</h3><p>在机器学习模型的开发过程中，希望训练好的模型能在新的、未见过的数据上表现良好。为了模拟新的、未见过的数据，对可用数据进行数据分割，从而将其分割成2部分（有时称为训练—测试分割）。特别是，第一部分是较大的数据子集，用作<a href="https://so.csdn.net/so/search?q=%E8%AE%AD%E7%BB%83%E9%9B%86&spm=1001.2101.3001.7020">训练集</a>（如占原始数据的80%），第二部分通常是较小的子集，用作测试集（其余20%的数据）。需要注意的是，这种数据拆分只进行一次。</p>
<p>接下来，利用训练集建立预测模型，然后将这种训练好的模型应用于测试集（即作为新的、未见过的数据）上进行预测。根据模型在测试集上的表现来选择最佳模型，为了获得最佳模型，还可以进行超参数优化。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/04bda3d58fd0d7d3f00f09633a7346e0.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-2-训练–验证–测试集分割"><a href="#4-2-训练–验证–测试集分割" class="headerlink" title="4.2 训练–验证–测试集分割"></a>4.2 训练–验证–测试集分割</h3><p>另一种常见的数据分割方法是将数据分割成3部分。(1) 训练集，(2) 验证集和(3) 测试集。与上面解释的类似，训练集用于建立预测模型，同时对验证集进行评估，据此进行预测，可以进行模型调优（如超参数优化），并根据验证集的结果选择性能最好的模型。正如我们所看到的，类似于上面对测试集进行的操作，这里我们在验证集上做同样的操作。请注意，测试集不参与任何模型的建立和准备。因此，测试集可以真正充当新的、未知的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4474821915c1010ba44add1073e8958e.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-3-交叉验证"><a href="#4-3-交叉验证" class="headerlink" title="4.3 交叉验证"></a>4.3 交叉验证</h3><p>为了最经济地利用现有数据，通常使用N倍交叉验证（CV），将数据集分割成N个折（即通常使用5倍或10倍CV）。在这样的N倍CV中，其中一个折被留作测试数据，而其余的折则被用作建立模型的训练数据。</p>
<p>例如，在5倍CV中，有1个折被省略，作为测试数据，而剩下的4个被集中起来，作为建立模型的训练数据。然后，将训练好的模型应用于上述遗漏的折（即测试数据）。这个过程反复进行，直到所有的折都有机会被留出作为测试数据。因此，我们将建立5个模型（即5个折中的每个折都被留出作为测试集），其中5个模型中的每个模型都包含相关的性能指标（我们将在接下来的部分讨论）。最后，度量（指标）值是基于5个模型计算出的平均性能。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9d45766ab73071d61345e172de34f30c.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-模型建立"><a href="#5-模型建立" class="headerlink" title="5. 模型建立"></a>5. 模型建立</h2><p><strong>现在，有趣的部分来了，我们终于可以使用精心准备的数据来建立模型了。根据目标变量（通常称为Y变量）的数据类型（定性或定量），我们要建立一个分类（如果Y是定性的）或回归（如果Y是定量的）模型。</strong></p>
<h3 id="5-1-学习算法"><a href="#5-1-学习算法" class="headerlink" title="5.1 学习算法"></a>5.1 学习算法</h3><p>机器学习算法可以大致分为以下三种类型之一：</p>
<ul>
<li>监督学习：是一种机器学习任务，建立输入X和输出Y变量之间的数学（映射）关系。这样的X、Y对构成了用于建立模型的标签数据，以便学习如何从输入中预测输出。</li>
<li>无监督学习：是一种只利用输入X变量的机器学习任务。这种 X 变量是未标记的数据，学习算法在建模时使用的是数据的固有结构。</li>
<li>强化学习：是一种决定下一步行动方案的机器学习任务，它通过试错学习来实现这一目标，努力使回报最大化。</li>
</ul>
<h3 id="5-2-参数调优"><a href="#5-2-参数调优" class="headerlink" title="5.2 参数调优"></a>5.2 参数调优</h3><p>超参数本质上是机器学习算法的参数，直接影响学习过程和预测性能。由于没有“一刀切 ”的超参数设置，可以普遍适用于所有数据集，因此需要进行超参数优化（也称为超参数调整或模型调整）。</p>
<p>我们以随机森林为例。在使用randomForest R包时，通常会对两个常见的超参数进行优化，其中包括mtry和ntree参数（这对应于scikit-learnPython库中RandomForestClassifier()和RandomForestRegressor()函数中的nestimators和maxfeatures）。mtry（maxfeatures）代表在每次分裂时作为候选变量随机采样的变量数量，而ntree（nestimators）代表要生长的树的数量。</p>
<p>另一种流行的机器学习算法是支持向量机。需要优化的超参数是径向基函数(RBF)内核的C参数和gamma参数(即线性内核只有C参数；多项式内核的C和指数)。C参数是一个限制过拟合的惩罚项，而gamma参数则控制RBF核的宽度。如上所述，调优通常是为了得出超参数的最佳值集，尽管如此，也有一些研究旨在为C参数和gamma参数找到良好的起始值（Alvarsson等人，2014）。</p>
<p>地址：<a href="https://pubs.acs.org/doi/10.1021/ci500344v">https://pubs.acs.org/doi/10.1021/ci500344v</a></p>
<h3 id="5-3-特征选择"><a href="#5-3-特征选择" class="headerlink" title="5.3 特征选择"></a>5.3 特征选择</h3><p>顾名思义，特征选择从字面上看就是从最初的大量特征中选择一个特征子集的过程。除了实现高精度的模型外，机器学习模型构建最重要的一个方面是获得可操作的见解，为了实现这一目标，能够从大量的特征中选择出重要的特征子集非常重要。</p>
<p>特征选择的任务本身就可以构成一个全新的研究领域，在这个领域中，大量的努力都是为了设计新颖的算法和方法。从众多可用的特征选择算法中，一些经典的方法是基于模拟退火和遗传算法。除此之外，还有大量基于进化算法（如粒子群优化、蚁群优化等）和随机方法（如蒙特卡洛）的方法。</p>
<p>我们自己的研究小组也在对醛糖还原酶抑制剂的定量结构—活性关系建模的研究中，探索了利用蒙特卡洛模拟进行特征选择的方法（Nantasenamat等，2014）。<br>地址:<a href="https://doi.org/10.1016/j.ejmech.2014.02.043">https://doi.org/10.1016/j.ejmech.2014.02.043</a></p>
<p>在《遗传算法搜索空间拼接粒子群优化作为通用优化器》的工作中，我们还设计了一种基于结合两种流行的进化算法即遗传算法和粒子群算法的新型特征选择方法（Li等，2013）。<br>地址:<a href="https://doi.org/10.1016/j.chemolab.2013.08.009">https://doi.org/10.1016/j.chemolab.2013.08.009</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/449a0ace0442abe9607dc0606af605f5.png#pic_center" alt="在这里插入图片描述"><br>“原搜索空间（a）x∈[-500,0]在每个维度上以2的固定间隔拼接成子空间（图中一个维度等于一个横轴）。这样就得到了4个子空间(b-e)，其中x在每个维度上的范围是原始空间的一半。GA的每一个字符串都会编码一个子空间的索引。然后，GA启发式地选择一个子空间（e），并在那里启动PSO（粒子显示为红点）。PSO搜索子空间的全局最小值，最好的粒子适应性作为编码该子空间索引的GA字符串的适应性。最后，GA进行进化，选择一个新的子空间进行探索。整个过程重复进行，直到达到满意的误差水平。”</p>
<h2 id="6-机器学习任务"><a href="#6-机器学习任务" class="headerlink" title="6. 机器学习任务"></a>6. 机器学习任务</h2><p>在监督学习中，两个常见的机器学习任务包括分类和回归。</p>
<h3 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1 分类"></a>6.1 分类</h3><p>一个训练有素的分类模型将一组变量（定量或定性）作为输入，并预测输出的类标签（定性）。下图是由不同颜色和标签表示的三个类。每一个小的彩色球体代表一个数据样本。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b86af8d3630d8333f23889528ac01e08.png#pic_center" alt="在这里插入图片描述"><br>三类数据样本在二维中的显示。上图显示的是数据样本的假设分布。这种可视化图可以通过执行PCA分析并显示前两个主成分（PC）来创建；或者也可以选择两个变量的简单散点图可视化。</p>
<h3 id="6-1-1-样例数据集"><a href="#6-1-1-样例数据集" class="headerlink" title="6.1.1 样例数据集"></a>6.1.1 样例数据集</h3><p>以企鹅数据集（Penguins Dataset）为例（最近提出作为大量使用的Iris数据集的替代数据集），我们将定量（喙长、喙深、鳍长和身体质量）和定性（性别和岛屿）特征作为输入，这些特征唯一地描述了企鹅的特征，并将其归入三个物种类别标签（Adelie、Chinstrap或Gentoo）之一。该数据集由344行和8列组成。之前的分析显示，该数据集包含333个完整的案例，其中11个不完整的案例中出现了19个缺失值。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/860d0e764e0f77e362475954ee0da385.png#pic_center" alt="在这里插入图片描述"><br>图11. 三个企鹅物种的类别标签（Chinstrap、Gentoo和Adelie）</p>
<h3 id="6-1-2-性能指标"><a href="#6-1-2-性能指标" class="headerlink" title="6.1.2 性能指标"></a>6.1.2 性能指标</h3><p>如何知道我们的模型表现好或坏？答案是使用性能指标，一些常见的评估分类性能的指标包括准确率（Ac）、灵敏度（Sn）、特异性（Sp）和马太相关系数（MCC）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/65a6e7a9abd0ad17684d658ce3bf9947.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/6762a6c4d3d907dcdf5309a77524b978.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/6c2a7c02317fc05cf955facdf882b198.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/0c9e925c8977f0b0be0a3927dfede2f0.png#pic_center" alt="在这里插入图片描述"><br>其中TP、TN、FP和FN分别表示真阳性、真阴性、假阳性和假阴性的实例。应该注意的是，MCC的范围从-1到1，其中MCC为-1表示最坏的可能预测，而值为1表示最好的可能预测方案。此外，MCC为0表示随机预测。</p>
<h3 id="6-2-回归"><a href="#6-2-回归" class="headerlink" title="6.2 回归"></a>6.2 回归</h3><p>简而言之，可以通过以下简单等式很好地总结训练有素的回归模型：Y = f(X)。其中，Y对应量化输出变量，X指输入变量，f指计算输出值作为输入特征的映射函数（从训练模型中得到）。上面的回归例子公式的实质是，如果X已知，就可以推导出Y。一旦Y被计算出来（我们也可以说是 “预测”），一个流行的可视化方式是将实际值与预测值做一个简单的散点图，如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4a21012b42cf9b29d304155a45d80cd6.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="6-2-1-样例数据集"><a href="#6-2-1-样例数据集" class="headerlink" title="6.2.1 样例数据集"></a>6.2.1 样例数据集</h3><p>波士顿住房数据集（Boston Housing Dataset）是数据科学教程中通常使用的一个热门示例数据集。该数据集由506行和14列组成。为了简洁起见，下面显示的是标题（显示变量名称）加上数据集的前4行。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9fc1a37a13b5da7d994d4c261ebef46a.png#pic_center" alt="在这里插入图片描述"><br>在14列中，前13个变量被用作输入变量，而房价中位数（medv）被用作输出变量。可以看出，所有14个变量都包含了量化的数值，因此适合进行回归分析。我还在YouTube上做了一个逐步演示如何用Python建立线性回归模型的视频。</p>
<h3 id="6-2-2-性能指标"><a href="#6-2-2-性能指标" class="headerlink" title="6.2.2 性能指标"></a>6.2.2 性能指标</h3><p>对回归模型的性能进行评估，以评估拟合模型可以准确预测输入数据值的程度。评估回归模型性能的常用指标是确定系数（R²）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a34a65112e4f0dca7ef992786e14265e.png#pic_center" alt="在这里插入图片描述"><br>从公式中可以看出，R²实质上是1减去残差平方和（SSres）与总平方和（SStot）的比值。简单来说，可以说它代表了解释方差的相对量度。例如，如果R²=0.6，那么意味着该模型可以解释60%的方差（即60%的数据符合回归模型），而未解释的方差占剩余的40%。</p>
<p>此外，均方误差（MSE）以及均方根误差（RMSE）也是衡量残差或预测误差的常用指标。<br><img src="https://img-blog.csdnimg.cn/img_convert/bc761eccbf90c66b89b1929b6e5d2577.png#pic_center" alt="在这里插入图片描述"><br>从上面的公式可以看出，MSE顾名思义是很容易计算的，取平方误差的平均值。此外，MSE的简单平方根可以得到RMSE。</p>
<h2 id="7-分类任务的直观说明"><a href="#7-分类任务的直观说明" class="headerlink" title="7. 分类任务的直观说明"></a>7. 分类任务的直观说明</h2><p><strong>现在我们再来看看分类模型的整个过程。以企鹅数据集为例，我们可以看到，企鹅可以通过4个定量特征和2个定性特征来描述，然后将这些特征作为训练分类模型的输入。在训练模型的过程中，需要考虑的问题包括以下几点。</strong></p>
<ul>
<li>使用什么机器学习算法？</li>
<li>应该探索什么样的搜索空间进行超参数优化？</li>
<li>使用哪种数据分割方案？80/20分割还是60/20/20分割？还是10倍CV？</li>
</ul>
<p>一旦模型被训练，得到的模型就可以用来对类别标签（即在我们的案例中企鹅种类）进行预测，可以是三种企鹅种类中的一种：Adelie、Chinstrap或Gentoo。</p>
<p>除了只进行分类建模，我们还可以进行主成分分析（PCA），这将只利用X（独立）变量来辨别数据的底层结构，并在这样做的过程中允许将固有的数据簇可视化（如下图所示为一个假设图，其中簇根据3种企鹅物种进行了颜色编码）。<br><img src="https://img-blog.csdnimg.cn/img_convert/2fa98b5e4ee108504a45b90014629681.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 align="center">Hi 👋, I'm Fang Jian</h1>
<h3 align="center">A passionate developer from China</h3>

<ul>
<li>🔭 I’m currently working on <a href="https://github.com/fangjian98/ExploreGithub">ExploreGithub</a></li>
<li>🌱 I’m currently learning <strong>Android, AOSP, SpringBoot, Ant Design, ML, NLP</strong></li>
<li>👯 I’m looking to collaborate on <strong>Alibaba, Tencent</strong></li>
<li>🤔 I’m looking for help with <strong>ML, AOSP</strong></li>
<li>👨‍💻 All of my projects are available at <a href="https://github.com/fangjian98">GitHub</a></li>
<li>📝 I regulary write articles on <a href="https://blog.csdn.net/weixin_44008788">CSDN</a></li>
<li>💬 Ask me about <strong>Android, Python, Linux</strong></li>
<li>📫 How to reach me <strong><a href="mailto:&#x66;&#97;&#110;&#103;&#x6a;&#105;&#97;&#x6e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;">&#x66;&#97;&#110;&#103;&#x6a;&#105;&#97;&#x6e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a></strong></li>
<li>:books: Motto:What does not kill me,makes me stronger.(任何不能杀死你的，都会使你更强大)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>网站导航</title>
    <url>/navigation/index.html</url>
    <content><![CDATA[<h2 id="设计导航"><a href="#设计导航" class="headerlink" title="设计导航"></a>设计导航</h2><p><strong>美叶</strong> - <a href="https://www.meiye.art/">meiye.art</a></p>
<blockquote>
<p>让灵感获取变轻松。</p>
</blockquote>
<p><strong>奇迹秀</strong> - <a href="https://www.qijishow.com/">qijishow.com</a></p>
<blockquote>
<p>奇迹秀是集设计分享、设计交流的互动设计产业个人合作平台，以设计、营销、品牌建设为主要研究发展方向，同时也是设计师罗忠林的个人网站，相信奇迹，相信自己。</p>
</blockquote>
<p><strong>设优SheUI</strong> - <a href="https://www.sheui.net/">sheui.net</a></p>
<blockquote>
<p>设计优选 为你挑剔。设优在全球优选好设计，无论你使用什么设计软件或素材都能找到合适的资源，且都是经过测试稳定发布的，助飞创意。我们致力于优选高品质创意内容和设计资源。</p>
</blockquote>
<p><strong>Dribble</strong> - <a href="https://dribbble.com/">dribbble.com</a></p>
<blockquote>
<p>全球UI设计师作品分享平台。</p>
</blockquote>
<p><strong>BeHance</strong> - <a href="https://behance.net/">behance.net</a></p>
<blockquote>
<p>Adobe旗下的设计师交流平台，来自世界各地的设计师在这里分享自己的作品。</p>
</blockquote>
<h2 id="素材资源"><a href="#素材资源" class="headerlink" title="素材资源"></a>素材资源</h2><p><strong>Pexels</strong> - <a href="https://www.pexels.com/zh-cn/">pexels.com</a></p>
<blockquote>
<p>Pexels 提供高质量且完全免费的素材图片，这些图片均在 Pexels 许可下授权。我们精心地为所有图片贴上了标签，你可以搜索，也可以轻松通过我们的发现页面发现这些图片。我们帮助数百万位设计师、作家、艺术家、程序员和其他创作者获得他们可以免费使用的唯美图片，使他们能够创造令人惊叹的产品、设计、故事、网站、应用、艺术和其他作品。我们称之为：“创作天地，尽情挥洒”</p>
</blockquote>
<p><strong>Unsplash</strong> - <a href="https://unsplash.com/">unsplash.com</a></p>
<blockquote>
<p>适合所有人的照片，世界上最慷慨的摄影师社区为您带来了超过 300 万张免费的高分辨率图像。Unsplash 是互联网上可免费使用的图像的来源。Unsplash 诞生于我们在寻找伟大的、可用的图像时所经历的痛苦。我们并不孤单。这就是为什么今天来自世界各地的数百万创作者已经下载了超过 40 亿张 Unsplash 图像来创建演示文稿、艺术品、模型等。</p>
</blockquote>
<p><strong>Pixabay</strong> - <a href="https://pixabay.com/zh/">pixabay.com</a></p>
<blockquote>
<p>Pixabay是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清图片素材,涵盖照片、插画、矢量图、视频等分类,你可以在任何地方使用Pixabay图库中的素材,无惧版权风险。</p>
</blockquote>
<p><strong>Streamline</strong> - <a href="https://www.streamlinehq.com/">streamlinehq.com</a></p>
<blockquote>
<p>在几秒钟内个性化世界上最大、最一致的插图集。提供平面、手绘、漫画和更多样式。Streamline主要是插画素材，内置超过10万个素材可免费使用。</p>
</blockquote>
<p><strong>LottieFiles</strong> - <a href="https://lottiefiles.com/">lottiefiles.com</a></p>
<blockquote>
<p>免费的 Lottie 动画文件、工具和插件</p>
</blockquote>
<p><strong>IsoFlat</strong> - <a href="https://isoflat.com/">isoflat.com</a></p>
<blockquote>
<p>IsoFlat 的使命是为设计师提供很棒的免费矢量和图形资源：各种免费矢量集合、photoshop 插图、图标和图标包、背景和很棒的字体。</p>
</blockquote>
<p><strong>StorySet</strong> - <a href="https://storyset.com/">storyset.com</a></p>
<blockquote>
<p>StorySet是一个提供免费插画的网站，你可以按照标签，颜色进行插图筛选，将合适的插图用于你的项目之中。你还可以对插图进行简单的自定义，改变颜色，隐藏不想要的内容，插图支持png格式和svg格式进行保存。</p>
</blockquote>
<p><strong>花瓣网</strong> - <a href="https://huaban.com/">huaban.com</a></p>
<blockquote>
<p>超过40亿灵感等你来发现，陪你做生活的设计师</p>
</blockquote>
<p><strong>Microsoft Design Wallpapers</strong> - <a href="https://wallpapers.microsoft.design/">wallpapers.microsoft.design</a></p>
<blockquote>
<p>Microsoft Design Wallpapers，这个网站包含了微软旗下产品设计的创意图和壁纸。收录图片超过60张，都是4K分辨率。微软还有一款 <a href="https://bing.ioliu.cn/">必应壁纸</a>，里面有好多高清好看的壁纸。</p>
</blockquote>
<h2 id="开源平台"><a href="#开源平台" class="headerlink" title="开源平台"></a>开源平台</h2><p><strong>Github</strong> - <a href="https://github.com/">github.com</a></p>
<blockquote>
<p>GitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。</p>
</blockquote>
<p><strong>Gitee</strong> - <a href="https://gitee.com/">gitee.com</a></p>
<blockquote>
<p>Gitee是开源中国（OSChina）推出的基于Git的代码托管服务。Gitee包括三个版本，分别是：社区版、企业版和高校版。</p>
</blockquote>
<h2 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h2><p><strong>LeetCode</strong> - <a href="https://leetcode.cn/">leetcode.cn</a></p>
<blockquote>
<p>力扣（LeetCode）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌。源自美国硅谷，力扣为全球程序员提供了专业的IT技术职业化提升平台，有效帮助程序员实现快速进步和长期成长。</p>
</blockquote>
<p><strong>LintCode</strong> - <a href="https://www.lintcode.com/">lintcode.com</a></p>
<blockquote>
<p>LintCode是一个集合了大量算法面试题和AI面试题的网站，它为全世界的码农提供了练习自我技能的良好平台。</p>
</blockquote>
<p><strong>FreeCodeCamp</strong> - <a href="https://www.freecodecamp.org/">freecodecamp.org</a></p>
<blockquote>
<p>我们是一个非营利社区，通过构建项目来帮助您学习编码。您将通过完成编码挑战和构建项目来学习编码。在此过程中，您还将获得认证。</p>
</blockquote>
<h2 id="电子书下载"><a href="#电子书下载" class="headerlink" title="电子书下载"></a>电子书下载</h2><p><strong>Z-Library</strong> - <a href="https://z-lib.org/">z-lib.org</a></p>
<blockquote>
<p>Z-Library 项目的一部分. 全球最大的数字图书馆。主站访问缓慢，可以使用其他地址：<br><a href="https://zh.z-lib.org/">https://zh.z-lib.org/</a><br><a href="https://zh.booksc.org/">https://zh.booksc.org/</a><br><a href="https://zh.b-ok.cc/">https://zh.b-ok.cc/</a></p>
</blockquote>
<p><strong>LoreFree</strong> - <a href="https://lorefree.com/">lorefree.com</a></p>
<blockquote>
<p>首个基于EOS和IPFS的去中心化知识共享社区</p>
</blockquote>
<p><strong>MagazineLib</strong> - <a href="https://magazinelib.com/">magazinelib.com</a></p>
<blockquote>
<p>MagazineLib是一个非常强大的外刊资源网站，对于想要阅读如<em>The Economist</em>、<em>The New Yorker</em>等主流英语外刊的童鞋来说简直是大福利。无需注册，无需扫码，无需关注，只需进入网站即可免费下载这些外刊的PDF版本。网站还很贴心地在顶部设置了标题栏分类，如Animals、Art、Business、Fashion、Health、Science等，点击对应的分类就会出现相关的杂志，再也不用费心去想要读什么啦。</p>
</blockquote>
<p><strong>书栈网</strong> - <a href="https://www.bookstack.cn/">bookstack.cn</a></p>
<blockquote>
<p>书栈网，BookStack，既是一个开源书籍和文档分享站点，也是一套使用Go语言开发的开源程序，助您更好地实现文档阅读管理。</p>
</blockquote>
<h2 id="互联网运营"><a href="#互联网运营" class="headerlink" title="互联网运营"></a>互联网运营</h2><p><strong>媒帮派导航</strong> - <a href="http://123.meibp.com/">123.meibp.com</a></p>
<blockquote>
<p>优秀新媒体工具大全。</p>
</blockquote>
<p><strong>考拉新媒体导航</strong> - <a href="https://www.kaolamedia.com/">kaolamedia.com</a></p>
<blockquote>
<p>考拉新媒体导航上线了。里面罗列了上百款工具和新媒体人必备的技法，且都是完全免费的。作为一个老鸟，如果再被新人问相关问题，你无需再列一堆东西出来，而只需要告诉他：去「考拉新媒体导航」吧，你要的答案里面都有。这个网站是完全公益化的，我们希望它未来能够成为新媒体人每天打开的第一个网站。</p>
</blockquote>
<p><strong>人人都是产品经理</strong> - <a href="http://www.woshipm.com/">woshipm.com</a></p>
<blockquote>
<p>人人都是产品经理是以产品经理、运营为核心的学习、交流、分享平台，集媒体、培训、社群为一体，全方位服务产品人和运营人，成立11年举办在线讲座1000+期，线下分享会500+场，产品经理大会、运营大会50+场，覆盖北上广深杭成都等20个城市，在行业有较高的影响力和知名度。平台聚集了众多BAT美团京东滴滴360小米网易等知名互联网公司产品总监和运营总监，他们在这里与你一起成长。</p>
</blockquote>
<h2 id="编程导航"><a href="#编程导航" class="headerlink" title="编程导航"></a>编程导航</h2><p><strong>W3School</strong> - <a href="https://www.w3school.com.cn/">w3school.com.cn</a></p>
<blockquote>
<p>W3School 是因特网上最大的 WEB 开发者资源，其中包括全面的教程、完善的参考手册以及庞大的代码库。</p>
</blockquote>
<p><strong>菜鸟教程</strong> - <a href="https://www.runoob.com/">runoob.com</a></p>
<blockquote>
<p>菜鸟教程提供了基础编程技术教程。菜鸟教程的 Slogan 为：学的不仅是技术，更是梦想！资源海量，覆盖了编程路上的方方面面。</p>
</blockquote>
<h2 id="导航网站"><a href="#导航网站" class="headerlink" title="导航网站"></a>导航网站</h2><p><strong>CoderUtil程序员盒子</strong> - <a href="https://www.coderutil.com/">coderutil.com</a></p>
<blockquote>
<p>专注于程序员工作、学习、编程提效。</p>
</blockquote>
<p><strong>编程导航</strong> - <a href="https://www.code-nav.cn/">code-nav.cn</a></p>
<blockquote>
<p>提供人人皆可推荐的编程资源导航平台，帮助大家发现优质编程资源，是一个“可搜索”、“可复用”、“可量化” 、“可定制” 的资源系统。</p>
</blockquote>
<p><strong>工具猫</strong> - <a href="https://www.toolmao.com/">toolmao.com</a></p>
<blockquote>
<p>工具猫创建于2009年9月份，一直致力于为网友提供免费实用的小工具，从一开始的纯工具打包发布，到现在以更加方便的插件形式发布，我们一步步成长，期间坎坷不断，很幸运我们坚持到了现在，也很感谢一直关注着工具猫的朋友！</p>
</blockquote>
<p><strong>资源猫</strong> - <a href="https://www.ziyuanm.com/">ziyuanm.com</a></p>
<blockquote>
<p>资源猫网址导航是国内网民查找精品资源的首选平台。网站汇集了大量精品资源网站，涵盖新闻、视频、音乐、学习、社交、博客、设计、动漫等多方面的精品资源网站，切实为网民打造一个最全面、最实用、最人性化的资源网站大全。</p>
</blockquote>
<p><strong>AboutPPT导航</strong> - <a href="https://www.aboutppt.com/">aboutppt.com</a></p>
<blockquote>
<p>AboutPPT 导航，专注于 PPT 设计教程与网站神器分享，收录了高质量且系统的 PPT 学习文章与教程。</p>
</blockquote>
<p><strong>果酱云</strong> - <a href="https://www.bcnav.cn/">bcnav.cn</a></p>
<blockquote>
<p>程序员资源网址导航。</p>
</blockquote>
<p><strong>程序员网址导航</strong> - <a href="https://nav.vpssw.com/">nav.vpssw.com</a></p>
<blockquote>
<p> 程序员必备实用网址导航</p>
</blockquote>
<h2 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h2><p><strong>wikiHow</strong> - <a href="https://zh.wikihow.com/%E9%A6%96%E9%A1%B5">zh.wikihow.com</a></p>
<blockquote>
<p>wikiHow是一个吸引了成千上万人参与的全球协作平台，大家都怀着一个共同的目标：教这个世界上的任何人学会做任何事情。你在WikiHow上读到的每一篇文章都是热心帮助别人的作者撰写的。<br>为什么要首先选择WikiHow？因为我们用心为你提供互联网上最有用的万事指南。网络上到处充斥着由某些作者一手粗制滥造的文章。相比之下，“wikiHow的文章平均会被23个人编辑，并经过16个人的评审”。</p>
</blockquote>
<p><strong>uTools</strong> - <a href="https://www.u.tools/">u.tools</a></p>
<blockquote>
<p>新一代效率工具平台，自由组合插件应用，打造专属你的趁手工具集。</p>
</blockquote>
<p><strong>DevToys</strong>  - <a href="https://devtoys.app/">devtoys.app</a></p>
<blockquote>
<p>DevToys ——开发人员的瑞士军刀。DevToys 有助于完成日常任务，例如格式化 JSON、比较文本、测试 RegExp。无需使用许多不真实的网站来处理您的数据的简单任务。借助智能检测，DevToys 能够检测出可以处理您在 Windows 剪贴板中复制的数据的最佳工具。紧凑的覆盖可让您将应用程序保持在较小的位置并位于其他窗口的顶部。可以一次使用应用程序的多个实例。</p>
</blockquote>
<p><strong>Grammarly</strong> - <a href="https://www.grammarly.com/">grammarly.com</a></p>
<blockquote>
<p>Grammarly是一款在线语法纠正和校对工具，它能帮助作者纠正语法错误,检查单词拼写,标点符号,调整语气以及给出风格建议等,对学术写作来说，Grammarly还可以帮助查重。</p>
</blockquote>
<p><strong>Academic Phrasebank</strong> - <a href="http://www.phrasebank.manchester.ac.uk/introducing-work/">phrasebank.manchester.ac.uk</a></p>
<blockquote>
<p>Academic Phrasebank是一个专门针对学术论文写作的词句模板库。它汇集了万千英文母语者的学术文章，并归纳总结了在文章不同位置、不同功用的学术写作短语和句型的用法和例句。帮助你快速学习如何写绪论、如何表达自己观点、如何评价他人、如何进行总结。Academic Phrasebank 特别适合SCI写作能力较弱的科研人员，因为其收集了大量的写作模版。对于SCI论文的几个重要组成部分(前言、方法描述、结果报道、讨论和结论等)，Academic Phrasebank都有对应的模板供用户参考。</p>
</blockquote>
<p><strong>CodePen</strong> - <a href="https://codepen.io/">codepen.io</a></p>
<blockquote>
<p>CodePen（代码笔）一款前端所见即所得的工具，我们可以在线编辑制作前端页面，所见即所得。同时网站提供所有常见的 js、css 库，并且支持流行技术（如 SASS），免去了我们自建平台的麻烦。有时我们需要调试一些前端代码（无论是 html、css，还是 js），或者要制作一个 demo 分享给他人。这些都可以借助 CodePen 这个网站来实现。</p>
</blockquote>
<p> <strong>Codelf</strong> - <a href="https://unbug.github.io/codelf/">unbug.github.io/codelf</a></p>
<blockquote>
<p>开发过程中很头疼的事情就是给变量或函数命名，Codelf 就是一个变量命名网站 。Codelf 是通过搜索在线开源平台Github, Bitbucket, Google Code, Codeplex, Sourceforge, Fedora Projec的项目源码，帮开发者从中找出已有的匹配关键字的变量名。它支持中文查询，可以根据需要查询尽可能满足我们所需要的结果，并展示与查询结果相关的支持各种编程语言的代码片段以及代码库。</p>
</blockquote>
<p><strong>虫部落</strong> - <a href="https://www.chongbuluo.com/">chongbuluo.com</a></p>
<blockquote>
<p>虫部落是一个纯粹的搜索知识、技术和经验分享平台,虫部落快搜、虫部落学术搜索等搜索聚合工具均为虫部落原创出品,搜索世界的乐趣,就在虫部落!</p>
</blockquote>
<p><strong>Similarsites</strong> - <a href="https://www.similarsites.com/">similarsites.com</a></p>
<blockquote>
<p>触类旁通Similarsites一个快速寻找类似网站的神器。SimilarSites是一个创新的推荐引擎，可以搜索互联网，为您提供更多您喜欢的内容。SimilarSites根据相关内容、Web结构、链接分析算法、详细的用户冲浪行为和庞大的用户排名社区，找到与您浏览的网站类似的网站，从而消除网络的混乱。</p>
</blockquote>
<h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><p><strong>Wormhole</strong> - <a href="https://wormhole.app/">wormhole.app</a></p>
<blockquote>
<p>简单，私密的文件分享。Wormhole 让你能以端到端加密和自动过期链接的方式分享文件。 所以你可以确保你分享的文件私密且不会一直留在互联网上。 对于5GB以内的文件，Wormhole将在服务器上存储24小时。<br>对于大于5GB的文件，Wormhole使用点对点传输,直接从你的浏览器向接收者发送文件。所以你需要保持页面打开直到接收者下载完毕。与其他大多数网盘或文件分享服务不同，你可以立刻复制链接并发送给好友，无需等待上传结束。Wormhole 将此称为 “即时文件流”（instant file streaming）。</p>
</blockquote>
<p><strong>轻松传</strong> - <a href="https://easychuan.cn/">easychuan.cn</a></p>
<blockquote>
<p>轻松传在线传送文件、文本、屏幕和视频，随收随发，局域网互传首选。</p>
</blockquote>
<p><strong>OSCHINA工具</strong> - <a href="https://tool.oschina.net/">tool.oschina.net</a></p>
<blockquote>
<p>由开源中国提供的在线工具集合，常用开发手册、对照表、代码处理、加密/格式化工具、正则等其他实用工具。</p>
</blockquote>
<p><strong>All To All</strong> - <a href="https://www.alltoall.net/">alltoall.net</a></p>
<blockquote>
<p>国内最全类型的在线文件转换平台，免费、快速，无须下载安装任何软件，致力于提供免费并且好用的在线转换服务。</p>
</blockquote>
<p><strong>ToolFK</strong> - <a href="https://www.toolfk.com/">toolfk.com</a></p>
<blockquote>
<p>最强工具人在线工具箱。</p>
</blockquote>
<p><strong>爱资料工具</strong> - <a href="https://www.toolnb.com/">toolnb.com</a></p>
<blockquote>
<p>提供开发上的便捷工具。</p>
</blockquote>
<p><strong>小霸王</strong> - <a href="https://www.yikm.net/">yikm.net</a></p>
<blockquote>
<p>小霸王，其乐无穷 。红白机，FC在线游戏，街机游戏，街机在线，NES games，NES games online，Super Mario。一个可以在线玩红白机的网站。</p>
</blockquote>
<p><strong>RemoveBg</strong> - <a href="https://www.remove.bg/zh">remove.bg</a></p>
<blockquote>
<p>在线抠图软件，图片去除背景图片，轻点一下，即可在5秒钟内100%自动去除背景，100% 全自动且免费。</p>
</blockquote>
<p><strong>Magic Eraser</strong> - <a href="https://www.magiceraser.io/">magiceraser.io</a></p>
<blockquote>
<p>瞬间删除图像中不需要的部分上传图像，标记您需要删除的部分，下载修改后的图像。</p>
</blockquote>
<p><strong>Bigjpg</strong> - <a href="https://bigjpg.com/">bigjpg.com</a></p>
<blockquote>
<p>AI人工智能图片放大</p>
</blockquote>
<p><strong>iLoveIMG</strong> - <a href="https://www.iloveimg.com/zh-cn">iloveimg.com</a></p>
<blockquote>
<p>为了简化图片的在线编辑推出的iLoveIMG。现在，你可以轻松地批量修改图片，操作速度非常快！这样你就可以把宝贵的时间留给更重要的事情。你需要的各种功能都在这儿，例如：压缩、裁剪、转换文件，以及调整文件的大小等。甚至还可以通过几个点击来制作GIF动图！是的，这也是免费的。</p>
</blockquote>
<p><strong>在线颜色选择器</strong> - <a href="http://tools.jb51.net/static/colorpicker/">tools.jb51.net/static/colorpicker</a></p>
<blockquote>
<p>提供颜色值的计算工具，以及几种颜色选择的工具，方便大家选择颜色，并将颜色转换成自己想要的格式。</p>
</blockquote>
<h2 id="指数工具"><a href="#指数工具" class="headerlink" title="指数工具"></a>指数工具</h2><p><strong>百度指数</strong> - <a href="https://index.baidu.com/v2/index.html#/">index.baidu.com</a></p>
<blockquote>
<p>百度指数是以百度海量网民行为数据为基础的数据分享平台。在这里，你可以研究关键词搜索趋势、洞察网民需求变化、监测媒体舆情趋势、定位数字消费者特征；还可以从行业的角度，分析市场特点。</p>
</blockquote>
<p><strong>360趋势</strong> - <a href="https://trends.so.com/">trends.so.com</a></p>
<blockquote>
<p>360搜索是干净、安全、可信任的搜索引擎，包含 网页、 新闻、 问答、 视频、 图片、 音乐、 地图、 良医、 百科、 英文、 软件、 趋势、 学术 等多项搜索产品。</p>
</blockquote>
<p><strong>巨量算数</strong> - <a href="https://trendinsight.oceanengine.com/arithmetic-index">trendinsight.oceanengine.com</a></p>
<blockquote>
<p>巨量算数是巨量引擎旗下内容消费趋势洞察品牌。以今日头条、抖音、西瓜视频等内容消费场景为依托并承接巨量引擎的数据与技术优势，输出内容趋势、产业研究、广告策略等洞察与观点。同时，开放算数指数、算数榜单、抖音垂类等数据分析工具，满足品牌主、营销从业者、创作者等数据洞察需求。</p>
</blockquote>
<h2 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h2><p><strong>Symbolab数学求解器</strong> - <a href="https://zs.symbolab.com/">zs.symbolab.com</a></p>
<blockquote>
<p>Symbolab是一种高级数学教育工具。它允许用户使用数学符号和科学记数法以及文本来学习、练习和发现数学主题。Symbolab 为从中学到大学的代数、三角函数和微积分主题提供自动化的分步解决方案。Symbolab 提供丰富的智能计算器，包括：方程、联立方程、不等式、积分、导数、极限、切线、三角方程、函数等。该网站的既定目标是通过将可搜索的数据空间扩展到科学记数法、表达式、方程式和公式，使科学内容普遍可访问。这是通过应用专有的机器学习算法来完成的，以了解查询的含义和上下文。Symbolab，让数学变得更简单。</p>
</blockquote>
<p><strong>WolframAlpha</strong> - <a href="https://www.wolframalpha.com/">wolframalpha.com</a></p>
<blockquote>
<p>Wolfram|Alpha 的引入定义了一种全新的获取知识和答案的范式——不是通过搜索网络，而是通过基于大量内置数据、算法和方法的动态计算。随时随地为每个人带来广泛、深入、专家级的知识。</p>
</blockquote>
<p><strong>数学求解器</strong></p>
<blockquote>
<p>Edge浏览器内置工具：Edge浏览器-更多工具-数学求解器</p>
</blockquote>
<h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><p><strong>Figma</strong> - <a href="https://www.figma.com/">figma.com</a></p>
<blockquote>
<p>Figma 是一个基于浏览器的协作式跨平台 UI 设计工具，Figma 从推出至今越来越受到 UI 设计师的青睐，如今也有很多的设计团队投入了Figma 的怀抱。Figma = Sketch（UI 设计）+ InVision（原型设计） + Zeplin（标注）+ Dropbox（云端同步）+ Abstract（版本历史）+ Craft-Freehand（实时讨论） + Liveshare（实时分享）+ Team Library （团队组件库）+ Web API（第三方接入）</p>
</blockquote>
<p><strong>即时设计</strong> - <a href="https://js.design/">js.design</a></p>
<blockquote>
<p>可云端编辑的专业级 UI 设计工具，为中国设计师量身打造Windows 也能用的「协作版 Sketch」，在同一个地方，构思、设计、协作， 让你和团队更加高效。</p>
</blockquote>
<p><strong>MasterGo</strong> - <a href="https://mastergo.com/">mastergo.com</a></p>
<blockquote>
<p>面向团队的专业 UI/UX 设计工具，多人同时编辑、随时在线评审、设计一键交付，让想法更快实现</p>
</blockquote>
<h2 id="在线设计"><a href="#在线设计" class="headerlink" title="在线设计"></a>在线设计</h2><p><strong>搞定设计</strong> - <a href="https://www.gaoding.com/">gaoding.com</a></p>
<blockquote>
<p>让设计更简单。搞定设计已在多媒体创作工具、AI辅助设计以及图形图像算法等领域储备了丰富的核心技术。作为国内首批SaaS服务开拓者，我们从全新视角为电商、社交电商提供视觉设计工具和内容。并在此基础上不断丰富、迭代、打磨，为全商业场景用户提供视觉解决方案，赋能爆发式增长的数字营销需求。</p>
</blockquote>
<p><strong>创客贴</strong> - <a href="https://www.chuangkit.com/">chuangkit.com</a></p>
<blockquote>
<p>创客贴聚焦于创意设计领域，秉持用设计设计世界、让设计触手可得的使命， 提供全创意类型在线设计工具、创意版权内容、创意设计服务、数字资产管理、企业品牌云等产品和服务，为个人和企业提供一站式创意设计解决方案。</p>
</blockquote>
<p><strong>Fotor懒设计</strong> - <a href="https://www.fotor.com.cn/">fotor.com.cn</a></p>
<blockquote>
<p>Fotor是一款多平台（Mobile, Web, Mac &amp; Windows）图片编辑和平面设计产品。跟随欧美设计风潮，Fotor的每一个界面都严格遵照极简主义理念，呈现给用户最流畅、最唯美的修图和设计体验。除了提供给广大用户轻便而又全能的图片编辑工具以外，Fotor的设计功能还能满足中小型创业公司、自媒体、学生团体和个体经营者的平面设计需求。通过专业设计师制作的模板几分钟便可以轻松完成一系列专业水准的平面设计。</p>
</blockquote>
<p><strong>Canva可画</strong> - <a href="https://www.canva.cn/">canva.cn</a></p>
<blockquote>
<p>Canva可画打造了一流的中文在线设计平台，整合了数以千万计的高清图片、中英文字体、原创模板、插画等视觉元素。Canva可画降低，在某些领域甚至消除了专业设计的门槛。即使是没有任何基础的用户，也可以通过运用Canva可画的中文模板，轻松完成包括社交媒体插图、海报、电商用图、演示文稿、信息图、小视频等在内的各种设计。</p>
</blockquote>
<h2 id="排版工具"><a href="#排版工具" class="headerlink" title="排版工具"></a>排版工具</h2><p><strong>135编辑器</strong> - <a href="https://www.135editor.com/">135editor.com</a></p>
<blockquote>
<p>135编辑器用于微信排版、图文内容排版、邮件排版等场景，同时我们还提供表单制作、提议征集、报名等运营模块。一款简单易上手的在线图文排版工具，有丰富的排版样式、模板、图片素材，并提供秒刷、一键排版、全文配色、云端草稿、企业定制等强大功能。</p>
</blockquote>
<p><strong>秀米</strong> - <a href="https://xiumi.us/#/">xiumi.us</a></p>
<blockquote>
<p>秀米，微信公众号图文编辑器和H5在线制作工具，海量模板素材和排版样式，强大的布局编辑功能，轻松制作公众号图文和H5，打动你的人群。</p>
</blockquote>
<p><strong>i排版</strong> - <a href="http://ipaiban.com/bianji">ipaiban.com</a></p>
<blockquote>
<p>微信编辑器i排版是一款排版效率高、界面简洁、样式原创设计的微信排版工具，支持全文编辑，实时预览、一键样式、一键添加签名的微信图文编辑器。短短三分钟，排好一篇微信图文。</p>
</blockquote>
<h2 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h2><p><strong>LeetCode Cookbook</strong> - <a href="https://books.halfrost.com/leetcode/">books.halfrost.com/leetcode</a></p>
<blockquote>
<p>想通过 LeetCode 提高算法能力的编程爱好者。本书的算法全部用 Go 语言实现。</p>
<p>Github开源：<a href="https://github.com/halfrost/LeetCode-Go">https://github.com/halfrost/LeetCode-Go</a></p>
</blockquote>
<p><strong>labuladong</strong> - <a href="https://labuladong.github.io/algo/">labuladong.github.io/algo</a></p>
<blockquote>
<p>LABULADONG 的算法网站</p>
<p>Github开源：<a href="https://github.com/labuladong/fucking-algorithm">https://github.com/labuladong/fucking-algorithm</a></p>
</blockquote>
<p>LeetCodeAnimation算法图解 - <a href="https://github.com/MisterBooo/LeetCodeAnimation">https://github.com/MisterBooo/LeetCodeAnimation</a></p>
<p>VisuAlgo 经典的算法可视化网站 - <a href="https://visualgo.net/zh">https://visualgo.net/zh</a></p>
<p>Algrithm Visualizer - <a href="https://github.com/algorithm-visualizer/algorithm-visualizer">https://github.com/algorithm-visualizer/algorithm-visualizer</a></p>
<p><strong>洛谷OJ</strong> - <a href="https://www.luogu.com.cn/">luogu.com.cn</a></p>
<blockquote>
<p>洛谷致力于为编程爱好者提供清爽、快捷的编程体验。它不仅仅是一个在线测题系统，更拥有强大的社区、在线学习功能。同时，许多教程内容都是由五湖四海的用户提供的，保证了内容的广泛性。无论是初学 OI 的蒟蒻，还是久经沙场的神犇，均可从洛谷获益，也可以帮助他人，共同进步。</p>
</blockquote>
<h2 id="设计体系"><a href="#设计体系" class="headerlink" title="设计体系"></a>设计体系</h2><p><strong>TDesign</strong>  - <a href="https://tdesign.tencent.com/">tdesign.tencent.com</a></p>
<blockquote>
<p>TDesign 是腾讯各业务团队在服务业务过程中沉淀的一套企业级设计体系。TDesign 具有统一的 设计价值观，一致的设计语言和视觉风格，帮助用户形成连续、统一的体验认知。在此基础上，TDesign 提供了开箱即用的 UI 组件库、设计指南 和相关 设计资产，以优雅高效的方式将设计和研发从重复劳动中解放出来，同时方便大家在 TDesign 的基础上扩展，更好的的贴近业务需求。</p>
</blockquote>
<p><strong>CoDesign</strong> - <a href="https://codesign.qq.com/">codesign.qq.com</a></p>
<blockquote>
<p>一站式设计协作平台，覆盖产品经理、设计师、工程师协作需求，助力团队提升协作效率、有效管理和使用设计资产。</p>
</blockquote>
<p><strong>Ant Design</strong> - <a href="https://ant.design/index-cn">ant.design</a></p>
<blockquote>
<p> 一套企业级 UI 设计语言和 React 组件库，主要用于研发企业级中后台产品。</p>
</blockquote>
<p><strong>Fusion Design</strong> - <a href="https://fusion.design/pc/?themeid=2">fusion.design</a></p>
<blockquote>
<p>Alibaba Fusion Design企业级的中后台设计系统解决方案。</p>
</blockquote>
<p><strong>Acro Design</strong> ：<a href="https://arco.design/">arco.design</a></p>
<blockquote>
<p>字节跳动出品的企业级设计系统，企业级产品的完整设计和开发解决方案。</p>
</blockquote>
<p><strong>Semi Design</strong>：<a href="http://semi.design/zh-CN">semi.design</a></p>
<blockquote>
<p>全面、易用、优质的企业级产品设计系统。由字节跳动抖音前端与 UED 团队设计、开发并维护，包含设计语言、React 组件、主题等开箱即用的中后台解决方案，帮助设计师与开发者打造高质量产品。</p>
</blockquote>
<p><strong>Material Design</strong> - <a href="https://www.material.io/">material.io</a></p>
<blockquote>
<p>Material 是一个由指南、组件和工具组成的适应性系统，支持用户界面设计的最佳实践。在开源代码的支持下，Material 简化了设计师和开发人员之间的协作，并帮助团队快速构建精美的产品。</p>
</blockquote>
<h2 id="博客社区"><a href="#博客社区" class="headerlink" title="博客社区"></a>博客社区</h2><p><strong>掘金</strong> - <a href="https://juejin.cn/">juejin.cn</a></p>
<blockquote>
<p>一个帮助开发者成长的社区。我们旨在建立一个服务开发者的生态系统，在这个生态系统中，我们将品牌、流量、变现能力赋予开发者，帮助开发者创造出影响世界的新技术。</p>
</blockquote>
<p><strong>开源中国</strong> - <a href="https://www.oschina.net/">oschina.net</a></p>
<blockquote>
<p>OSCHINA（Open Source China，OSC）成立于 2008 年 8 月，目前已建立了相当完善的开源软件分类数据库，收录全球知名开源项目近 5 万款，涉及几百个不同的分类。围绕这些开源项目，OSCHINA 为中国开发者提供了最新开源资讯、软件更新资讯、技术分享和交流的技术平台。</p>
</blockquote>
<p><strong>CSDN</strong> - <a href="https://www.csdn.net/">csdn.net</a></p>
<blockquote>
<p>中国开发者社区CSDN (Chinese Software Developer Network) 创立于1999年，致力于成为IT技术人交流和成长的家园。</p>
</blockquote>
<p><strong>简书</strong> - <a href="https://www.jianshu.com/">jianshu.com</a></p>
<blockquote>
<p>简书是一个优质的创作社区，在这里，你可以任性地创作，一篇短文、一张照片、一首诗、一幅画……我们相信，每个人都是生活中的艺术家，有着无穷的创造力。</p>
</blockquote>
<p><strong>博客园</strong> - <a href="https://www.cnblogs.com/">cnblogs.com</a></p>
<blockquote>
<p>博客园创立于2004年1月，是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界。</p>
</blockquote>
<p><strong>Stack Overflow</strong> - <a href="https://stackoverflow.com/">stackoverflow.com</a></p>
<blockquote>
<p>Stack Overflow 可帮助人们在需要时找到所需的答案。我们以我们的公共问答平台而闻名，每月有超过 1 亿人访问该平台提出问题、学习和分享技术知识。</p>
</blockquote>
<p><strong>SegmentFault</strong> - <a href="https://segmentfault.com/">segmentfault.com</a></p>
<blockquote>
<p>SegmentFault 中文技术交流平台，在这里你可以检索，交流和分享任何技术编程相关的问题及知识。我们的目标是覆盖和服务 1,000 万以上中国软件开发者和IT信息从业者，其实现方法是充分利用在各个平台上所能获得的各种技术创新机会为他们开发产品应用和服务。</p>
</blockquote>
<h2 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h2><p><strong>阿里云</strong> - <a href="https://www.aliyun.com/">aliyun.com</a></p>
<blockquote>
<p>阿里云——阿里巴巴集团旗下公司，是全球领先的云计算及人工智能科技公司。提供免费试用、云服务器、云数据库、云安全、云企业应用等云计算服务，以及大数据、人工智能服务、精准定制基于场景的行业解决方案。免费备案，7x24 小时售后支持，助企业无忧上云。</p>
</blockquote>
<p><strong>腾讯云</strong> - <a href="https://cloud.tencent.com/">cloud.tencent.com</a></p>
<blockquote>
<p>提供全球领先的云计算服务。腾讯云，腾讯集团倾力打造的云计算品牌，面向全世界各个国家和地区的政府机构、企业组织和个人开发者，提供全球领先的云计算、大数据、人工智能等技术产品与服务，以卓越的科技能力打造丰富的行业解决方案，构建开放共赢的云端生态，推动产业互联网建设，助力各行各业实现数字化升级。</p>
</blockquote>
<p><strong>华为云</strong> - <a href="https://www.huaweicloud.com/">huaweicloud.com</a></p>
<blockquote>
<p>一切皆服务，共建智能世界云底座。面向未来的智能世界，数字化是企业发展的必由之路。数字化成功的关键是以云原生的思维践行云原生，全数字化、全云化、AI驱动，一切皆服务。华为云将持续创新，携手客户、合作伙伴和开发者，致力于让云无处不在，让智能无所不及，共建智能世界云底座。</p>
</blockquote>
<p><strong>百度智能云</strong> - <a href="https://cloud.baidu.com/">cloud.baidu.com</a></p>
<blockquote>
<p>百度智能云以“云智一体”为核心赋能千行百业，致力于为企业和开发者提供全球领先的人工智能、大数据和云计算服务以及简单易用的开发工具，加速产业智能化转型升级。</p>
</blockquote>
<h2 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h2><p><strong>Icons8</strong> - <a href="https://icons8.com/">icons8.com</a></p>
<blockquote>
<p>Icons8 中的矢量图标资源非常丰富，支持PNG格式免费下载。只需在搜索栏输入你想要查找的关键词即可。</p>
</blockquote>
<p><strong>IconPark</strong> - <a href="https://iconpark.oceanengine.com/home">iconpark.oceanengine.com</a></p>
<blockquote>
<p>IconPark图标库是一个通过技术驱动矢量图标样式的开源图标库，可以实现根据单一SVG源文件变换出多种主题， 具备丰富的分类、更轻量的代码和更灵活的使用场景；致力于构建高质量、统一化、可定义的图标资源，让大多数人都能够选择适合自己的风格图标</p>
</blockquote>
<p><strong>IconFont</strong> - <a href="https://www.iconfont.cn/">iconfont.cn</a></p>
<blockquote>
<p>阿里妈妈MUX倾力打造的矢量图标管理、交流平台。设计师将图标上传到 iconfont 平台，用户可以自定义下载多种格式的icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。</p>
</blockquote>
<p><strong>Font Awesome</strong> - <a href="https://fontawesome.com/">fontawesome.com</a></p>
<blockquote>
<p>Font Awesome 是数百万设计师、开发人员和内容创建者使用的互联网图标库和工具包。</p>
</blockquote>
<p><strong>icones.netlify</strong> - <a href="https://icones.netlify.app/">icones.netlify.app</a></p>
<blockquote>
<p>icones.netlify是一个icon合集。</p>
</blockquote>
<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p><strong>SourceForge</strong>  - <a href="https://sourceforge.net/">sourceforge.net</a></p>
<blockquote>
<p>SourceForge 是全球最大的开放源代码软件开发平台和仓库。它集成了很多开放源代码应用程序，为软件开发提供了整套生命周期服务。SourceForge.net 是开放 源代码软件的开发者进行开发管理的集中式场所，也是源代码仓库。大量开源项目在此落户，包括维基百科使用的 MediaWiki，但也包含很多休眠和单个用户的项目。</p>
</blockquote>
<p><strong>Softonic</strong> - <a href="https://en.softonic.com/">softonic.com</a></p>
<blockquote>
<p>Softonic 是一个功能非常强大的软件下载网站，你可以利用这个网站下载电脑软件，安卓 App，苹果 App；网站还拥有强大的搜索功能，你可以利用这个网站轻松搜索到你需要下载的软件。</p>
</blockquote>
<p><strong>异次元</strong> - <a href="https://www.iplaysoft.com/">iplaysoft.com</a></p>
<blockquote>
<p>异次元软件世界简称异次元，是一个致力推广优秀应用软件与互联网资源的网站，因我自己个人兴趣而建立。最初叫做《异次元の世界》，域名曾为 X-Force.cn，后来改版到现在的 iPlaySoft.com，目的是更加专注于“玩软件”的交流。</p>
</blockquote>
<h2 id="SAAS项目管理"><a href="#SAAS项目管理" class="headerlink" title="SAAS项目管理"></a>SAAS项目管理</h2><p><strong>JIRA</strong> - <a href="https://www.atlassian.com/zh">atlassian.com</a></p>
<blockquote>
<p>JIRA是集项目计划、任务分配、需求管理、缺陷跟踪于一体的软件。它基于Java架构的管理系统，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。<br>JIRA创建的问题类型包括New Feature(新功能)、Bug(缺陷)、Task(任务)和Improvement(改进)四种，还可以自定义，所以它也是一个过程管理系统。同时融合了项目管理、任务管理和缺陷管理。JIRA功能强大，可配合着一些组件及工具一起使用，如： Confluence 用于 wiki 管理需求， JIRA管理任务、进度和 Bug 。JIRA设计以项目为主线，产品、测试结合管理，通过issues控制管理。因此它的核心诉求还是围绕issue展开的，以issue驱动管理、分工、以及团队协作，进而实现项目的规划、建设，终完成产品开发。</p>
</blockquote>
<p><strong>禅道</strong> - <a href="https://www.zentao.net/">zentao.net</a></p>
<blockquote>
<p>禅道项目管理软件集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，是一款功能完备的项目管理软件，完美地覆盖了项目管理的核心流程。禅道的主要管理思想基于国际流行的敏捷项目管理方式—Scrum。Scrum是一种注重实效的敏捷项目管理方式，它规定了核心的管理框架，但具体的细节还需要团队自行扩充。禅道在遵循其管理方式基础上，又融入了国内研发现状的很多需求，比如bug管理，测试用例管理，发布管理，文档管理等。因此禅道不仅仅是一款scrum敏捷项目管理工具，更是一款完备的项目管理软件。基于scrum，又不局限于scrum。禅道最大的特色是创造性的将产品、项目、测试这三者的概念明确分开，互相配合，又互相制约。通过需求、任务、bug来进行交相互动，最终通过项目拿到合格的产品。</p>
</blockquote>
<p><strong>Tower</strong> - <a href="https://tower.im/">tower.im</a></p>
<blockquote>
<p>Tower 帮助你更高效的安排工作任务，管理项目进度，沉淀团队知识，让每个人走得更快，让团队走得更远。使用 Tower 项目，帮助不同规模和业务场景的团队设置目标，组织待办事务。在项目内用任务分解工作，指派负责人，设置截止时间，Tower 会自动追踪延期任务，发送提醒。像使用 Excel 一样组织和整理任务，更多维度查看任务，分析结果。将团队业务流程化，每个阶段的任务和目标一目了然。</p>
</blockquote>
<h2 id="编码辅助工具"><a href="#编码辅助工具" class="headerlink" title="编码辅助工具"></a>编码辅助工具</h2><p><strong>GitHub Copilot</strong> - <a href="https://github.com/features/copilot/">github.com/features/copilot</a></p>
<blockquote>
<p>GitHub Copilot是一款非常好用的代码生成工具，适合生成通用的工具代码、leetcode算法、单元测试等场景的高频代码，而对业务代码的生成则依然存在语法错误的问题。</p>
</blockquote>
<p><strong>TabNine</strong> - <a href="https://www.tabnine.com/">tabnine.com</a></p>
<blockquote>
<p>已经被<a href="https://www.codota.com/">Codota</a>公司收购。TabNine能提供长序列的代码补全，TabNine是支持的开发语言种类以及IDE平台最多的工具。但是与其他工具相同，它会推荐出不完整的代码以及存在语法错误的代码。有部分开发者喜欢TabNine即时学习代码模式的能力，这点是相比其他工具比较不错的，虽然目前提取代码模式的能力还存在比较多的缺陷，但是相信未来会逐渐完善。</p>
</blockquote>
<p><strong>阿里云Cosy</strong> - <a href="https://developer.aliyun.com/tool/cosy">developer.aliyun.com/tool/cosy</a></p>
<blockquote>
<p>阿里云Cosy的代码补全在TabNine的基础上更进一步的解决了部分生成错误代码的缺陷，但是在细节打磨上还存在一些问题，与TabNine、GitHub Copilot相比各有千秋，Cosy的代码搜索功能相比其他工具确实是一个比较好的亮点。</p>
</blockquote>
<h2 id="协同工具"><a href="#协同工具" class="headerlink" title="协同工具"></a>协同工具</h2><p><strong>腾讯文档</strong> - <a href="https://docs.qq.com/desktop">docs.qq.com/desktop</a></p>
<blockquote>
<p>腾讯文档是一个多人协作在线文档平台，支持多人在线编辑Word、Excel和PPT文档。腾讯文档支持随时随地创建、编辑的多人协作式在线文档工具，拥有一键翻译、实时股票函数和浏览权限安全可控等智能化操作，以及打通QQ，微信等多个平台编辑和分享的能力。 </p>
</blockquote>
<p><strong>石墨文档</strong> - <a href="https://shimo.im/">shimo.im</a></p>
<blockquote>
<p>石墨文档是中国首款支持多人实时协同的云端 Office 办公软件。作为中国协同办公的基础工具，石墨提供了文档、表格、幻灯片、企业网盘等全套云协同办公产品，能够助力企业实现文档高效协同、知识沉淀传承、内容安全管控，以及系统灵活集成。</p>
</blockquote>
<p><strong>Processon</strong> - <a href="https://processon.com/">processon.com</a></p>
<blockquote>
<p>一个实时协作、在线作图工具，支持个人或团队在线制作各种图形。ProcessOn是一款专业在线作图工具和分享社区。它支持流程图、思维导图、原型图、网络拓扑图和UML等多种类型的绘制。思维导图也好、逻辑图也罢，都是帮助我们从抽象中来，到具象中去的方法，ProcessOn 会把这些方法加强，相信这种加强对常常需要“离散—总结—再离散”自己思维的伙伴来说，是有价值的。</p>
</blockquote>
<p><strong>幕布</strong> - <a href="https://mubu.com/home">mubu.com</a></p>
<blockquote>
<p>幕布主要以大纲的形式梳理呈现结构化内容，并且支持思维导图模式，可以一键把大纲结构的文本内容转化成思维导图。幕布支持OPML格式和思维导图格式文件的导入和导出，也支持多种其他格式(PDF、Word、HTML，图片以及.MM)导出。在幕布所写的内容可以保留样式复制粘贴到印象笔记、简书、微信公众号等第三方写作平台。幕布后期也将不断升级，并推出新产品。</p>
</blockquote>
<h2 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h2><p><strong>CSDN</strong> - <a href="https://www.csdn.net/">csdn.net</a></p>
<blockquote>
<p>CSDN（中国开发者网络）创立于1999年，是全球知名中文开发者网站。秉承成就一亿技术人的使命，为IT技术人成长及科技企业发展，提供开发者生态的全方位服务。CSDN在社区基础上，通过知识云、人才云、开发云三大服务，赋能开发者、研发团队及科技企业在IT知识学习、人才招聘、研发效能与协同管理等方面的高速成长与发展。</p>
</blockquote>
<p><strong>OSCHINA</strong> - <a href="https://www.oschina.net/">oschina.net</a></p>
<blockquote>
<p>OSCHINA（Open Source China，OSC）成立于 2008 年 8 月，目前已建立了相当完善的开源软件分类数据库，收录全球知名开源项目近 5 万款，涉及几百个不同的分类。围绕这些开源项目，OSCHINA 为中国开发者提供了最新开源资讯、软件更新资讯、技术分享和交流的技术平台。</p>
</blockquote>
<p><strong>掘金</strong> - <a href="https://juejin.cn/">juejin.cn</a></p>
<blockquote>
<p>我们旨在建立一个服务开发者的生态系统，在这个生态系统中，我们将品牌、流量、变现能力赋予开发者，帮助开发者创造出影响世界的新技术。</p>
</blockquote>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p><strong>Google</strong> - <a href="https://google..com/">google..com</a></p>
<blockquote>
<p>谷歌拥有超过 70% 的搜索市场份额，无疑是最受欢迎的搜索引擎。此外，谷歌捕获了近 85% 的移动流量。巨大的流量潜力使谷歌成为获取自然搜索或付费搜索的可行选择。Google 算法的更改（例如：精选摘要）旨在直接在 Google 上满足用户的需求，因此他们无需点击任何链接。这些变化以及 Google 的流行可能使你难以捕获所需的网站流量。</p>
</blockquote>
<p><strong>Bing</strong> - <a href="https://cn.bing.com/">cn.bing.com</a></p>
<blockquote>
<p>必应（Bing）是微软公司于2009年5月28日推出的全新搜索引擎服务。必应集成了多个独特功能，包括每日首页美图，与Windows 8.1深度融合的超级搜索功能，以及崭新的搜索结果导航模式等。作为最贴近中国用户的全球搜索引擎，微软必应一直致力于为中国用户提供了美观、高质量、国际化的中英文搜索服务。</p>
</blockquote>
<p><strong>百度</strong> - <a href="https://www.baidu.com/">baidu.com</a></p>
<blockquote>
<p>百度是中国最大的搜索引擎，占据了中国搜索市场超过 75% 的份额。搜索引擎看起来类似于谷歌，有白色背景、蓝色链接和绿色 URL。与谷歌一样，百度的目标是在 SERP 中加入更丰富的功能(更多的是关键词竞价等商业行为)。</p>
</blockquote>
<p><strong>Yandex</strong> - <a href="https://yandex.com/">yandex.com</a></p>
<blockquote>
<p>俄罗斯的版的百度，Yandex是俄罗斯重要网络服务门户之一，值得一提的是，即使在没有“互联网围墙”的俄罗斯，Yandex的市场份额已远超俄罗斯Google，它也是欧洲第二大流行搜索引擎，推荐它是因为访问速度够快。</p>
</blockquote>
<h2 id="技术团队"><a href="#技术团队" class="headerlink" title="技术团队"></a>技术团队</h2><p><strong>美团技术团队</strong> - <a href="https://tech.meituan.com/">tech.meituan.com</a> </p>
<blockquote>
<p>美团经过多年耕耘和沉淀，团队已经建成了比较完备的技术体系，有基于主流开源技术加自研的大数据、人工智能、基础架构、复杂业务系统平台，和比较完备的运维、安全、风控系统。其中，美团外卖智能配送调度系统每天匹配50多万外卖小哥，100多万商家，1000多万消费者，基于海量数据和人工智能算法，确保平均配送时长不超过28分钟，是目前世界上规模超大，复杂度超高的多人、多点实时智能配送调度系统。</p>
</blockquote>
<p><strong>小米信息部技术团队</strong>- <a href="https://xiaomi-info.github.io/">xiaomi-info.github.io</a></p>
<blockquote>
<p>小米信息部技术团队</p>
</blockquote>
<p><strong>字节跳动技术团队</strong> - <a href="https://blog.csdn.net/ByteDanceTech/">blog.csdn.net/ByteDanceTech</a></p>
<blockquote>
<p>字节跳动技术团队官方博客</p>
</blockquote>
<p><strong>ThoughtWorks 洞见</strong> - <a href="https://insights.thoughtworks.cn/">insights.thoughtworks.cn</a></p>
<blockquote>
<p>ThoughtWorks 洞见</p>
</blockquote>
<p><strong>有赞技术团队</strong> - <a href="https://tech.youzan.com/">tech.youzan.com</a></p>
<blockquote>
<p>有赞技术团队</p>
</blockquote>
<h2 id="在线论坛"><a href="#在线论坛" class="headerlink" title="在线论坛"></a>在线论坛</h2><p><strong>吾爱破解</strong> - <a href="https://www.52pojie.cn/">52pojie.cn</a></p>
<blockquote>
<p>吾爱破解是目前国内最大的软件破解论坛，而且网友都很热心，也是国内下载氛围最好的软件下载网站论坛。</p>
</blockquote>
<p><strong>亦是美网络</strong> - <a href="http://www.yishimei.cn/">yishimei.cn</a></p>
<blockquote>
<p>亦是美网络，致力于操作系统应用与计算机网络技术的IT网站。精心为大家收集、整理常用的工具、软件资源，不断的为大家提供和推荐有用的计算机网络教程与技术。</p>
</blockquote>
<h2 id="集成服务"><a href="#集成服务" class="headerlink" title="集成服务"></a>集成服务</h2><p><strong>声网</strong> - <a href="https://www.agora.io/cn/">agora.io/cn</a></p>
<blockquote>
<p>声网是实时互动 API 平台行业开创者，是专业服务商。开发者只需简单调用声网 API，即可在应用内构建多种实时音视频互动场景。</p>
</blockquote>
<p><strong>环信</strong> - <a href="https://www.easemob.com/">easemob.com</a></p>
<blockquote>
<p>环信主要产品线包括即时通讯能力PaaS平台——环信即时通讯云，全场景音视频PaaS平台——环信实时音视频云，全媒体智能客服SaaS平台——环信客服云，以及企业级人工智能服务能力平台——环信机器人，是国内较早覆盖云通讯、云客服、智能机器人的一体化产品技术储备企服公司。</p>
</blockquote>
<p><strong>LearnCloud</strong> - <a href="https://www.leancloud.cn/">leancloud.cn</a></p>
<blockquote>
<p>LeanCloud 是行业领先的一站式后端云服务提供商，专注于为开发者提供一流的工具、平台和服务。提供包括数据存储、文件存储与 CDN、消息推送和即时通讯在内的后端云服务，同时提供支撑后端代码的云引擎和云函数等开发工具，全面涵盖移动开发的需求；我们同时也提供了易于集成的全平台 SDK，支持 iOS、Android 应用和游戏开发，以及包括微信小程序在内的 web 开发。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
