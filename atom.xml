<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaxxSpace</title>
  
  <subtitle>特立独行</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2025-10-22T03:11:19.302Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fangjian98</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习模型训练全流程</title>
    <link href="http://yoursite.com/article/79f5c2dd.html"/>
    <id>http://yoursite.com/article/79f5c2dd.html</id>
    <published>2022-05-31T14:19:33.000Z</published>
    <updated>2025-10-22T03:11:19.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习模型训练全流程：数据集、探索性数据分析、数据预处理、数据分割、模型建立、机器学习等。</p></blockquote><a id="more"></a><h1 id="最全的机器学习模型训练全流程"><a href="#最全的机器学习模型训练全流程" class="headerlink" title="最全的机器学习模型训练全流程"></a>最全的机器学习模型训练全流程</h1><h2 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h2><p>发现一个很有趣的<a href="https://so.csdn.net/so/search?q=%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE&spm=1001.2101.3001.7020">开源项目</a>，作者用手绘图的方式讲解了机器学习模型构建的全流程，逻辑清晰、生动形象。想给大家分享一下。<br>项目地址:<a href="https://github.com/dataprofessor/infographic">https://github.com/dataprofessor/infographic</a><br><img src="https://img-blog.csdnimg.cn/img_convert/e948159b0b0628d8fc360aed3f4debaa.png#pic_center" alt="在这里插入图片描述"></p><p><strong>全文如下：</strong></p><p>感觉学习数据科学枯燥无味，那如何能让学习数据科学变得有趣而简单呢？带着这个目标，我开始在iPad上涂鸦建立<a href="https://so.csdn.net/so/search?q=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&spm=1001.2101.3001.7020">机器学习</a>模型所需的流程。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5c1b5e14d98c75c44799dfb8b33238ec.png#pic_center" alt="在这里插入图片描述"></p><h2 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1. 数据集"></a>1. <a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020">数据集</a></h2><p>数据集是你构建机器学习模型历程中的起点。简单来说，数据集本质上是一个M×N<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a>，其中M代表列（特征），N代表行（样本）。</p><p>列可以分解为X和Y，首先，X是几个类似术语的同义词，如特征、独立变量和输入变量。其次，Y也是几个术语的同义词，即类别标签、因变量和输出变量。<br><img src="https://img-blog.csdnimg.cn/img_convert/a589e7727e877b7d740feea5db65fd3d.png#pic_center" alt="在这里插入图片描述"><br>图1. 数据集的卡通插图</p><p>应该注意的是，一个可以用于监督学习的数据集（可以执行回归或分类）将同时包含X和Y，而一个可以用于无监督学习的数据集将只有X。</p><p>此外，如果Y包含定量值，那么数据集（由X和Y组成）可以用于回归任务，而如果Y包含定性值，那么数据集（由X和Y组成）可以用于分类任务。</p><h2 id="2-探索性数据分析（EDA）"><a href="#2-探索性数据分析（EDA）" class="headerlink" title="2. 探索性数据分析（EDA）"></a>2. 探索性数据分析（EDA）</h2><p>进行探索性数据分析（EDA）是为了获得对数据的初步了解。在一个典型的数据科学项目中，我会做的第一件事就是通过执行EDA来 “盯住数据”，以便更好地了解数据。</p><p>我通常使用的三大EDA方法包括：</p><ul><li>描述性统计：平均数、中位数、模式、标准差。</li><li>数据可视化：热力图（辨别特征内部相关性）、箱形图（可视化群体差异）、散点图（可视化特征之间的相关性）、主成分分析（可视化数据集中呈现的聚类分布）等。</li><li>数据整形：对数据进行透视、分组、过滤等。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ddfd472f1ff1a8eb7669594baaa3c5c3.png#pic_center" alt="在这里插入图片描述"><br>图2. NBA球员统计数据的箱形图示例</p><p><img src="https://img-blog.csdnimg.cn/img_convert/65c30dba2762c047d4985a673a2c143e.png#pic_center" alt="在这里插入图片描述"><br>图3. NBA球员统计数据的相关热力图示例<br><img src="https://img-blog.csdnimg.cn/img_convert/e9c973782708a005becb0370dfd34529.png#pic_center" alt="在这里插入图片描述"><br>图4. NBA球员统计数据的直方图示例</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e958e7afe50f95c4e3d7a8bd6c3ccb63.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3. 数据预处理"></a>3. 数据预处理</h2><p><strong>数据预处理(又称数据清理、数据整理或数据处理)是指对数据进行各种检查和审查的过程，以纠正缺失值、拼写错误、使数值正常化/标准化以使其具有可比性、转换数据(如对数转换)等问题。</strong></p><p>“Garbage in, Garbage out.”</p><p>正如上面的引言所说，数据的质量将对生成模型的质量产生很大的影响。因此，为了达到最高的模型质量，应该在数据预处理阶段花费大量精力。一般来说，数据预处理可以轻松地占到数据科学项目所花费时间的80%，而实际的模型建立阶段和后续的模型分析仅占到剩余的20%。</p><h2 id="4-数据分割"><a href="#4-数据分割" class="headerlink" title="4. 数据分割"></a>4. 数据分割</h2><h3 id="4-1-训练–测试集分割"><a href="#4-1-训练–测试集分割" class="headerlink" title="4.1 训练–测试集分割"></a>4.1 训练–测试集分割</h3><p>在机器学习模型的开发过程中，希望训练好的模型能在新的、未见过的数据上表现良好。为了模拟新的、未见过的数据，对可用数据进行数据分割，从而将其分割成2部分（有时称为训练—测试分割）。特别是，第一部分是较大的数据子集，用作<a href="https://so.csdn.net/so/search?q=%E8%AE%AD%E7%BB%83%E9%9B%86&spm=1001.2101.3001.7020">训练集</a>（如占原始数据的80%），第二部分通常是较小的子集，用作测试集（其余20%的数据）。需要注意的是，这种数据拆分只进行一次。</p><p>接下来，利用训练集建立预测模型，然后将这种训练好的模型应用于测试集（即作为新的、未见过的数据）上进行预测。根据模型在测试集上的表现来选择最佳模型，为了获得最佳模型，还可以进行超参数优化。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/04bda3d58fd0d7d3f00f09633a7346e0.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-2-训练–验证–测试集分割"><a href="#4-2-训练–验证–测试集分割" class="headerlink" title="4.2 训练–验证–测试集分割"></a>4.2 训练–验证–测试集分割</h3><p>另一种常见的数据分割方法是将数据分割成3部分。(1) 训练集，(2) 验证集和(3) 测试集。与上面解释的类似，训练集用于建立预测模型，同时对验证集进行评估，据此进行预测，可以进行模型调优（如超参数优化），并根据验证集的结果选择性能最好的模型。正如我们所看到的，类似于上面对测试集进行的操作，这里我们在验证集上做同样的操作。请注意，测试集不参与任何模型的建立和准备。因此，测试集可以真正充当新的、未知的数据。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4474821915c1010ba44add1073e8958e.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-3-交叉验证"><a href="#4-3-交叉验证" class="headerlink" title="4.3 交叉验证"></a>4.3 交叉验证</h3><p>为了最经济地利用现有数据，通常使用N倍交叉验证（CV），将数据集分割成N个折（即通常使用5倍或10倍CV）。在这样的N倍CV中，其中一个折被留作测试数据，而其余的折则被用作建立模型的训练数据。</p><p>例如，在5倍CV中，有1个折被省略，作为测试数据，而剩下的4个被集中起来，作为建立模型的训练数据。然后，将训练好的模型应用于上述遗漏的折（即测试数据）。这个过程反复进行，直到所有的折都有机会被留出作为测试数据。因此，我们将建立5个模型（即5个折中的每个折都被留出作为测试集），其中5个模型中的每个模型都包含相关的性能指标（我们将在接下来的部分讨论）。最后，度量（指标）值是基于5个模型计算出的平均性能。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9d45766ab73071d61345e172de34f30c.png#pic_center" alt="在这里插入图片描述"></p><h2 id="5-模型建立"><a href="#5-模型建立" class="headerlink" title="5. 模型建立"></a>5. 模型建立</h2><p><strong>现在，有趣的部分来了，我们终于可以使用精心准备的数据来建立模型了。根据目标变量（通常称为Y变量）的数据类型（定性或定量），我们要建立一个分类（如果Y是定性的）或回归（如果Y是定量的）模型。</strong></p><h3 id="5-1-学习算法"><a href="#5-1-学习算法" class="headerlink" title="5.1 学习算法"></a>5.1 学习算法</h3><p>机器学习算法可以大致分为以下三种类型之一：</p><ul><li>监督学习：是一种机器学习任务，建立输入X和输出Y变量之间的数学（映射）关系。这样的X、Y对构成了用于建立模型的标签数据，以便学习如何从输入中预测输出。</li><li>无监督学习：是一种只利用输入X变量的机器学习任务。这种 X 变量是未标记的数据，学习算法在建模时使用的是数据的固有结构。</li><li>强化学习：是一种决定下一步行动方案的机器学习任务，它通过试错学习来实现这一目标，努力使回报最大化。</li></ul><h3 id="5-2-参数调优"><a href="#5-2-参数调优" class="headerlink" title="5.2 参数调优"></a>5.2 参数调优</h3><p>超参数本质上是机器学习算法的参数，直接影响学习过程和预测性能。由于没有“一刀切 ”的超参数设置，可以普遍适用于所有数据集，因此需要进行超参数优化（也称为超参数调整或模型调整）。</p><p>我们以随机森林为例。在使用randomForest R包时，通常会对两个常见的超参数进行优化，其中包括mtry和ntree参数（这对应于scikit-learnPython库中RandomForestClassifier()和RandomForestRegressor()函数中的nestimators和maxfeatures）。mtry（maxfeatures）代表在每次分裂时作为候选变量随机采样的变量数量，而ntree（nestimators）代表要生长的树的数量。</p><p>另一种流行的机器学习算法是支持向量机。需要优化的超参数是径向基函数(RBF)内核的C参数和gamma参数(即线性内核只有C参数；多项式内核的C和指数)。C参数是一个限制过拟合的惩罚项，而gamma参数则控制RBF核的宽度。如上所述，调优通常是为了得出超参数的最佳值集，尽管如此，也有一些研究旨在为C参数和gamma参数找到良好的起始值（Alvarsson等人，2014）。</p><p>地址：<a href="https://pubs.acs.org/doi/10.1021/ci500344v">https://pubs.acs.org/doi/10.1021/ci500344v</a></p><h3 id="5-3-特征选择"><a href="#5-3-特征选择" class="headerlink" title="5.3 特征选择"></a>5.3 特征选择</h3><p>顾名思义，特征选择从字面上看就是从最初的大量特征中选择一个特征子集的过程。除了实现高精度的模型外，机器学习模型构建最重要的一个方面是获得可操作的见解，为了实现这一目标，能够从大量的特征中选择出重要的特征子集非常重要。</p><p>特征选择的任务本身就可以构成一个全新的研究领域，在这个领域中，大量的努力都是为了设计新颖的算法和方法。从众多可用的特征选择算法中，一些经典的方法是基于模拟退火和遗传算法。除此之外，还有大量基于进化算法（如粒子群优化、蚁群优化等）和随机方法（如蒙特卡洛）的方法。</p><p>我们自己的研究小组也在对醛糖还原酶抑制剂的定量结构—活性关系建模的研究中，探索了利用蒙特卡洛模拟进行特征选择的方法（Nantasenamat等，2014）。<br>地址:<a href="https://doi.org/10.1016/j.ejmech.2014.02.043">https://doi.org/10.1016/j.ejmech.2014.02.043</a></p><p>在《遗传算法搜索空间拼接粒子群优化作为通用优化器》的工作中，我们还设计了一种基于结合两种流行的进化算法即遗传算法和粒子群算法的新型特征选择方法（Li等，2013）。<br>地址:<a href="https://doi.org/10.1016/j.chemolab.2013.08.009">https://doi.org/10.1016/j.chemolab.2013.08.009</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/449a0ace0442abe9607dc0606af605f5.png#pic_center" alt="在这里插入图片描述"><br>“原搜索空间（a）x∈[-500,0]在每个维度上以2的固定间隔拼接成子空间（图中一个维度等于一个横轴）。这样就得到了4个子空间(b-e)，其中x在每个维度上的范围是原始空间的一半。GA的每一个字符串都会编码一个子空间的索引。然后，GA启发式地选择一个子空间（e），并在那里启动PSO（粒子显示为红点）。PSO搜索子空间的全局最小值，最好的粒子适应性作为编码该子空间索引的GA字符串的适应性。最后，GA进行进化，选择一个新的子空间进行探索。整个过程重复进行，直到达到满意的误差水平。”</p><h2 id="6-机器学习任务"><a href="#6-机器学习任务" class="headerlink" title="6. 机器学习任务"></a>6. 机器学习任务</h2><p>在监督学习中，两个常见的机器学习任务包括分类和回归。</p><h3 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1 分类"></a>6.1 分类</h3><p>一个训练有素的分类模型将一组变量（定量或定性）作为输入，并预测输出的类标签（定性）。下图是由不同颜色和标签表示的三个类。每一个小的彩色球体代表一个数据样本。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b86af8d3630d8333f23889528ac01e08.png#pic_center" alt="在这里插入图片描述"><br>三类数据样本在二维中的显示。上图显示的是数据样本的假设分布。这种可视化图可以通过执行PCA分析并显示前两个主成分（PC）来创建；或者也可以选择两个变量的简单散点图可视化。</p><h3 id="6-1-1-样例数据集"><a href="#6-1-1-样例数据集" class="headerlink" title="6.1.1 样例数据集"></a>6.1.1 样例数据集</h3><p>以企鹅数据集（Penguins Dataset）为例（最近提出作为大量使用的Iris数据集的替代数据集），我们将定量（喙长、喙深、鳍长和身体质量）和定性（性别和岛屿）特征作为输入，这些特征唯一地描述了企鹅的特征，并将其归入三个物种类别标签（Adelie、Chinstrap或Gentoo）之一。该数据集由344行和8列组成。之前的分析显示，该数据集包含333个完整的案例，其中11个不完整的案例中出现了19个缺失值。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/860d0e764e0f77e362475954ee0da385.png#pic_center" alt="在这里插入图片描述"><br>图11. 三个企鹅物种的类别标签（Chinstrap、Gentoo和Adelie）</p><h3 id="6-1-2-性能指标"><a href="#6-1-2-性能指标" class="headerlink" title="6.1.2 性能指标"></a>6.1.2 性能指标</h3><p>如何知道我们的模型表现好或坏？答案是使用性能指标，一些常见的评估分类性能的指标包括准确率（Ac）、灵敏度（Sn）、特异性（Sp）和马太相关系数（MCC）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/65a6e7a9abd0ad17684d658ce3bf9947.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/6762a6c4d3d907dcdf5309a77524b978.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/6c2a7c02317fc05cf955facdf882b198.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/0c9e925c8977f0b0be0a3927dfede2f0.png#pic_center" alt="在这里插入图片描述"><br>其中TP、TN、FP和FN分别表示真阳性、真阴性、假阳性和假阴性的实例。应该注意的是，MCC的范围从-1到1，其中MCC为-1表示最坏的可能预测，而值为1表示最好的可能预测方案。此外，MCC为0表示随机预测。</p><h3 id="6-2-回归"><a href="#6-2-回归" class="headerlink" title="6.2 回归"></a>6.2 回归</h3><p>简而言之，可以通过以下简单等式很好地总结训练有素的回归模型：Y = f(X)。其中，Y对应量化输出变量，X指输入变量，f指计算输出值作为输入特征的映射函数（从训练模型中得到）。上面的回归例子公式的实质是，如果X已知，就可以推导出Y。一旦Y被计算出来（我们也可以说是 “预测”），一个流行的可视化方式是将实际值与预测值做一个简单的散点图，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4a21012b42cf9b29d304155a45d80cd6.png#pic_center" alt="在这里插入图片描述"></p><h3 id="6-2-1-样例数据集"><a href="#6-2-1-样例数据集" class="headerlink" title="6.2.1 样例数据集"></a>6.2.1 样例数据集</h3><p>波士顿住房数据集（Boston Housing Dataset）是数据科学教程中通常使用的一个热门示例数据集。该数据集由506行和14列组成。为了简洁起见，下面显示的是标题（显示变量名称）加上数据集的前4行。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9fc1a37a13b5da7d994d4c261ebef46a.png#pic_center" alt="在这里插入图片描述"><br>在14列中，前13个变量被用作输入变量，而房价中位数（medv）被用作输出变量。可以看出，所有14个变量都包含了量化的数值，因此适合进行回归分析。我还在YouTube上做了一个逐步演示如何用Python建立线性回归模型的视频。</p><h3 id="6-2-2-性能指标"><a href="#6-2-2-性能指标" class="headerlink" title="6.2.2 性能指标"></a>6.2.2 性能指标</h3><p>对回归模型的性能进行评估，以评估拟合模型可以准确预测输入数据值的程度。评估回归模型性能的常用指标是确定系数（R²）。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a34a65112e4f0dca7ef992786e14265e.png#pic_center" alt="在这里插入图片描述"><br>从公式中可以看出，R²实质上是1减去残差平方和（SSres）与总平方和（SStot）的比值。简单来说，可以说它代表了解释方差的相对量度。例如，如果R²=0.6，那么意味着该模型可以解释60%的方差（即60%的数据符合回归模型），而未解释的方差占剩余的40%。</p><p>此外，均方误差（MSE）以及均方根误差（RMSE）也是衡量残差或预测误差的常用指标。<br><img src="https://img-blog.csdnimg.cn/img_convert/bc761eccbf90c66b89b1929b6e5d2577.png#pic_center" alt="在这里插入图片描述"><br>从上面的公式可以看出，MSE顾名思义是很容易计算的，取平方误差的平均值。此外，MSE的简单平方根可以得到RMSE。</p><h2 id="7-分类任务的直观说明"><a href="#7-分类任务的直观说明" class="headerlink" title="7. 分类任务的直观说明"></a>7. 分类任务的直观说明</h2><p><strong>现在我们再来看看分类模型的整个过程。以企鹅数据集为例，我们可以看到，企鹅可以通过4个定量特征和2个定性特征来描述，然后将这些特征作为训练分类模型的输入。在训练模型的过程中，需要考虑的问题包括以下几点。</strong></p><ul><li>使用什么机器学习算法？</li><li>应该探索什么样的搜索空间进行超参数优化？</li><li>使用哪种数据分割方案？80/20分割还是60/20/20分割？还是10倍CV？</li></ul><p>一旦模型被训练，得到的模型就可以用来对类别标签（即在我们的案例中企鹅种类）进行预测，可以是三种企鹅种类中的一种：Adelie、Chinstrap或Gentoo。</p><p>除了只进行分类建模，我们还可以进行主成分分析（PCA），这将只利用X（独立）变量来辨别数据的底层结构，并在这样做的过程中允许将固有的数据簇可视化（如下图所示为一个假设图，其中簇根据3种企鹅物种进行了颜色编码）。<br><img src="https://img-blog.csdnimg.cn/img_convert/2fa98b5e4ee108504a45b90014629681.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习模型训练全流程：数据集、探索性数据分析、数据预处理、数据分割、模型建立、机器学习等。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="MachineLearning" scheme="http://yoursite.com/categories/MachineLearning/"/>
    
    
    <category term="MachineLearning" scheme="http://yoursite.com/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX数学表达式</title>
    <link href="http://yoursite.com/article/f107c406.html"/>
    <id>http://yoursite.com/article/f107c406.html</id>
    <published>2022-05-23T08:39:29.000Z</published>
    <updated>2025-10-22T03:11:19.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一个作者，在博客中公式的编辑总是难免的。markdown并不支持数学公式编辑，这些公式仅靠编辑器自带的排版功能是难以表示的，所以需要我们掌握网页公式编辑方案。目前比较流行的网页公式编辑方案是采用TEX/LATEX语法编辑，知名的有MathJax、KATEX。</p></blockquote><a id="more"></a><h3 id="关于KaTeX"><a href="#关于KaTeX" class="headerlink" title="关于KaTeX"></a>关于KaTeX</h3><p><a href="https://katex.org/">KaTex</a> - The fastest math typesetting library for the web.</p><p>可汗学院出品，号称“最快”的数学公式渲染库，支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8~IE11。</p><p>KaTex的优势</p><ul><li><p>快速：并发渲染，无需重排页面。根据这个测试，性能绝对秒杀MathJax。</p></li><li><p>渲染效果好：采用TeX语法，渲染效果达到印刷出版级别。</p></li><li><p>无依赖：不依赖其它库。</p></li><li><p>支持服务器端渲染：例如，服务器端的Node.js程序调用KaTeX，把渲染好的HTML片段直接发送给客户端。</p></li></ul><p>KaTeX官方文档</p><p><a href="https://katex.org/docs/supported.html">Supported Functions · KaTeX</a></p><p><a href="https://katex.org/docs/support_table.html">Support Table · KaTeX</a></p><p>overleaf数学表达式</p><p><a href="https://cn.overleaf.com/learn/latex/Mathematical_expressions">https://cn.overleaf.com/learn/latex/Mathematical_expressions</a></p><p>MyScript手绘公式</p><p><a href="https://webdemo.myscript.com/">https://webdemo.myscript.com/</a></p><p>Tex 科学公式语言 (TeX/LaTeX)示例</p><p><a href="https://pandao.github.io/editor.md/examples/katex.html">https://pandao.github.io/editor.md/examples/katex.html</a></p><p>LaTeX 数学表达式</p><p><a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference</a></p><h3 id="LaTeX示例"><a href="#LaTeX示例" class="headerlink" title="LaTeX示例"></a>LaTeX示例</h3><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma(z)%20=%20%5Cint_0%5E%5Cinfty%20t%5E%7Bz-1%7De%5E%7B-t%7Ddt%5C,." alt="CodeCogsEqn"></p><p>渲染LaTeX数学表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="LaTeX书籍"><a href="#LaTeX书籍" class="headerlink" title="LaTeX书籍"></a>LaTeX书籍</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf">https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf</a></p><p><a href="https://www.latex-project.org/help/documentation/amsldoc.pdf">https://www.latex-project.org/help/documentation/amsldoc.pdf</a></p><h3 id="LATEX语法"><a href="#LATEX语法" class="headerlink" title="LATEX语法"></a>LATEX语法</h3><p>在LaTeX数学模式中，公式有两种形式——行内公式和行间公式。前者公式嵌入在行内，适用于简单短小的公式；后者居中独占一行，适用于比较长或重要的公式。科学公式 TeX(KaTeX)</p><p><strong>行内公式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ f(x) = a+b $</span><br></pre></td></tr></table></figure><p>效果： <img src="https://www.zhihu.com/equation?tex=f(x)+=+a+b" alt="[公式]"></p><p><strong>行间公式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x) = a+b $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=f(x)+=+a+b+" alt="[公式]"></p><p><strong>手动编号</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x) = a - b \tag&#123;1.1&#125; $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=f(x)+=+a+-+b+%5Ctag%7B1.1%7D" alt="[公式]"></p><p><strong>公式组合</strong></p><p>通过cases环境实现公式的组合，&amp;分隔公式和条件，还可以通过\limits来让x→0位于lim的正下方而非默认在lim符号的右下方显示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$D(x) = \begin&#123;cases&#125;</span><br><span class="line">\lim\limits_&#123;x \to 0&#125; \frac&#123;a^x&#125;&#123;b+c&#125;, &amp; x&lt;3 \\</span><br><span class="line">\pi, &amp; x=3 \\</span><br><span class="line">\int_a^&#123;3b&#125;x_&#123;ij&#125;+e^2 \mathrm&#123;d&#125;x,&amp; x&gt;3 \\</span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/equation.svg" alt="[公式]"></p><p><strong>拆分单个公式</strong></p><p>通过split环境实现公式拆分</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;split&#125;</span><br><span class="line">\cos 2x &amp;= \cos^2x - \sin^2x \\</span><br><span class="line">&amp;=2\cos^2x-1</span><br><span class="line">\end&#123;split&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/equation_split.svg" alt="[公式]"></p><p><strong>简单运算</strong></p><p>拉丁字母、阿拉伯数字和 +-*/= 运算符均可以直接输入获得，命令\cdot表示乘法的圆点，命令\neq表示不等号，命令\equiv表示恒等于，命令\bmod表示取模</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ x+2-3*4/6=4/y + x\cdot y $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=x+2-3*4/6=4/y+++x%5Ccdot+y" alt="[公式]"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ 0 \neq 1 \quad x \equiv x \quad 1 = 9 \bmod 2 $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=0+%5Cneq+1+%5Cquad+x+%5Cequiv+x+%5Cquad+1+=+9+%5Cbmod+2" alt="[公式]"></p><p><strong>上下标</strong></p><p>语法_表示下标、^表示上标，但上下标内容不止一个字符时，需用大括号括起来。单引号’表示求导</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ a_&#123;ij&#125;^&#123;2&#125; + b^3_&#123;2&#125;=x^&#123;t&#125; + y&#x27; + x&#x27;&#x27;_&#123;12&#125; $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=a_%7Bij%7D%5E%7B2%7D+++b%5E3_%7B2%7D=x%5E%7Bt%7D+++y%27+++x%27%27_%7B12%7D" alt="[公式]"></p><p><strong>根号、分式</strong></p><p>命令：\sqrt表示平方根，\sqrt[n]表示n次方根，\frac表示分式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sqrt&#123;x&#125; + \sqrt&#123;x^&#123;2&#125;+\sqrt&#123;y&#125;&#125; = \sqrt[3]&#123;k_&#123;i&#125;&#125; - \frac&#123;x&#125;&#123;m&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bx%7D+++%5Csqrt%7Bx%5E%7B2%7D+%5Csqrt%7By%7D%7D+=+%5Csqrt%5B3%5D%7Bk_%7Bi%7D%7D+-+%5Cfrac%7Bx%7D%7Bm%7D" alt="[公式]"></p><p><strong>上下标记</strong></p><p>命令：\overline, \underline 分别在表达式上、下方画出水平线</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\overline&#123;x+y&#125; \qquad \underline&#123;a+b&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=%5Coverline%7Bx+y%7D%5Cqquad%5Cunderline%7Ba+b%7D" alt="[公式]"></p><p>命令：\overbrace, \underbrace 分别在表达式上、下方给出一个水平的大括号</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\overbrace&#123;1+2+\cdots+n&#125;^&#123;n个&#125; \qquad \underbrace&#123;a+b+\cdots+z&#125;_&#123;26&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=%5Coverbrace%7B1+2+%5Ccdots+n%7D%5E%7Bn%E4%B8%AA%7D+%5Cqquad+%5Cunderbrace%7Ba+b+%5Ccdots+z%7D_%7B26%7D" alt="[公式]"></p><p><strong>向量</strong></p><p>命令：\vec表示向量，\overrightarrow表示箭头向右的向量，\overleftarrow表示箭头向左的向量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;a&#125; + \overrightarrow&#123;AB&#125; + \overleftarrow&#123;DE&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cvec%7Ba%7D+++%5Coverrightarrow%7BAB%7D+++%5Coverleftarrow%7BDE%7D" alt="[公式]"></p><p><strong>积分、极限、求和、乘积</strong></p><p>命令：\int表示积分，\lim表示极限， \sum表示求和，\prod表示乘积，^、_表示上、下限</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$  \lim_&#123;x \to \infty&#125; x^2_&#123;22&#125; - \int_&#123;1&#125;^&#123;5&#125;x\mathrm&#123;d&#125;x + \sum_&#123;n=1&#125;^&#123;20&#125; n^&#123;2&#125; = \prod_&#123;j=1&#125;^&#123;3&#125; y_&#123;j&#125;  + \lim_&#123;x \to -2&#125; \frac&#123;x-2&#125;&#123;x&#125; $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Cto+%5Cinfty%7D+x%5E2_%7B22%7D+-+%5Cint_%7B1%7D%5E%7B5%7Dx+%5Cmathrm%7Bd%7D+x+++%5Csum_%7Bn=1%7D%5E%7B20%7D+n%5E%7B2%7D+=+%5Cprod_%7Bj=1%7D%5E%7B3%7D+y_%7Bj%7D++++%5Clim_%7Bx+%5Cto+-2%7D+%5Cfrac%7Bx-2%7D%7Bx%7D" alt="[公式]"></p><p><strong>三圆点</strong></p><p>命令：\ldots点位于基线上，\cdots点设置为居中，\vdots使其垂直，\ddots对角线排列</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ x_&#123;1&#125;,x_&#123;2&#125;,\ldots,x_&#123;5&#125;  \quad x_&#123;1&#125; + x_&#123;2&#125; + \cdots + x_&#123;n&#125; $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=x_%7B1%7D,x_%7B2%7D,%5Cldots,x_%7B5%7D++%5Cquad+x_%7B1%7D+++x_%7B2%7D+++%5Ccdots+++x_%7Bn%7D" alt="[公式]"></p><p><strong>重音符号</strong></p><p>常用命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \hat&#123;x&#125; $</span><br></pre></td></tr></table></figure><p>效果： <img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D" alt="[公式]"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \bar&#123;x&#125; $</span><br></pre></td></tr></table></figure><p>效果： <img src="https://www.zhihu.com/equation?tex=%5Cbar%7Bx%7D" alt="[公式]"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \tilde&#123;x&#125; $</span><br></pre></td></tr></table></figure><p>效果： <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D" alt="[公式]"></p><p><strong>矩阵</strong></p><p>其采用矩阵环境实现矩阵排列，常用的矩阵环境有matrix、bmatrix、vmatrix、pmatrix，其区别为在于外面的括号不同：</p><p><img src="https://pic1.zhimg.com/80/v2-684e48900e810dff360c23b4ffe99680_720w.jpg" alt="img"></p><p>下列代码中，&amp;用于分隔列，\用于分隔行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; \cdots \\</span><br><span class="line">67 &amp; 95 &amp; \cdots \\</span><br><span class="line">\vdots  &amp; \vdots &amp; \ddots \\</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/matrix.svg" alt="[公式]"></p><p><strong>希腊字母</strong></p><p>希腊字母无法直接通过美式键盘输入获得。在LaTeX中通过反斜杠\加上其字母读音实现，将读音首字母大写即可输入其大写形式，详见下表</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ \alpha^&#123;2&#125; + \beta = \Theta  $$</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://www.zhihu.com/equation?tex=%5Calpha%5E%7B2%7D+++%5Cbeta+=+%5CTheta" alt="[公式]"></p><p><img src="https://pic1.zhimg.com/80/v2-da3e717cf670582fbfbdddee33073524_720w.jpg" alt="img"></p><p><strong>三角函数</strong></p><p><img src="https://pic4.zhimg.com/80/v2-2527327da18ba3cd4d9cfa9483bcbe1f_720w.jpg" alt="img"></p><p><strong>设置颜色</strong></p><p>字体颜色：{\color{色调} 表达式}</p><p>背景颜色：{\pagecolor{色调} 表达式}</p><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$\color&#123;red&#125;&#123;\text red&#125;$</span><br><span class="line">$\color&#123;#FF0000&#125;&#123;\text 红色字\;&#125;$</span><br><span class="line">$\color&#123;rgb(255,255,0)&#125;&#123;黄色字\;&#125;$</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/m0_53793870/article/details/122514409">https://blog.csdn.net/m0_53793870/article/details/122514409</a></p><p><a href="https://zhuanlan.zhihu.com/p/110756681">https://zhuanlan.zhihu.com/p/110756681</a></p><p><a href="https://zhuanlan.zhihu.com/p/261750408?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/261750408?utm_source=wechat_session</a></p><p><a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455">https://blog.csdn.net/mingzhuo_126/article/details/82722455</a></p><p><a href="https://blog.csdn.net/PolarisRisingWar/article/details/121333303">https://blog.csdn.net/PolarisRisingWar/article/details/121333303</a></p><p><a href="https://blog.csdn.net/u013210620/article/details/81938733">https://blog.csdn.net/u013210620/article/details/81938733</a></p><p>LaTeX数学公式 <a href="https://blog.csdn.net/qq_20602929/article/details/50983697">https://blog.csdn.net/qq_20602929/article/details/50983697</a></p><p>Markdown 中 LaTex 数学公式命令 <a href="https://www.jianshu.com/p/0ea47ae02262">https://www.jianshu.com/p/0ea47ae02262</a></p><p>LaTeX新手入门教程（3）数学公式 <a href="https://www.cnblogs.com/GarfieldEr007/p/5536138.html">https://www.cnblogs.com/GarfieldEr007/p/5536138.html</a></p><p>online latex editor <a href="http://latex.codecogs.com/eqneditor/editor.php">http://latex.codecogs.com/eqneditor/editor.php</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作为一个作者，在博客中公式的编辑总是难免的。markdown并不支持数学公式编辑，这些公式仅靠编辑器自带的排版功能是难以表示的，所以需要我们掌握网页公式编辑方案。目前比较流行的网页公式编辑方案是采用TEX/LATEX语法编辑，知名的有MathJax、KATEX。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术流" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%B5%81/"/>
    
    
    <category term="LaTeX" scheme="http://yoursite.com/tags/LaTeX/"/>
    
    <category term="KaTeX" scheme="http://yoursite.com/tags/KaTeX/"/>
    
  </entry>
  
  <entry>
    <title>关于TEX、LATEX、KATEX的关系</title>
    <link href="http://yoursite.com/article/2b2380bd.html"/>
    <id>http://yoursite.com/article/2b2380bd.html</id>
    <published>2022-05-23T07:39:29.000Z</published>
    <updated>2025-10-22T03:11:19.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TEX是一个电子排版系统，它的出现给印刷出版业带来了一场革命。但TEX对于使用者的要求比较高，所以出现了LATEX使得使用者可以更方便的利用TEX的强大功能。KATEX则是一种LATEX的一个快速web数学公式渲染器，使得LATEX的公式可以快速渲染出来。</p></blockquote><a id="more"></a><h2 id="TEX"><a href="#TEX" class="headerlink" title="TEX"></a>TEX</h2><p>说到排版系统不得不提的就是TEX。TEX是一种排版系统，是基于宏的流行的文本格式化程序。它提供了一套功能强大并且十分灵活的排版语言，多达900多条指令，而且有宏功能，用户可以不断地定义自己适用的新命令来扩展TEX系统的功能。<br>TEX系统的排版结果DVI文件与输出设备无关，DVI文件可以显示、打印、照排，几乎可以在所有的输出设备上输出。利用TEX可以很容易地生成高质量的dvi文件，打印输出。<br>它在学术界十分流行，特别是数学、物理学、统计学与计算机科学界。被普遍认为是一个很好的排版工具，特别是在处理复杂的数学公式时。<br>利用TEX提供的宏定义功能可以对TEX进行二次开发。它是包括LaTeX和teTeX在内的其它的此类格式化程序的基础。利用诸如LaTeX等终端软件，TEX就能够排版出精美的文本。通过CTAN上的宏包可以扩展其功能，可以做幻灯片，定义模板。中文支持可以由CCT、CJK、ctex等来完成。<br>TEX有几种常见的格式：</p><p>Plain TEX：TEX的作者设计了Plain TEX的基本格式，以与低层的TEX互应。这种格式是用TEX处理文本时相当基本的部分，以致于我们有时都分不清到底那条指令是真正处理程序TEX的，哪条是这个特殊格式的。Plain TEX也是其他格式的基础，有些人认为TEX和Plain TEX是同一件事。<br>LATEX：Plain TEX的重点还只是在于如何排版的层次上，而不是从一位作者的观点的观点出发。当然对它的深层功能的进一步发掘，需要相当丰富的编程技巧。因此它的应用就需要高级排版和程序设计人员。正是由此种种原因，开发了LATEX格式，这种格式提供了一组生成复杂文档所需的更高级命令。利用这种格式，即使使用者没有排版和程序设计的只是也可以充分发挥由TEX所提供的强大功能。对于生成复杂表格和数学公式，这一点表现得尤为突出。LATEX相对于其基础Plain TEX而言，更像一个包装语言。它可以在作者根本不知道所以然的条件下，自动给出标题，章节，表格目录，交叉索引，公式编号，文献引用，浮动图表。版面布局信息包含在类文件中，这些类文件并不是位于源文件中的。这些布局可以改动，也可以直接采用。<br>LATEX2ϵ \epsilonϵ:由于LATEX相当普及，以及它在许多原本没想象到的领域中的扩展，再加上计算机技术的日新月异，特别是价格低廉，但功能强大的激光打印机的出现，使得相当广泛的一类格式都冠以LATEX的标签。为了尝试建立一个真正的改进标准，创立了LATEX3项目，目标是建立一个最优的，有效的命令集合，这些命令是来自于各种软件包为了实现某一目的而设计出来的。朝向这个目标迈进的第一步是发行了LATEX2ϵ \epsilonϵ。也就是LATEX的当前版本。<br>TEX的优点：</p><p>高质量的输出：TEX遵循传统的排版规则，以排版的质量为最重要的目标。<br>超常的稳定性：自从TEX出现以来，只有一些微小的改动。也就是说，十几年前的TEX文件用现在的TEX系统排版得到的结果与十几年前得到的结果是一样的。稳定性还体现在TEX系统极少会崩溃，可以处理任意大小的文件，即使你的计算机的内存很少，TEX也可自如的工作。<br>TEX是可编程的，TEX是一种宏命令编程语言：你可以用很少的命令来完成非常复杂的工作。如果需要的话，你也可以重新定义TEX的所有命令来得到特殊的效果。<br>高度的灵活性：TEX自从数显以来其内核只有微小的改动。但是由于其内核的设计方式，世界上的TEX使用者可以让TEX做几乎任何工作。你可以用TEX来排版英文文本，也可以排版德文、俄文、中文等多种语言。你还可以用TEX来排版乐谱，象棋，围棋棋谱等等。<br>简单方便TEX文档是ASCII码的文本文件：因此，即使你手边没有TEX系统，你也可以看懂绝大部分内容。TEX文件的这种特点使得它占用很少的存储空间，也可以很方便的用email来传输。<br>目前为止，TEX几乎在所有的计算机操作系统平台上得到实现：如Atari，Apple，Macintosh，Unix，VMS，MS-DOS，MS-Windows和OS/2等等。TEX的源文件可在不同的平台之间自由的交换，而得到的输出是完全相同的。<br>TEX是免费软件，它的源程序也是免费的：你可能仅需要制服邮费，甚至一分不花得得到适合你的TEX系统。<br>超级技术支持：由于TEX并不是被某个公司垄断开发，所以世界各地的使用者设计了统一的技术支持方式。<br>TEX是一种乐趣：使用TEX不仅仅是一种工作手段，也是一种乐趣。它有挑战，也有荣誉。很多人在熟悉TEX之后都开始把使用TEX作为一种爱好，而不是一件枯燥无味的劳动。</p><h2 id="LATEX"><a href="#LATEX" class="headerlink" title="LATEX"></a>LATEX</h2><p>在上面的介绍中已经提到过，LATEX使用TEX作为格式化引擎，当前的版本是LATEX2ϵ \epsilonϵ。<br>LATEX是当今世界上最流行和使用最广泛的TEX宏集。它构筑在Plain TEX的基础上，并加进了很多的功能以使得使用者可以更方便的利用TEX的强大功能。<br>使用LATEX基本不需要使用者自己设计命令和宏等。因为LATEX已经替你做好了。因此，即使使用者并不是很了解TEX，也可以在短短的时间内生成高质量的文档。对于生成复杂的数学公式，LATEX表现的更为出色。</p><p>也就是说，LATEX是TEX中的一种格式，是建立在TEX基础上的宏语言，每一个LATEX命令实际上最后都会被转换解释称几个甚至上百个TEX命令。但是，普通用户可以无需知道这中间复杂的联系。就像变成的时候如果使用一些已经编译好的函数库和模版可以使我们仅仅用几个命令就实现很多功能一样。LATEX根据人们排版文章的习惯，定义了许多命令和模版，我们可以很快的得到漂亮的排版结果。</p><blockquote><p>一份不太简短的 LaTeX2ε 介绍【中文资料】（lshort中文版 <a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf%EF%BC%89">https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf）</a><br>LaTeX for Complete Novices【英文资料】（pdf, 源代码, <a href="http://www.dickimaw-books.com/latex/novices/%EF%BC%89">http://www.dickimaw-books.com/latex/novices/）</a><br>黄正华老师 LaTeX 教学首页.<a href="http://aff.whu.edu.cn/huangzh/">http://aff.whu.edu.cn/huangzh/</a></p></blockquote><h2 id="KATEX"><a href="#KATEX" class="headerlink" title="KATEX"></a>KATEX</h2><p>KaTeX： 可汗学院出品，号称“最快”的数学公式渲染库，支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8~IE11。</p><p>KATEX是一个web数学公式渲染器。我们日常写博客用的markdown并不支持数学公式编辑，这些公式仅靠编辑器自带的排版功能是难以表示的，所以需要掌握网页公式编辑方案。<br>目前比较流行的网页公式编辑方案是采用TEX/LATEX语法编辑，知名的有MathJax、KATEX。与前者相比，KATEX方案的渲染速度高，虽然支持不够全面，但仍能满足大多数的使用环境。<br>我们可以在KATEX官网来在线渲染我们写好的LATEX公式，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190817152527198.png" alt="在这里插入图片描述"></p><h2 id="LaTeX写作软件"><a href="#LaTeX写作软件" class="headerlink" title="LaTeX写作软件"></a>LaTeX写作软件</h2><p>LaTeX（LTEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统</p><p>1.一款Latex在线编辑器<br><a href="https://www.overleaf.com/">https://www.overleaf.com/</a><br>Latex常用模版<br><a href="https://www.overleaf.com/latex/templates">https://www.overleaf.com/latex/templates</a></p><p>2.新一代LaTeX协作平台<br><a href="https://www.slager.cn/#/Home">https://www.slager.cn/#/Home</a></p><p>3.TeX Live 是 TUG (TeX User Group) 发布并维护的的 TeX 系统，可以称得上是TeX的官方系统。对于任何阶段的TeX用户，都可以使用TeX Live， 以保持在跨操作系统、跨用户的TeX文件一致性。</p><p><a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></p><h2 id="关于CTAN"><a href="#关于CTAN" class="headerlink" title="关于CTAN"></a>关于CTAN</h2><p>CTAN是“Comprehensive TeX Archive Network”的首字缩写，为世界上最主要的TeX资源集散网站，搜集了关于TeX的各种文件与软件等等。Perl的资源集散网站CPAN即是基于<em>CTAN</em>的模式诞生与运作。</p><p><a href="https://ctan.org/">https://ctan.org/</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;TEX是一个电子排版系统，它的出现给印刷出版业带来了一场革命。但TEX对于使用者的要求比较高，所以出现了LATEX使得使用者可以更方便的利用TEX的强大功能。KATEX则是一种LATEX的一个快速web数学公式渲染器，使得LATEX的公式可以快速渲染出来。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术流" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%B5%81/"/>
    
    
    <category term="TeX" scheme="http://yoursite.com/tags/TeX/"/>
    
    <category term="LaTeX" scheme="http://yoursite.com/tags/LaTeX/"/>
    
    <category term="KaTeX" scheme="http://yoursite.com/tags/KaTeX/"/>
    
  </entry>
  
  <entry>
    <title>SMB通信协议</title>
    <link href="http://yoursite.com/article/67e1ad8.html"/>
    <id>http://yoursite.com/article/67e1ad8.html</id>
    <published>2022-05-21T07:27:06.000Z</published>
    <updated>2025-10-22T03:11:19.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。</p></blockquote><a id="more"></a><ul><li>samba</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">2.安装 samba</span><br><span class="line">sudo apt-get install samba</span><br><span class="line">3. 创建共享文件夹</span><br><span class="line">mkdir 777 /home/share</span><br><span class="line">4. 修改共享文件夹权限</span><br><span class="line">chmod 777 /home/share</span><br><span class="line">5. 编辑smb.conf</span><br><span class="line">vim /etc/samba/smb.conf (先检查vim是否安装，如果没有安装先安装sudo apt-get install vim)</span><br><span class="line">在文档的最后加入</span><br><span class="line">[share]</span><br><span class="line">path=/home/share</span><br><span class="line">available=yes</span><br><span class="line">browseable=yes</span><br><span class="line">public=yes</span><br><span class="line">writable=yes //这条只表明客户端可以创建文件并且能修改,但是却不能修改服务端创建出来的文件.</span><br><span class="line"></span><br><span class="line">6.重启samba服务</span><br><span class="line">service smbd restart</span><br><span class="line">7. 访问</span><br><span class="line">windows中，win+r 输入\ip</span><br><span class="line">或在工作组计算机中找到ubuntu主机即可访问</span><br><span class="line">ubuntu中，connect to server smb://ip/即可访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原因是客户端创建出来的文件所属user是nobdoy, group是nogroup, 而服务端的user/group是kris/kris.</span><br><span class="line">两个不同用户和不同组不能相互修改.</span><br><span class="line"></span><br><span class="line">网上资料一般提供的方法都是直接将共享目录下的所有文件权限修改:</span><br><span class="line"><span class="comment"># chmod -R 777 /home/kris</span></span><br><span class="line"></span><br><span class="line">可是如果使用git,这种情况下用git status去查看会是一片红啊!</span><br><span class="line">而且如果服务端再新增文件呢,又要去改权限...</span><br><span class="line"></span><br><span class="line">其实smb.conf提供了另外一个配置叫force user, 它表示客户端默认创建的文件所属用户,</span><br><span class="line">只要和服务端设置成一样,那么就直接可以创建和修改所有文件了.</span><br><span class="line"></span><br><span class="line">最终添加的配置如下:</span><br><span class="line">[kris]</span><br><span class="line">comment=<span class="string">&quot;Kris&#x27;s Home&quot;</span></span><br><span class="line">path=/home/kris</span><br><span class="line">available = yes</span><br><span class="line">browseable = yes</span><br><span class="line">public = yes</span><br><span class="line">writable = yes</span><br><span class="line">create mask = 0644    //创建文件属性</span><br><span class="line">force user = kris    //和服务端用户一样</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术流" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%B5%81/"/>
    
    
    <category term="Samba" scheme="http://yoursite.com/tags/Samba/"/>
    
  </entry>
  
  <entry>
    <title>关于应用容器引擎Docker</title>
    <link href="http://yoursite.com/article/9ca11197.html"/>
    <id>http://yoursite.com/article/9ca11197.html</id>
    <published>2022-05-21T07:20:58.000Z</published>
    <updated>2025-10-22T03:11:19.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker 是一个开源的应用容器引擎，优点是开箱即用，快速部署，可移植性强，环境隔离。</p></blockquote><a id="more"></a><p>Docker三要素</p><ul><li>镜像(Image) : </li></ul><p>​    Docker 镜像就是一个只读的模板，镜像可以用来创建Docker容器。Docker提供了一个很简单的机制来创建镜    像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。镜像是一种文    件结构。Dockerfile中的每条命令都会在文件系统中创建一个新的层次结构，文件系统在这些层次上构建起来，    镜像就构建于这些联合的文件系统之上。Docker官方网站专门有一个页面来存储所有可用的镜像，</p><p>​    网址是: index.docker.io。</p><ul><li><p>容器( Container)</p><p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的Linux环境，Docker利用容器来运行应用。</p></li><li><p>仓库(Repository)</p><p>仓库是集中存放镜像文件的场所,仓库注册服务器(Registry)上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)。目前，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，优点是开箱即用，快速部署，可移植性强，环境隔离。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术流" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%B5%81/"/>
    
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>OpenAPI的介绍及其使用</title>
    <link href="http://yoursite.com/article/f7f06827.html"/>
    <id>http://yoursite.com/article/f7f06827.html</id>
    <published>2022-05-19T02:16:29.000Z</published>
    <updated>2025-10-22T03:11:19.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>API的全称是应用编程接口（Application Programming Interface），这并不是一个新概念，在计算机操作系统出现的早期就已经存在了。在互联网时代，把网站的服务封装成一系列计算机易识别的数据接口开放出去，供第三方开发者使用，这种行为就叫做开放网站的API，与之对应的，所开放的API就被称作openAPI。</p></blockquote><a id="more"></a><h2 id="OSCHINA-API的使用"><a href="#OSCHINA-API的使用" class="headerlink" title="OSCHINA API的使用"></a>OSCHINA API的使用</h2><p>OSCHINA API：<a href="https://www.oschina.net/openapi/docs">https://www.oschina.net/openapi/docs</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 什么是token</span><br><span class="line">token（令牌）是一串唯一的字符串，通常由服务端生成，在注册完成时返回给客户端，用来标识此用户，客户端将此字符串存储在本地。在以后的网络请求时，客户端先查询本地的token，如果有则直接使用此令牌进行网络请求，没有则提示未登录，转到登陆注册界面。</span><br><span class="line">此外，还可以在服务端或者客户端添加过期判别机制。</span><br><span class="line"></span><br><span class="line">- token的作用</span><br><span class="line">token可以显著减少服务端对用户表的查询，同时使用户不必每次都登陆，提高了系统的可用性与健壮性。</span><br><span class="line"></span><br><span class="line">- 使用SharedPreferences保存token</span><br></pre></td></tr></table></figure><p>1.创建应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态正在审核</span><br><span class="line">应用IDGCqPUbrIaoe7nUScRlet</span><br><span class="line">应用私钥YFJDhiYsnyI6qW8nzdAHYIPocZsPEff1</span><br><span class="line">应用首页https://fangjian98.github.io/    </span><br><span class="line">回调地址http://192.168.0.106/</span><br></pre></td></tr></table></figure><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/oschina_api.png" alt="OSCHINA API"></p><p>2.OAuth2 获取 AccessToken，应用通过 AccessToken 访问 OpenApi 使用用户数据。<br>采用 OAuth2 协议 认证，开放 osc 移动 app 版本所有接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line"><span class="comment"># 用户授权码的回调地址直接获取code</span></span><br><span class="line"><span class="comment"># 构造Uri：/action/oauth2/authorize</span></span><br><span class="line"><span class="comment"># client_id(应用ID)和redirect_uri(回调地址)</span></span><br><span class="line">https://www.oschina.net/action/oauth2/authorize?response_type=code&amp;client_id=GCqPUbrIaoe7nUScRlet&amp;redirect_uri=http://192.168.0.106/</span><br><span class="line"><span class="comment"># 返回用户授权码code</span></span><br><span class="line">http://192.168.0.106/?code=iap9LL&amp;state=</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line"><span class="comment"># 应用服务器使用 oauth2_token API 向 OSChina 认证服务器发送用户授权码以及回调地址，OSChina 认证服务器返回 AccessToken</span></span><br><span class="line"><span class="comment"># 构造Uri:/action/openapi/token</span></span><br><span class="line"><span class="comment"># client_id(应用ID)和redirect_uri(回调地址)和client_secret(应用私钥)和code(用户授权码)</span></span><br><span class="line">https://www.oschina.net/action/openapi/token?client_id=GCqPUbrIaoe7nUScRlet&amp;client_secret=YFJDhiYsnyI6qW8nzdAHYIPocZsPEff1&amp;grant_type=authorization_code&amp;code=pZ6Ye2&amp;redirect_uri=http://192.168.0.106/&amp;dataType=json</span><br><span class="line"><span class="comment"># 返回AccessToken</span></span><br><span class="line">&#123;<span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;09a10176-7772-4577-8856-1b396f86e83b&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;da728b79-3b0d-4062-961b-bd67c09ecbcd&quot;</span>,<span class="string">&quot;uid&quot;</span>:4470181,<span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,<span class="string">&quot;expires_in&quot;</span>:604799&#125;</span><br><span class="line"></span><br><span class="line">3.使用AccessToken请求：参考OpenAPI文档即可</span><br><span class="line"><span class="comment"># 新闻news_list</span></span><br><span class="line"><span class="comment"># 构造Uri:/action/openapi/news_list</span></span><br><span class="line"><span class="comment"># access_token catalog page pageSize dataType</span></span><br><span class="line">https://www.oschina.net/action/openapi/news_list?access_token=09a10176-7772-4577-8856-1b396f86e83b&amp;catalog=2&amp;page=1&amp;pageSize=10&amp;dataType=json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">必选类型及范围说明默认值</span><br><span class="line">access_token<span class="literal">true</span>stringoauth2_token获取的access_token</span><br><span class="line">catalog<span class="literal">true</span>int1-所有|2-综合新闻|3-软件更新1</span><br><span class="line">page/pageIndex<span class="literal">true</span>int页数1</span><br><span class="line">pageSize<span class="literal">true</span>int每页条数20</span><br><span class="line">dataType<span class="literal">true</span>string返回数据类型[<span class="string">&#x27;json&#x27;</span>|<span class="string">&#x27;jsonp&#x27;</span>|<span class="string">&#x27;xml&#x27;</span>]json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新闻news_detail</span></span><br><span class="line"><span class="comment"># 构造Uri:/action/openapi/news_detail</span></span><br><span class="line"><span class="comment"># id access_token</span></span><br><span class="line">https://www.oschina.net/action/openapi/news_detail?id=188164&amp;access_token=6983b81e-5e2e-4685-888f-36abcf3f2da7&amp;dataType=json</span><br><span class="line"></span><br><span class="line">必选类型及范围说明默认值</span><br><span class="line">id<span class="literal">true</span>long新闻编号空</span><br><span class="line">access_token<span class="literal">false</span>stringoauth2_token获取的access_token 传则显示是否收藏 用户未登录则不传</span><br><span class="line">dataType<span class="literal">false</span>string返回数据类型 [<span class="string">&#x27;json&#x27;</span>|<span class="string">&#x27;jsonp&#x27;</span>|<span class="string">&#x27;xml&#x27;</span>]json</span><br></pre></td></tr></table></figure><h2 id="其他平台开放API"><a href="#其他平台开放API" class="headerlink" title="其他平台开放API"></a>其他平台开放API</h2><ul><li>CODING OPEN API：<a href="https://help.coding.net/openapi">https://help.coding.net/openapi</a></li><li>有道云笔记API：<a href="http://note.youdao.com/open/index.html">http://note.youdao.com/open/index.html</a></li><li><a href="https://www.cnblogs.com/trackingmore/p/7156877.html">常用精品API接口汇总</a></li></ul><h2 id="Json解析"><a href="#Json解析" class="headerlink" title="Json解析"></a>Json解析</h2><p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON格式取代了xml给网络传输带来了很大的便利，是最常见的数据返回类型。</p><p>常见的Json解析库</p><ul><li>org.json库</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Android给我们提供的Json解析类，官方提供的JSONArray与JSONObject</span><br><span class="line">这些API都存在于org.json包下，而我们用到的类有下面这些：</span><br><span class="line">JSONObject： Json对象，可以完成Json字符串与Java对象的相互转换</span><br><span class="line">JSONArray： Json数组，可以完成Json字符串与Java集合或对象的相互转换</span><br><span class="line">JSONStringer： Json文本构建类，这个类可以帮助快速和便捷的创建JSON text， 每个</span><br><span class="line">JSONStringer实体只能对应创建一个JSON text</span><br><span class="line">JSONTokener：Json解析类</span><br><span class="line">JSONException：Json异常</span><br></pre></td></tr></table></figure><ul><li>fastjson</li><li>gson</li></ul><blockquote><p>[1] <a href="https://www.cnblogs.com/lushimei/p/13436096.html">https://www.cnblogs.com/lushimei/p/13436096.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;API的全称是应用编程接口（Application Programming Interface），这并不是一个新概念，在计算机操作系统出现的早期就已经存在了。在互联网时代，把网站的服务封装成一系列计算机易识别的数据接口开放出去，供第三方开发者使用，这种行为就叫做开放网站的API，与之对应的，所开放的API就被称作openAPI。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java的反射机制</title>
    <link href="http://yoursite.com/article/5337b80a.html"/>
    <id>http://yoursite.com/article/5337b80a.html</id>
    <published>2022-05-18T11:40:14.000Z</published>
    <updated>2025-10-22T03:11:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。Java 的这一能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一特性。</p></blockquote><a id="more"></a><h2 id="Java的类加载"><a href="#Java的类加载" class="headerlink" title="Java的类加载"></a>Java的类加载</h2><ul><li>编译：java文件编译后生成class字节码文件</li><li>类加载机制：JVM把class文件加载到内存，并对数据进行校验、准备、解析、初始化，最终形成JVM可以直接使用的Java类型的过程。<br><img src="https://img-blog.csdnimg.cn/cc40b19fbce5410f877a062d3f225fca.png" alt="类加载机制"><h2 id="Java的反射机制"><a href="#Java的反射机制" class="headerlink" title="Java的反射机制"></a>Java的反射机制</h2>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取、调用对象方法的功能称为Java语言的反射机制。</li></ul><p>Java的反射就是利用上面第二步加载到JVM中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。</p><p>总体来说，反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。例如一个类有成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><blockquote><p>反射的必要性：<br>1.反射机制是很多java框架的基石。<br>2.有时候要适应某些需求，Java类里面不一定能直接调用另外的方法，这时候也可以通过反射机制来实现。</p><p>反射的缺点：<br>反射的代码比正常调用的代码更多，性能也慢，所以应避免使用反射。</p></blockquote><h2 id="Java反射获取对象"><a href="#Java反射获取对象" class="headerlink" title="Java反射获取对象"></a>Java反射获取对象</h2><blockquote><p>Class类：代表一个类<br>Constructor类：代表类的构造方法<br>Field类：代表类的成员变量（类的属性）<br>Method类：代表类的方法</p></blockquote><h3 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获取Class对象的三种方式</span><br><span class="line"><span class="number">1.</span>通过对象获取      对象名.getClass()</span><br><span class="line"><span class="number">2.</span>通过类名获取      类名.class </span><br><span class="line"><span class="number">3.</span>通过全类名获取    Class.forName(全类名)   </span><br><span class="line"></span><br><span class="line">三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三中方式获取Class对象</span></span><br><span class="line">Class stuClass = Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">System.out.println(stuClass.getName());</span><br></pre></td></tr></table></figure><h3 id="2-获取Constructor构造方法对象"><a href="#2-获取Constructor构造方法对象" class="headerlink" title="2.获取Constructor构造方法对象"></a>2.获取Constructor构造方法对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>获取构造方法：</span><br><span class="line"><span class="number">1</span>).批量的方法：</span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors()：所有<span class="string">&quot;公有的&quot;</span>构造方法</span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line">     </span><br><span class="line"><span class="number">2</span>).获取单个的方法，并调用：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span>:获取单个的&quot;公有的&quot;构造方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>:获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">调用构造方法：</span></span><br><span class="line"><span class="function">Constructor--&gt;<span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2.newInstance是 Constructor类的方法（管理构造函数的类）</span></span><br><span class="line"><span class="function">api的解释为：<span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function">使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</span></span><br><span class="line"><span class="function">它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3.Constructor con </span>= clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">1</span>)因为是无参的构造方法所以类型是一个<span class="keyword">null</span>,不写也可以：这里需要的是一个参数的类型，切记是类型</span><br><span class="line"><span class="number">2</span>)返回的是描述这个无参构造函数的类对象。</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1.加载Class对象</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);</span><br><span class="line">Constructor  con = clazz.getDeclaredConstructor(<span class="keyword">char</span>.class);</span><br><span class="line">System.out.println(con);</span><br><span class="line"><span class="comment">//调用构造方法</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"><span class="comment">//Student stu = (Student)obj;</span></span><br></pre></td></tr></table></figure><h3 id="3-获取Field成员变量对象"><a href="#3-获取Field成员变量对象" class="headerlink" title="3.获取Field成员变量对象"></a>3.获取Field成员变量对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">获取成员变量并调用：</span><br><span class="line"><span class="number">1.</span>批量的</span><br><span class="line">Field[] getFields():获取所有的<span class="string">&quot;公有字段&quot;</span></span><br><span class="line">Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span><br><span class="line"><span class="number">2.</span>获取单个的：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String fieldName)</span>:获取某个&quot;公有的&quot;字段；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String fieldName)</span>:获取某个字段<span class="params">(可以是私有的)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">设置字段的值：</span></span><br><span class="line"><span class="function">Field --&gt; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj,Object value)</span>:</span></span><br><span class="line"><span class="function">第一个参数：要传入设置的对象，第二个参数：要传入实参</span></span><br><span class="line"><span class="function">参数说明：</span></span><br><span class="line"><span class="function">1.obj:要设置的字段所在的对象；</span></span><br><span class="line"><span class="function">2.value:要为字段设置的值；</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//1.获取Class对象</span></span></span><br><span class="line"><span class="function">Class stuClass </span>= Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);</span><br><span class="line">Field f = stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//获取一个对象</span></span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();<span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line"><span class="comment">//为字段设置值</span></span><br><span class="line">f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line"><span class="comment">//验证</span></span><br><span class="line">Student stu = (Student)obj;</span><br><span class="line">System.out.println(<span class="string">&quot;验证姓名：&quot;</span> + stu.name);</span><br></pre></td></tr></table></figure><h3 id="4-获取Method成员方法对象"><a href="#4-获取Method成员方法对象" class="headerlink" title="4.获取Method成员方法对象"></a>4.获取Method成员方法对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">获取成员方法并调用：</span><br><span class="line"><span class="number">1.</span>批量的：</span><br><span class="line"><span class="keyword">public</span> Method[] getMethods():获取所有<span class="string">&quot;公有方法&quot;</span>；（包含了父类的方法也包含Object类）</span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span><br><span class="line"><span class="number">2.</span>获取单个的：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name,Class&lt;?&gt;... parameterTypes)</span>:</span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">name : 方法名；</span></span><br><span class="line"><span class="function">Class ... : 形参的Class类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name,Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">调用方法：</span></span><br><span class="line"><span class="function">Method --&gt; <span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj,Object... args)</span>:</span></span><br><span class="line"><span class="function">参数说明：</span></span><br><span class="line"><span class="function">obj : 要调用方法的对象；</span></span><br><span class="line"><span class="function">args:调用方式时所传递的实参；</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//1.获取Class对象</span></span></span><br><span class="line"><span class="function">Class stuClass </span>= Class.forName(<span class="string">&quot;com.example.Student&quot;</span>);</span><br><span class="line">Method m = stuClass.getMethod(<span class="string">&quot;show1&quot;</span>, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">//m.setAccessible(true);//解除私有限定</span></span><br><span class="line"><span class="comment">//实例化一个Student对象</span></span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">Object result = m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);</span><br></pre></td></tr></table></figure><blockquote><p>[1] <a href="https://www.cnblogs.com/tech-bird/p/3525336.html">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。Java 的这一能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一特性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Reflection" scheme="http://yoursite.com/tags/Reflection/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Android多线程使用</title>
    <link href="http://yoursite.com/article/123e7dd4.html"/>
    <id>http://yoursite.com/article/123e7dd4.html</id>
    <published>2022-05-18T10:34:22.000Z</published>
    <updated>2025-10-22T03:11:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程的应用在开发中非常常见。</p></blockquote><a id="more"></a><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>Android多线程实现的基础使用包括：</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>Handler</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><img src="https://img-blog.csdnimg.cn/2019111311265420.png" alt="继承Thread类"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 步骤1：创建线程类 （继承自Thread类）</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：复写run（），内容 = 定义线程行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ... <span class="comment">// 定义的线程行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤3：创建线程对象，即 实例化线程类</span></span><br><span class="line">  MyThread mt=<span class="keyword">new</span> MyThread(“线程名称”);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤4：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止</span></span><br><span class="line">    <span class="comment">// 此处采用 start（）开启线程</span></span><br><span class="line">  mt.start();</span><br></pre></td></tr></table></figure><p>开发者会选择一种更加方便的方法去创建线程：匿名类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：采用匿名类，直接 创建 线程类的实例</span></span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="string">&quot;线程名称&quot;</span>) &#123;</span><br><span class="line">                 <span class="comment">// 步骤2：复写run（），内容 = 定义线程行为</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">                  <span class="comment">// 步骤3：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止   </span></span><br><span class="line">                      &#125;.start();</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><img src="https://img-blog.csdnimg.cn/20191113141230159.png" alt="实现Runnable接口"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 步骤1：创建线程辅助类，实现Runnable接口</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 步骤2：复写run（），定义线程行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤3：创建线程辅助对象，即 实例化 线程辅助类</span></span><br><span class="line">  MyThread mt=<span class="keyword">new</span> MyThread();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤4：创建线程对象，即 实例化线程类；线程类 = Thread类；</span></span><br><span class="line">    <span class="comment">// 创建时通过Thread类的构造函数传入线程辅助类对象</span></span><br><span class="line">    <span class="comment">// 原因：Runnable接口并没有任何对线程的支持，我们必须创建线程类（Thread类）的实例，从Thread类的一个实例内部运行</span></span><br><span class="line">  Thread td=<span class="keyword">new</span> Thread(mt);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤5：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止</span></span><br><span class="line">    <span class="comment">// 当调用start（）方法时，线程对象会自动回调线程辅助类对象的run（），从而实现线程操作</span></span><br><span class="line">  td.start();</span><br></pre></td></tr></table></figure><p>开发者会选择一种更加方便的方法去创建线程：匿名类  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：通过匿名类 直接 创建线程辅助对象，即 实例化 线程辅助类</span></span><br><span class="line">    Runnable mt = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="comment">// 步骤2：复写run（），定义线程行为</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 步骤3：创建线程对象，即 实例化线程类；线程类 = Thread类；</span></span><br><span class="line">                Thread mt1 = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">           </span><br><span class="line">                <span class="comment">// 步骤4：通过 线程对象 控制线程的状态，如 运行、睡眠、挂起  / 停止</span></span><br><span class="line">                mt1.start();</span><br></pre></td></tr></table></figure><blockquote><p>Java中真正能创建新线程的只有Thread类对象，通过实现Runnable的方式，最终还是通过Thread类对象来创建线程，所以对于实现了Runnable接口的类，称为线程辅助类；Thread类才是真正的线程类。</p></blockquote><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><img src="https://img-blog.csdnimg.cn/20191113165713433.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20191113165928918.png" alt="在这里插入图片描述"></p><p>Handler的使用方式 因发送消息到消息队列的方式不同而不同，共分为2种：使用Handler.sendMessage（）、使用Handler.post（）</p><p>Handler.sendMessage（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">      * 方式1：新建Handler子类（内部类）</span><br><span class="line">      *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 步骤1：自定义Handler子类（继承Handler类） &amp; 复写handleMessage（）方法</span><br><span class="line">    class mHandler extends Handler &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 通过复写handlerMessage() 从而确定更新UI的操作</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">         ...&#x2F;&#x2F; 需执行的UI操作</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤2：在主线程中创建Handler实例</span><br><span class="line">        private Handler mhandler &#x3D; new mHandler();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤3：创建所需的消息对象</span><br><span class="line">        Message msg &#x3D; Message.obtain(); &#x2F;&#x2F; 实例化消息对象</span><br><span class="line">        msg.what &#x3D; 1; &#x2F;&#x2F; 消息标识</span><br><span class="line">        msg.obj &#x3D; &quot;AA&quot;; &#x2F;&#x2F; 消息内容存放</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span><br><span class="line">    &#x2F;&#x2F; 可通过sendMessage（） &#x2F; post（）</span><br><span class="line">    &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 步骤5：开启工作线程（同时启动了Handler）</span><br><span class="line">    &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;** </span><br><span class="line">  * 方式2：匿名内部类</span><br><span class="line">  *&#x2F;</span><br><span class="line">   &#x2F;&#x2F; 步骤1：在主线程中 通过匿名内部类 创建Handler类对象</span><br><span class="line">            private Handler mhandler &#x3D; new  Handler()&#123;</span><br><span class="line">                &#x2F;&#x2F; 通过复写handlerMessage()从而确定更新UI的操作</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(Message msg) &#123;</span><br><span class="line">                        ...&#x2F;&#x2F; 需执行的UI操作</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 步骤2：创建消息对象</span><br><span class="line">    Message msg &#x3D; Message.obtain(); &#x2F;&#x2F; 实例化消息对象</span><br><span class="line">      msg.what &#x3D; 1; &#x2F;&#x2F; 消息标识</span><br><span class="line">      msg.obj &#x3D; &quot;AA&quot;; &#x2F;&#x2F; 消息内容存放</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 步骤3：在工作线程中 通过Handler发送消息到消息队列中</span><br><span class="line">  &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br><span class="line">   mHandler.sendMessage(msg);</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 步骤4：开启工作线程（同时启动了Handler）</span><br><span class="line">  &#x2F;&#x2F; 多线程可采用AsyncTask、继承Thread类、实现Runnable</span><br></pre></td></tr></table></figure><blockquote><p>警告提示：This Handler class should be static or leaks might occur (anonymous android.os.Handler)</p><p>官方解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></blockquote><p>Handler.post（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：在主线程中创建Handler实例</span></span><br><span class="line">    <span class="keyword">private</span> Handler mhandler = <span class="keyword">new</span> mHandler();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容</span></span><br><span class="line">    <span class="comment">// 需传入1个Runnable对象</span></span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ... <span class="comment">// 需执行的UI操作 </span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤3：开启工作线程（同时启动了Handler）</span></span><br><span class="line">    <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br></pre></td></tr></table></figure><h2 id="复合使用"><a href="#复合使用" class="headerlink" title="复合使用"></a>复合使用</h2><p>Android多线程实现的复合使用包括：</p><ul><li>AsyncTask</li><li>HandlerThread</li><li>IntentService</li></ul><p>称为”复用“的主要原因是：这3种方式的本质原理都是Android多线程基础实现（继承Thread类、实现Runnable接口、Handler）的组合实现。下面，我将详细讲解。</p><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p><img src="https://img-blog.csdnimg.cn/20191119160207922.png" alt="AsyncTask"></p><blockquote><p>AsyncTask类属于抽象类，即使用时需实现子类</p><p>AsyncTask的使用步骤</p><ol><li>创建 AsyncTask 子类 &amp; 根据需求实现核心方法</li><li>创建 AsyncTask子类的实例对象（即 任务实例）</li><li>手动调用execute(（）从而执行异步线程任务</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 步骤1：创建AsyncTask子类</span></span><br><span class="line"><span class="comment">  * 注： </span></span><br><span class="line"><span class="comment">  *   a. 继承AsyncTask类</span></span><br><span class="line"><span class="comment">  *   b. 为3个泛型参数指定类型；若不使用，可用java.lang.Void类型代替</span></span><br><span class="line"><span class="comment">  *   c. 根据需求，在AsyncTask子类内实现核心方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        ....</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法1：onPreExecute（）</span></span><br><span class="line">      <span class="comment">// 作用：执行 线程任务前的操作</span></span><br><span class="line">      <span class="comment">// 注：根据需求复写</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法2：doInBackground（）</span></span><br><span class="line">      <span class="comment">// 作用：接收输入参数、执行任务中的耗时操作、返回 线程任务执行的结果</span></span><br><span class="line">      <span class="comment">// 注：必须复写，从而自定义线程任务</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            ...<span class="comment">// 自定义的线程任务</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（）</span></span><br><span class="line">             publishProgress(count);</span><br><span class="line">              </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法3：onProgressUpdate（）</span></span><br><span class="line">      <span class="comment">// 作用：在主线程 显示线程任务执行的进度</span></span><br><span class="line">      <span class="comment">// 注：根据需求复写</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progresses)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法4：onPostExecute（）</span></span><br><span class="line">      <span class="comment">// 作用：接收线程任务执行结果、将执行结果显示到UI组件</span></span><br><span class="line">      <span class="comment">// 注：必须复写，从而自定义UI操作</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         ...<span class="comment">// UI操作</span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 方法5：onCancelled()</span></span><br><span class="line">      <span class="comment">// 作用：将异步任务设置为：取消状态</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 步骤2：创建AsyncTask子类的实例对象（即 任务实例）</span></span><br><span class="line"><span class="comment">  * 注：AsyncTask子类的实例必须在UI线程中创建</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  MyTask mTask = <span class="keyword">new</span> MyTask();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 步骤3：手动调用execute(Params... params) 从而执行异步线程任务</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *    a. 必须在UI线程中调用</span></span><br><span class="line"><span class="comment">  *    b. 同一个AsyncTask实例对象只能执行1次，若执行第2次将会抛出异常</span></span><br><span class="line"><span class="comment">  *    c. 执行任务中，系统会自动调用AsyncTask的一系列方法：onPreExecute() 、doInBackground()、onProgressUpdate() 、onPostExecute() </span></span><br><span class="line"><span class="comment">  *    d. 不能手动调用上述方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  mTask.execute()；</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191119161139902.png" alt="AsyncTask参数"></p><h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p><img src="https://img-blog.csdnimg.cn/20191119173637458.png" alt="HandlerThread"></p><p>HandlerThread的本质：继承Thread类 &amp; 封装Handler类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">   HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">   mHandlerThread.start();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">  Handler workHandler = <span class="keyword">new</span> Handler( handlerThread.getLooper() ) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                ...<span class="comment">//消息处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤4：使用工作线程Handler向工作线程的消息队列发送消息</span></span><br><span class="line"><span class="comment">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line">  <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">  Message msg = Message.obtain();</span><br><span class="line">  msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">  msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">  <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">  workHandler.sendMessage(msg);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">  mHandlerThread.quit();</span><br></pre></td></tr></table></figure><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>Android里的一个封装类，继承四大组件之一的Service</p><blockquote><p>作用：处理异步请求 &amp; 实现多线程<br>使用场景：线程任务需按顺序、在后台执行</p><ul><li>最常见的场景：离线下载</li><li>不符合多个数据同时请求的场景：所有的任务都在同一个Thread looper里执行</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：定义 IntentService的子类:传入线程名称、复写onHandleIntent()方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 在构造函数中传入线程名字</span></span><br><span class="line"><span class="comment">    **/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="comment">// 参数 = 工作线程的名字</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;myIntentService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onHandleIntent()方法</span></span><br><span class="line"><span class="comment">     * 根据 Intent实现 耗时任务 操作</span></span><br><span class="line"><span class="comment">     **/</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根据 Intent的不同，进行不同的事务处理</span></span><br><span class="line">        String taskName = intent.getExtras().getString(<span class="string">&quot;taskName&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (taskName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;task1&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;do task1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;task2&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;do task2&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onStartCommand()方法</span></span><br><span class="line"><span class="comment">     * 默认实现 = 将请求的Intent添加到工作队列里</span></span><br><span class="line"><span class="comment">     **/</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onStartCommand&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onDestroy&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">2</span>：在Manifest.xml中注册服务</span><br><span class="line">&lt;service android:name=<span class="string">&quot;.myIntentService&quot;</span>&gt;</span><br><span class="line">            &lt;intent-filter &gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;cn.scu.finch&quot;</span>/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;    </span><br><span class="line">                    </span><br><span class="line">步骤<span class="number">3</span>：在Activity中开启Service服务</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 同一服务只会开启1个工作线程</span></span><br><span class="line">            <span class="comment">// 在onHandleIntent（）函数里，依次处理传入的Intent请求</span></span><br><span class="line">            <span class="comment">// 将请求通过Bundle对象传入到Intent，再传入到服务里</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 请求1</span></span><br><span class="line">            Intent i = <span class="keyword">new</span> Intent(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task1&quot;</span>);</span><br><span class="line">            i.putExtras(bundle);</span><br><span class="line">            startService(i);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 请求2</span></span><br><span class="line">            Intent i2 = <span class="keyword">new</span> Intent(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            Bundle bundle2 = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle2.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line">            i2.putExtras(bundle2);</span><br><span class="line">            startService(i2);</span><br><span class="line"> </span><br><span class="line">            startService(i);  <span class="comment">//多次启动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="线程池（ThreadPool）"><a href="#线程池（ThreadPool）" class="headerlink" title="线程池（ThreadPool）"></a>线程池（ThreadPool）</h3><p><img src="https://img-blog.csdnimg.cn/20191119184102293.png" alt="ThreadPool"></p><p>1、ThreadPoolExecutor 创建基本线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建基本线程池</span></span><br><span class="line"><span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本线程池使用:设置一个按钮mThreadPoolExecute，并在点击事件中使用线程池</span></span><br><span class="line"> mThreadPoolExecute.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> finali = i;</span><br><span class="line">                    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                                Log.d(<span class="string">&quot;Thread&quot;</span>, <span class="string">&quot;run: &quot;</span>+finali);</span><br><span class="line">                                Log.d(<span class="string">&quot;当前线程：&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    threadPoolExecutor.execute(runnable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>其他几种常见的线程池</strong></p><p><img src="https://img-blog.csdnimg.cn/20191119185404571.png" alt="在这里插入图片描述"></p><p>2.FixedThreadPool (可重用固定线程数)</p><p>3.CachedThreadPool (按需创建)</p><p>4.SingleThreadPool(单个核线的fixed)</p><p>5.ScheduledThreadPool(定时延时执行)</p><blockquote><p>[1] <a href="https://blog.csdn.net/u013773608/article/details/124329942">https://blog.csdn.net/u013773608/article/details/124329942</a></p><p>[2] <a href="https://blog.csdn.net/qq_41648631/article/details/102871630">https://blog.csdn.net/qq_41648631/article/details/102871630</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程的应用在开发中非常常见。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
    <category term="AsyncTask" scheme="http://yoursite.com/tags/AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>Android文件存储媒体库库MediaStore</title>
    <link href="http://yoursite.com/article/5bfb2f95.html"/>
    <id>http://yoursite.com/article/5bfb2f95.html</id>
    <published>2022-05-18T08:43:28.000Z</published>
    <updated>2025-10-22T03:11:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MediaStore是android系统提供的一个多媒体数据库，专门用于存放多媒体信息的，通过ContentResolver即可对数据库进行操作。媒体库提供来自任何附加存储设备的常见媒体类型的索引集合，例如Audio、Video和。Images每个集合都是根据底层内容的主要 MIME 类型组织的；例如，image/*内容在Images. 该Files集合提供了所有集合的广泛视图，并且不按 MIME 类型进行过滤。</p></blockquote><a id="more"></a><h3 id="关于MediaStore"><a href="#关于MediaStore" class="headerlink" title="关于MediaStore"></a>关于MediaStore</h3><p>MediaStore是android系统提供的一个多媒体数据库，专门用于存放多媒体信息的，通过ContentResolver即可对数据库进行操作。</p><p>MediaStore.Files: 共享的文件,包括多媒体和非多媒体信息；<br>MediaStore.Audio: 存放音频信息；<br>MediaStore.Image: 存放图片信息；<br>MediaStore.Vedio: 存放视频信息；</p><p>每个内部类中都又包含了Media,Thumbnails和相应的MediaColumns，分别提供了媒体信息，缩略信息和操作字段。</p><p>MediaStore 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver contentResolver = <span class="keyword">this</span>.getContentResolver();</span><br><span class="line">Uri imgUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">Uri firstImgUri = <span class="keyword">null</span>;</span><br><span class="line">Cursor cursor = contentResolver.query( imgUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span> );</span><br><span class="line"><span class="keyword">if</span>(cursor!=<span class="keyword">null</span>&amp;&amp;cursor.getCount()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    cursor.moveToFirst();</span><br><span class="line">    firstImgUri = Uri.fromFile(<span class="keyword">new</span> File(cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA))));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;img cursor data=&quot;</span> + cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA))</span><br><span class="line">                + <span class="string">&quot;;\nimg cursor type=&quot;</span></span><br><span class="line">                + cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.MIME_TYPE)));</span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">Log.d(TAG,<span class="string">&quot;firstImgUri=&quot;</span>+firstImgUri);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ParcelFileDescriptor parcelFileDescriptor = contentResolver.openFileDescriptor(firstImgUri, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        Bitmap bitmap = contentResolver.loadThumbnail(firstImgUri, <span class="keyword">new</span> Size(<span class="number">200</span>, <span class="number">200</span>), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;exception: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用MediaStore-API"><a href="#常用MediaStore-API" class="headerlink" title="常用MediaStore API"></a>常用MediaStore API</h3><p>1.查询媒体文件：query()</p><p>用 MediaStore 提供的 Uri 指定设备，selection 参数指定过滤条件，通过 ContentResolver.query 接口查询文件 Uri。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Uri external &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line"></span><br><span class="line">ContentResolver resolver &#x3D; context.getContentResolver();</span><br><span class="line"></span><br><span class="line">String selection &#x3D; MediaStore.Images.Media.TITLE + &quot;&#x3D;?&quot;;</span><br><span class="line">String[] args &#x3D; new String[] &#123;&quot;Image&quot;&#125;;</span><br><span class="line">String[] projection &#x3D; new String[] &#123;MediaStore.Images.Media._ID&#125;;</span><br><span class="line">Cursor cursor &#x3D; resolver.query(external, projection, selection, args, null);</span><br><span class="line">Uri imageUri &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">    imageUri &#x3D; ContentUris.withAppendedId(external, cursor.getLong(0));</span><br><span class="line">    cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.打开媒体文件：openFileDescriptor()</p><p>3.添加媒体文件：Uri songContentUri = resolver.insert(audioCollection, songDetails);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">audioCollection = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">ContentValues songDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,<span class="string">&quot;My Workout Playlist.mp3&quot;</span>);</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>4.更新媒体文件：resolver.update(item, values, null, null);</p><p>5.单个媒体文件的缩略图，调用loadThumbnail()。</p><h3 id="MediaStore文件操作示例"><a href="#MediaStore文件操作示例" class="headerlink" title="MediaStore文件操作示例"></a>MediaStore文件操作示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">打开媒体文件</span><br><span class="line">用于打开媒体文件的具体逻辑取决于媒体内容最佳表示形式是文件描述符、文件流还是直接文件路径：</span><br><span class="line"></span><br><span class="line">文件描述符</span><br><span class="line">如需使用文件描述符打开媒体文件，请使用类似于以下代码段所示的逻辑：</span><br><span class="line"><span class="comment">// Open a specific media item using ParcelFileDescriptor.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;rw&quot; for read-and-write;</span></span><br><span class="line"><span class="comment">// &quot;rwt&quot; for truncating or overwriting existing file contents.</span></span><br><span class="line">String readOnlyMode = <span class="string">&quot;r&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (ParcelFileDescriptor pfd =</span><br><span class="line">        resolver.openFileDescriptor(content-uri, readOnlyMode)) &#123;</span><br><span class="line">    <span class="comment">// Perform operations on &quot;pfd&quot;.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">文件流</span><br><span class="line">如需使用文件流打开媒体文件，请使用类似于以下代码段所示的逻辑：</span><br><span class="line"><span class="comment">// Open a specific media item using InputStream.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"><span class="keyword">try</span> (InputStream stream = resolver.openInputStream(content-uri)) &#123;</span><br><span class="line">    <span class="comment">// Perform operations on &quot;stream&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接文件路径</span><br><span class="line">如果您没有任何与存储空间相关的权限，您可以访问应用专属目录中的文件，并可使用 File API 访问归因于您的应用的媒体文件。  </span><br><span class="line">    </span><br><span class="line">性能</span><br><span class="line">当您使用直接文件路径依序读取媒体文件时，其性能与 MediaStore API 相当。</span><br><span class="line">但是，当您使用直接文件路径随机读取和写入媒体文件时，进程的速度可能最多会慢一倍。在此类情况下，我们建议您改为使用 MediaStore API。</span><br><span class="line"></span><br><span class="line">DATA 列</span><br><span class="line">当您访问现有媒体文件时，您可以使用您的逻辑中 DATA 列的值。这是因为，此值包含有效的文件路径。但是，不要假设文件始终可用。请准备好处理可能发生的任何基于文件的 I/O 错误。</span><br><span class="line">另一方面，如需创建或更新媒体文件，请勿使用 DATA 列的值。请改用 DISPLAY_NAME 和 RELATIVE_PATH 列的值。</span><br><span class="line"></span><br><span class="line">分享</span><br><span class="line">某些应用允许用户彼此分享媒体文件。例如，用户可以通过社交媒体应用与朋友分享照片和视频。</span><br><span class="line">如需共享媒体文件，请按照 </span><br><span class="line">[content provider 创建指南]:</span><br><span class="line">https:<span class="comment">//developer.android.google.cn/guide/topics/providers/content-provider-creating?hl=fr</span></span><br><span class="line">中的建议使用 `content:<span class="comment">//` URI。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">添加项目</span><br><span class="line">如需将媒体项添加到现有集合，请调用类似于以下内容的代码。此代码段可在搭载 Android <span class="number">10</span> 或更高版本的设备上访问 VOLUME_EXTERNAL_PRIMARY 卷。这是因为在这些设备上，您只能修改主要卷的内容，如存储卷部分所述。</span><br><span class="line"><span class="comment">// Add a specific media item.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all audio files on the primary external storage device.</span></span><br><span class="line">Uri audioCollection;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media</span><br><span class="line">            .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish a new song.</span></span><br><span class="line">ContentValues newSongDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">newSongDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,</span><br><span class="line">        <span class="string">&quot;My Song.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keeps a handle to the new song&#x27;s URI in case we need to modify it</span></span><br><span class="line"><span class="comment">// later.</span></span><br><span class="line">Uri myFavoriteSongUri = resolver</span><br><span class="line">        .insert(audioCollection, newSongDetails);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">切换媒体文件的待处理状态</span><br><span class="line">如果您的应用执行可能非常耗时的操作（例如写入媒体文件），那么在处理文件时对其进行独占访问非常有用。在搭载 Android <span class="number">10</span> 或更高版本的设备上，您的应用可以通过将 IS_PENDING 标记的值设为 <span class="number">1</span> 来获取此独占访问权限。如此一来，只有您的应用可以查看该文件，直到您的应用将 IS_PENDING 的值改回 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">以下代码段基于前面的代码段进行构建。以下代码段显示了在与 MediaStore.Audio 集合对应的目录中存储一首较长的歌曲时如何使用 IS_PENDING 标记：</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a media item that other apps shouldn&#x27;t see until the item is</span></span><br><span class="line"><span class="comment">// fully written to the media store.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all audio files on the primary external storage device.</span></span><br><span class="line">Uri audioCollection;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media</span><br><span class="line">            .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    audioCollection = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ContentValues songDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,</span><br><span class="line">        <span class="string">&quot;My Workout Playlist.mp3&quot;</span>);</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Uri songContentUri = resolver</span><br><span class="line">        .insert(audioCollection, songDetails);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (ParcelableFileDescriptor pfd =</span><br><span class="line">        resolver.openFileDescriptor(songContentUri, <span class="string">&quot;w&quot;</span>, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="comment">// Write data into the pending audio file.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that we&#x27;re finished, release the &quot;pending&quot; status, and allow other apps</span></span><br><span class="line"><span class="comment">// to play the audio track.</span></span><br><span class="line">songDetails.clear();</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">0</span>);</span><br><span class="line">resolver.update(songContentUri, songDetails, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更新项目</span><br><span class="line">如需更新应用拥有的媒体文件，请运行类似于以下内容的代码：</span><br><span class="line"><span class="comment">// Updates an existing media item.</span></span><br><span class="line"><span class="keyword">long</span> mediaId = <span class="comment">// MediaStore.Audio.Media._ID of item to update.</span></span><br><span class="line">ContentResolver resolver = getApplicationContext()</span><br><span class="line">        .getContentResolver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// When performing a single item update, prefer using the ID</span></span><br><span class="line">String selection = MediaStore.Audio.Media._ID + <span class="string">&quot; = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// By using selection + args we protect against improper escaping of</span></span><br><span class="line"><span class="comment">// values. Here, &quot;song&quot; is an in-memory object that caches the song&#x27;s</span></span><br><span class="line"><span class="comment">// information.</span></span><br><span class="line">String[] selectionArgs = <span class="keyword">new</span> String[] &#123; getId().toString() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update an existing song.</span></span><br><span class="line">ContentValues updatedSongDetails = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updatedSongDetails.put(MediaStore.Audio.Media.DISPLAY_NAME,</span><br><span class="line">        <span class="string">&quot;My Favorite Song.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the individual song&#x27;s URI to represent the collection that&#x27;s</span></span><br><span class="line"><span class="comment">// updated.</span></span><br><span class="line"><span class="keyword">int</span> numSongsUpdated = resolver.update(</span><br><span class="line">        myFavoriteSongUri,</span><br><span class="line">        updatedSongDetails,</span><br><span class="line">        selection,</span><br><span class="line">        selectionArgs);</span><br><span class="line"></span><br><span class="line">注意：您可以在调用 update() 的过程中通过更改 MediaColumns.RELATIVE_PATH 或 MediaColumns.DISPLAY_NAME 在磁盘上移动文件。</span><br></pre></td></tr></table></figure><h3 id="关于MediaStore-Pending"><a href="#关于MediaStore-Pending" class="headerlink" title="关于MediaStore Pending"></a>关于MediaStore Pending</h3><p>Android Q 上，MediaStore 中添加了一个 IS_PENDING Flag，用于标记当前文件是 Pending 状态。</p><p>其他 APP 通过 MediaStore 查询文件，如果没有设置 setIncludePending 接口，就查询不到设置为 Pending 状态的文件，这就能使 APP 专享此文件。</p><p>这个 flag 在一些应用场景下可以使用，例如在下载文件的时候：下载中，文件设置为 Pending 状态；下载完成，把文件 Pending 状态置为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(MediaStore.Images.Media.DISPLAY_NAME, <span class="string">&quot;myImage.PNG&quot;</span>);</span><br><span class="line">values.put(MediaStore.Images.Media.MIME_TYPE, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">values.put(MediaStore.Images.Media.IS_PENDING, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ContentResolver resolver = context.getContentResolver();</span><br><span class="line">Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">Uri item = resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ParcelFileDescriptor pfd = resolver.openFileDescriptor(item, <span class="string">&quot;w&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// write data into the pending image.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    LogUtil.log(<span class="string">&quot;write image fail&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear IS_PENDING flag after writing finished.</span></span><br><span class="line">values.clear();</span><br><span class="line">values.put(MediaStore.Images.Media.IS_PENDING, <span class="number">0</span>);<span class="comment">//释放，使其他应用可以访问</span></span><br><span class="line">resolver.update(item, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><strong>IS_PENDING独占</strong>：Android 10以后，当写入磁盘时 应用可以通过IS_PENDING标志实现对媒体文件的独占访问。</p><h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><p>[1] 安卓 11 使用 MediaRecorder 录制视频，由于新的分区存储特性（Scoped Storage，APP 产生的文件只能通过 MediaStore API 写入磁盘），存储路径无法直接使用外部 SD 卡的路径。<br><a href="https://www.jianshu.com/p/edaa0d9df93e">https://www.jianshu.com/p/edaa0d9df93e</a></p><p>[2] 重命名由android 10中的应用程序创建的Mediastore的文件<br><a href="https://codingdict.com/questions/107164">https://codingdict.com/questions/107164</a></p><p>[3] Android 10、11 存储完全适配！<br><a href="https://blog.csdn.net/fitaotao/article/details/119700579">https://blog.csdn.net/fitaotao/article/details/119700579</a></p><p>[4] Android10_存储之scoped storage&amp;媒体文件-分区存储权限变更及适配<br><a href="https://blog.csdn.net/u010227042/article/details/104507886">https://blog.csdn.net/u010227042/article/details/104507886</a></p><p>[5] *Android Q 存储新特性适配脑壳疼？指南来了！<br><a href="https://www.163.com/dy/article/EL0CD9QG0511IFOV.html">https://www.163.com/dy/article/EL0CD9QG0511IFOV.html</a><br><a href="https://mp.weixin.qq.com/s/aiDMyAfAZvaYIHuIMLAlcg">https://mp.weixin.qq.com/s/aiDMyAfAZvaYIHuIMLAlcg</a></p><p>[6] *访问共享存储空间中的媒体文件<br><a href="https://developer.android.google.cn/training/data-storage/shared/media?hl=fr">https://developer.android.google.cn/training/data-storage/shared/media?hl=fr</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;MediaStore是android系统提供的一个多媒体数据库，专门用于存放多媒体信息的，通过ContentResolver即可对数据库进行操作。媒体库提供来自任何附加存储设备的常见媒体类型的索引集合，例如Audio、Video和。Images每个集合都是根据底层内容的主要 MIME 类型组织的；例如，image/*内容在Images. 该Files集合提供了所有集合的广泛视图，并且不按 MIME 类型进行过滤。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="MediaStore" scheme="http://yoursite.com/tags/MediaStore/"/>
    
  </entry>
  
  <entry>
    <title>Java Lambda 表达式</title>
    <link href="http://yoursite.com/article/8e84b9d0.html"/>
    <id>http://yoursite.com/article/8e84b9d0.html</id>
    <published>2022-05-18T06:39:51.000Z</published>
    <updated>2025-10-22T03:11:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p></blockquote><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda 表达式的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或 (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>以下是lambda表达式的重要特征:</p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li></ul><h3 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h3><p>Lambda 表达式的简单例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p>在 Java8Tester.java 文件输入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Java8Tester tester = <span class="keyword">new</span> Java8Tester();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 类型声明</span></span><br><span class="line">      MathOperation addition = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用类型声明</span></span><br><span class="line">      MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">      MathOperation multiplication = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">      MathOperation division = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a / b;</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用括号</span></span><br><span class="line">      GreetingService greetService1 = message -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 用括号</span></span><br><span class="line">      GreetingService greetService2 = (message) -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      greetService2.sayMessage(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">MathOperation</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, MathOperation mathOperation)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">10 + 5 &#x3D; 15</span><br><span class="line">10 - 5 &#x3D; 5</span><br><span class="line">10 x 5 &#x3D; 50</span><br><span class="line">10 &#x2F; 5 &#x3D; 2</span><br><span class="line">Hello Runoob</span><br><span class="line">Hello Google</span><br></pre></td></tr></table></figure><blockquote><p>使用 Lambda 表达式需要注意以下两点：</p><ul><li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li><li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li></ul></blockquote><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>Lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</li></ul><blockquote><p>我们也可以直接在 Lambda 表达式中访问外层的局部变量，Lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）。</p></blockquote><ul><li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Lambda" scheme="http://yoursite.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>企业项目开发流程</title>
    <link href="http://yoursite.com/article/a73689f8.html"/>
    <id>http://yoursite.com/article/a73689f8.html</id>
    <published>2022-05-16T15:26:51.000Z</published>
    <updated>2025-10-22T03:11:19.295Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般情况下，企业开发软件时会按照基线和定制两块并行方式执行项目开发工作。无论什么公司，都需要遵从一套成熟的产品研发过程体系，才能做出质量较好的产品。因此，如果出现项目较多的情况，应该合理地安排基线和定制之前的里程碑，让基线产品能够尽量多地收集用户的通用型需求，为定制项目进度实现技术支撑，减少定制项目中大量更改代码、需要新增模块情况发生。此外，产品研发过程体系也需要按照业务实际时间要求变化，不要拘泥于一定要按照瀑布方式，或是敏捷方式进行管理，凡事都需要找到契合自己的方式。</p></blockquote><a id="more"></a><h3 id="Web项目流程"><a href="#Web项目流程" class="headerlink" title="Web项目流程"></a>Web项目流程</h3><p>1.需求分析<br>2.设计（概要设计、详细设计)<br>3.技术选型<br>4.初始化/引入需要的技术<br>5.写Demo<br>6.写代码（实现业务逻辑)<br>7.测试(单元测试)<br>8.代码提交&amp;代码评审<br>9.部署<br>10.发布</p><p><strong>关于技术选型</strong><br>前端:三件套＋React +组件库Ant Design + Umi + Ant Design Pro(现成的管理系统)</p><blockquote><p>Umi 自动生成代码工具<br>packages.json 依赖和脚本<br>yarn 包管理器：//npm install -g yarn //yarn –version</p></blockquote><p>后端: java +spring + springmvc + mybatis + mybatis-plus + springboot + mysql<br>部署:服务器/容器（平台)</p><blockquote><p>mvnrepository:<a href="https://mvnrepository.com/">https://mvnrepository.com/</a><br><a href="https://search.maven.org/">https://search.maven.org/</a><br>mybatis-plus <a href="https://baomidou.com/">https://baomidou.com/</a><br>springboot官方生成器：<a href="https://start.spring.io/">https://start.spring.io/</a></p></blockquote><p><strong>关于依赖：</strong><br>Spring Boot DevTools //热更新<br>Lombok 注解<br>Spring Configuration Processor<br>mysql 数据库<br>spring web //接口<br>mybatis //数据库访问<br>junit //单元测试swagger //api文档</p><h3 id="App开发流程"><a href="#App开发流程" class="headerlink" title="App开发流程"></a>App开发流程</h3><p>1.产品经理:功能需求，竞品分析，抄同类产品的好功能<br>2.UI设计：寻找灵感，抄同类产品设计<br>3.程序员：代码审查，百度论坛找解决办法<br>4.测试：测试体验，多种手机对比</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一般情况下，企业开发软件时会按照基线和定制两块并行方式执行项目开发工作。无论什么公司，都需要遵从一套成熟的产品研发过程体系，才能做出质量较好的产品。因此，如果出现项目较多的情况，应该合理地安排基线和定制之前的里程碑，让基线产品能够尽量多地收集用户的通用型需求，为定制项目进度实现技术支撑，减少定制项目中大量更改代码、需要新增模块情况发生。此外，产品研发过程体系也需要按照业务实际时间要求变化，不要拘泥于一定要按照瀑布方式，或是敏捷方式进行管理，凡事都需要找到契合自己的方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术流" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%B5%81/"/>
    
    
    <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
    <category term="App" scheme="http://yoursite.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>Java中的几个重要特性</title>
    <link href="http://yoursite.com/article/7f3a79dc.html"/>
    <id>http://yoursite.com/article/7f3a79dc.html</id>
    <published>2022-05-14T11:27:23.000Z</published>
    <updated>2025-10-22T03:11:19.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java应用中的几个重要特性：多态、泛型、反射、集合、正则、引用分类。</p></blockquote><a id="more"></a><h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1.多态"></a>1.多态</h3><p>多态就是同一个行为，使用不同的实例而发生不同的作用。在使用多态调用方法的时候，编译器检查父类中是否有该方法，如果有才能编译通过，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>&#123;动物叫&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>&#123;猫叫&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testVoice</span><span class="params">(Animals a)</span></span>&#123;</span><br><span class="line">    a.voice();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    testVoice(<span class="keyword">new</span> Cat())；</span><br><span class="line"></span><br><span class="line">    Animals a = <span class="keyword">new</span> Cat();</span><br><span class="line">    a.voice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>猫继承自动物这个类，Animals a = new Cat()是向上转型（父类引用指向子类对象），实际的<strong>运行时类型</strong>还是Cat，也就是说a instanceof Cat 表达式为真，因此调用a的voice()方法是猫叫。结合C的指针和内存分析来理解多态。</p><h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2.泛型"></a>2.泛型</h3><ol><li>类型通配符</li></ol><ul><li>&lt;? extends T&gt;表示该通配符所代表的类型是T类型的子类。</li><li>&lt;? super T&gt;表示该通配符所代表的类型是T类型的父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Closable&gt; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T temp:a)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>泛型不能用在静态属性上</li><li>指定的类型不能为基本类型</li></ol><h3 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h3><ol><li>获取目标类型的Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; a = Object.getClass();</span><br><span class="line">Class&lt;?&gt; b = T.class;</span><br><span class="line">Class&lt;?&gt; c = Class.forName(...);</span><br></pre></td></tr></table></figure><ol><li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象<ul><li>不带 “Declared”的方法支持取出包括继承、公有（Public） &amp; 不包括有（Private）的构造函数</li><li>带 “Declared”的方法是支持取出包括公共（Public）、保护（Protected）、默认（包）访问和私有（Private）的构造方法，但不包括继承的构造函数</li></ul></li></ol><ul><li>Constructor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.获取指定的构造函数（公共/继承）</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//b.获取所有的构造函数（公共/继承） </span></span><br><span class="line">Constructor&lt;?&gt;[] getConstructors(); </span><br><span class="line"><span class="comment">//c.获取指定的构造函数（不包括继承）</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//d.获取所有的构造函（不包括继承）</span></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors(); </span><br></pre></td></tr></table></figure><ul><li>Field</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.获取指定的属性（公共/继承）</span></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//b.获取所有的属性（公共/继承）</span></span><br><span class="line">Field[] getFields();</span><br><span class="line"><span class="comment">//c.获取指定的所有属性（不包括继承）</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//d.获取所有的所有属性（不包括继承）</span></span><br><span class="line">Field[] getDeclaredFields();</span><br></pre></td></tr></table></figure><ul><li>Method</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.获取指定的方法（公共/继承）</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//b.获取所有的方法（公共/继承）</span></span><br><span class="line">Method[] getMethods();</span><br><span class="line"><span class="comment">//c.获取指定的方法 （不包括继承）</span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">//d.获取所有的方法（不包括继承）</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br></pre></td></tr></table></figure><h3 id="4-集合"><a href="#4-集合" class="headerlink" title="4. 集合"></a>4. 集合</h3><ol><li>迭代器遍历ArrayList</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;TAG&quot;</span>,ite.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历Map</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：map.keySet()</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; value= &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：map.entrySet().iterator()</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; value= &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//第三种：map.entrySet()</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; value= &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//第四种：map.values()</span></span><br><span class="line"><span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历 hashMap() 时 entrySet() 方法是将 key 和 value 全部取出来,所以性能开销是可以预计的, 而 keySet() 方法进行遍历的时候是根据取出的 key 值去查询对应的 value 值, 所以如果 key 值是比较简单的结构(如 1,2,3…)的话性能消耗上是比 entrySet() 方法低, 但随着 key 值得复杂度提高 entrySet() 的优势就会显露出来。</li><li>在只遍历 key 的时候使用 keySet(), 在只遍历 value 的时候使用 values(), 在遍历 key-value 的时候使用 entrySet()。</li></ol><h3 id="5-正则"><a href="#5-正则" class="headerlink" title="5.正则"></a>5.正则</h3><p>RegexBuddy</p><ol><li>转义字符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\n  \t  \\  \^  \$  \(  \)  \&#123;  </span><br><span class="line">\&#125;  \?  \+  \*  \|  \[  \]</span><br></pre></td></tr></table></figure><ol><li>标准字符集合（大写取反）</li></ol><table><thead><tr><th align="left">\d</th><th align="left">0~9的任意一个数字</th></tr></thead><tbody><tr><td align="left">\w</td><td align="left">A<del>Z, a</del>z, 0~9, _中任意一个</td></tr><tr><td align="left">\s</td><td align="left">空格、制表符、换行符等空白符的任意一个</td></tr><tr><td align="left">.</td><td align="left">匹配任意一个字符</td></tr><tr><td align="left">[]</td><td align="left">匹配方括号中任意一个字符</td></tr><tr><td align="left">^</td><td align="left">方括号取反</td></tr><tr><td align="left">-</td><td align="left">方括号中表示范围</td></tr><tr><td align="left">{}</td><td align="left">花括号前正则表达式的重复次数，{m,n}至少m次，最多n次</td></tr><tr><td align="left">?</td><td align="left">花括号后加，非贪婪模式。非花括号后加，相当于{0,1}</td></tr><tr><td align="left">+</td><td align="left">前面的正则表达式至少出现一次，相当于{1,}</td></tr><tr><td align="left">*</td><td align="left">表达式不出现或出现多次，相当于{0,}</td></tr><tr><td align="left">^</td><td align="left">与字符串开始的地方匹配</td></tr><tr><td align="left">$</td><td align="left">与字符串结束的地方匹配</td></tr><tr><td align="left">\b</td><td align="left">匹配一个字符边界</td></tr><tr><td align="left">|</td><td align="left">匹配左边或者右边</td></tr><tr><td align="left">(?=exp)</td><td align="left">断言自身出现的位置的后面能匹配表达式exp</td></tr><tr><td align="left">(?&lt;=exp)</td><td align="left">断言自身出现的位置的前面能匹配表达式exp</td></tr><tr><td align="left">(?!exp)</td><td align="left">断言此位置的后面不能匹配表达式exp</td></tr><tr><td align="left">(?&lt;!exp)</td><td align="left">断言此位置的前面不能匹配表达式exp</td></tr></tbody></table><h3 id="6-引用分类"><a href="#6-引用分类" class="headerlink" title="6.引用分类"></a>6.引用分类</h3><ol><li>强引用:StrongReference:引用指向对象，gc运行时不回收</li><li>软引用:SoftReference:gc运行时回收，（jvm内存不够）</li><li>弱引用:WeakReference:gc运行时立即回收</li><li>虚引用:PhantomReference:跟踪对象被回收的状态，必须与ReferenceQueue一起使用</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java应用中的几个重要特性：多态、泛型、反射、集合、正则、引用分类。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java技能树-基本语法和变量及常量</title>
    <link href="http://yoursite.com/article/d37d704e.html"/>
    <id>http://yoursite.com/article/d37d704e.html</id>
    <published>2022-05-14T10:12:32.000Z</published>
    <updated>2025-10-22T03:11:19.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本语法和变量及常量：Java的语法格式、注释、关键字、数据类型、常量和变量的声明及其作用域。</p></blockquote><a id="more"></a><h2 id="Java的基本语法"><a href="#Java的基本语法" class="headerlink" title="Java的基本语法"></a>Java的基本语法</h2><h3 id="Java的基本语法格式"><a href="#Java的基本语法格式" class="headerlink" title="Java的基本语法格式"></a>Java的基本语法格式</h3><p>每一种编程语言都有一套自己的语法规范,Java 语言也不例外,同样需要遵从一定的语法规范,如代码的书写、标识符的定义、关键字的应用等。因此要学好 Java 语言,首先需要熟悉它的基本语法。本节将针对 Java 的基本语法进行详细讲解。</p><p>Java 的基本语法格式</p><p>编写 Java 程序代码必须先声明一个类然后在类中编写实现需求的业务代码。类需变使用 class 关键字定鸟,在 class 前面可以有一些修饰符,其语法格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写 Java 程序代码时,需要特别注意几个关键点,具体如下。</p><p>(1) Java 中的程序可分为结构定义语句和功能执行语句。其中,结构定义语句用于声明一个类或方法,功能执行语句用于实现具体的功能。每条功能执行语句的结尾都必须用</p><p>英文分号(;)结束。如下面的语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;这是第一个Java程序&quot;</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是,在程序中不要将英文的分号(;)误写成中文的分号(;)。如果写成中文的分号,编译器会报告“Invalid Character(无效字符)”错误信息。</p><p>(2) Java 语言是严格区分大小写的。例如,在程序中定义一个 computer 的同时,还有以定义一个 Computer,computer 和 Computer 是两个完全不同的符号,在使用时务必注意</p><p>(3)在编写 Java 代码时,为了便于阅读,通常会使用一种良好的格式进行排版,但这并不是必需的,也可以在两个单词或符号之间任意地换行,例如下面这段代码的编排方式也是可以的。</p><p>虽然 Javn 没有严格要求用什么样的格式来编排程序代码,但是,出于程序可读性和美观性的考虑,应该让自己编写的程序代码整齐美观、层次清晰,通常会使用下面这种形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;这是第一个 Java 程序!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)Java 程序中一个连续的字符串不能分开在两行中书写,例如,下面这条语句在编译时将会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;这是第一个</span></span><br><span class="line"><span class="string">                    Java 程序！&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果为了便于阅读,想将一个太长的字符串分开在两行中书写,可以先将这个字符串分成两个字符串,然后用加号(十)将这两个字符串连起来,在加号(十)处断行,上面的语句可以修改成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out,println(<span class="string">&quot;这是第一个&quot;</span>+<span class="string">&quot;Java 程序!&quot;</span>);</span><br></pre></td></tr></table></figure><p>小提示：Java 代码基本格式中涉及的类、修饰符、编译器等专业性的词汇,读者可以先不必深究其具体含义,在本节只需要重点掌握 Java 代码的基本格式即可，在后续学习 Java 的过程中,会对这些专业词汇进行详细讲解。</p><h3 id="Java中的注释"><a href="#Java中的注释" class="headerlink" title="Java中的注释"></a>Java中的注释</h3><p>Java中的注释</p><p>在编写程序时,为了使代码易于阅读,通常会在实现功能的同时为代码添加一些注释。注释是对程序的某个功能或者某行代码的解释说明,它能够让开发者在后期阅读和使用代码时能更容易理解代码的作用。</p><p>注释只在Java 源文件中有效,在编译程序时编译器会忽略这些注释信息,不会将其编译到 class 字节码文件中。</p><p>Java 中的注释有三种类型,具体如下。</p><p>1.单行注释</p><p>单行注释通常用于对程序中的某一行代码进行注释，用符号”//“表示，”//“后面为注释说明的内容，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c=<span class="number">10</span>;   <span class="comment">//定义一个整型变量c</span></span><br></pre></td></tr></table></figure><p>2.多行注释</p><p>多行注释顾名思义就是可以同时注释多行内容，它以符号”/<em>“开头，并以符号”</em>/“结尾，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个整型变量x</span></span><br><span class="line"><span class="comment">将5赋值给变量x*/</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>3.文档注释</p><p>文档注释通常是对程序中某个类或类中的方法进行的系统性的解释说明,开发人员可以使用 JDK 提供的 javadoc 工具将文档注释提取出来生成一份 API 帮助文档。文档注释以符号“/*<em>”开头,并以符号“</em>/”结尾,具体示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Title:HelloNorid类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> srx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这是一个 main ()方法人口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args 参数名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out .printitln(<span class="string">&quot;这是第一个 Java程序!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留心：</p><p>在java中，有的注释可以嵌套使用，有的则不可以，下面列举两种具体的情况。</p><p>（1）多行注释”/<em>….</em>/“中可以嵌套使用单行注释”//“，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*int c=10;    //定义一个整型的c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  int x=5;*/</span></span><br></pre></td></tr></table></figure><p>(2)多行注释”/<em>…..</em>/“中不能嵌套多行注释”/<em>…</em>/“,具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    /*int c=10;*/</span></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>4.如果编写java源代码的过程中添加了文档注释吗，然后通过JDK提供的javac工具可以直接将源代码里的文档注释提取程一份系统的API文档。</p><p>javadoc 工具软件识别以下标签：</p><table><thead><tr><th align="left"><strong>标签</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="left">标识一个类的作者</td><td align="left">@author description</td></tr><tr><td align="left">@deprecated</td><td align="left">指名一个过期的类或成员</td><td align="left">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="left">指明当前文档根目录的路径</td><td align="left">Directory Path</td></tr><tr><td align="left">@exception</td><td align="left">标志一个类抛出的异常</td><td align="left">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="left">从直接父类继承的注释</td><td align="left">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="left">插入一个到另一个主题的链接</td><td align="left">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="left">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="left">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="left">说明一个方法的参数</td><td align="left">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="left">说明返回值类型</td><td align="left">@return explanation</td></tr><tr><td align="left">@see</td><td align="left">指定一个到另一个主题的链接</td><td align="left">@see anchor</td></tr><tr><td align="left">@serial</td><td align="left">说明一个序列化属性</td><td align="left">@serial description</td></tr><tr><td align="left">@serialData</td><td align="left">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="left">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="left">说明一个ObjectStreamField组件</td><td align="left">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="left">标记当引入一个特定的变化时</td><td align="left">@since release</td></tr><tr><td align="left">@throws</td><td align="left">和 @exception标签一样.</td><td align="left">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="left">显示常量的值，该常量必须是static属性。</td><td align="left">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="left">指定类的版本</td><td align="left">@version info</td></tr></tbody></table><p>javadoc 输出什么?</p><p>javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件。</p><p>每一个类的信息将在独自的HTML文件里。javadoc 也可以输出继承的树形结构和索引。</p><p>由于 javadoc 的实现不同，工作也可能不同，你需要检查你的 Java 开发系统的版本等细节，选择合适的 Javadoc 版本。</p><h3 id="java中的关键字"><a href="#java中的关键字" class="headerlink" title="java中的关键字"></a>java中的关键字</h3><p>2.1.3 Java 中的关键字</p><p>关键字(keyword)是编程语言里事先定义好并赋予了特殊含义的单词,也称作保留字。和其他语言一样,Java 中保留了许多关键字.例如 class.public等。JDK 8 中有 50 个关键字,这些关键字都是小写的，具体如表：</p><table><thead><tr><th>abstract</th><th>assert</th><th>boolean</th><th>break</th><th>byte</th></tr></thead><tbody><tr><td>case</td><td>catch</td><td>char</td><td>class</td><td>const</td></tr><tr><td>continue</td><td>default</td><td>do</td><td>double</td><td>else</td></tr><tr><td>enum</td><td>extends</td><td>final</td><td>finally</td><td>float</td></tr><tr><td>for</td><td>goto</td><td>if</td><td>implements</td><td>import</td></tr><tr><td>instanceof</td><td>int</td><td>interface</td><td>long</td><td>native</td></tr><tr><td>new</td><td>package</td><td>private</td><td>protected</td><td>public</td></tr><tr><td>return</td><td>strictfp</td><td>short</td><td>static</td><td>super</td></tr><tr><td>switch</td><td>synchronized</td><td>this</td><td>throw</td><td>throws</td></tr><tr><td>transient</td><td>try</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table><p>上面列举的关键字中.每个关键字都有特殊的作用,例如 package美键字用于包的声明，import 关键字用于引人包，class 关键字用于类的声明。</p><h3 id="关键字总结"><a href="#关键字总结" class="headerlink" title="关键字总结"></a>关键字总结</h3><h4 id="1-abstract"><a href="#1-abstract" class="headerlink" title="1.abstract"></a>1.abstract</h4><ul><li>修饰类：</li></ul><p>abstract修饰类，这个类就是抽象类，抽象类中可以有非抽象变量和成员变量，也可以有普通方法、构造方法。但是不能实例化，只能被子类继承。<br>如果子类不是抽象类，则必须重写父类的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰方法:</li></ul><p>abstract修饰方法，这个方法就是抽象方法。抽象方法必须存在于抽象类中。抽象方法不能有具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-assert"><a href="#2-assert" class="headerlink" title="2.assert"></a>2.assert</h4><p>assert表示“断言”，有两种使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 表达式;</span><br></pre></td></tr></table></figure><p>若表达式为真，程序继续执行；若表达式为假，则抛出一个AssertionError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 表达式:错误信息;</span><br></pre></td></tr></table></figure><p>与第一种方法相同，只是异常中带有错误信息。<br>使用assert时不能在表达式中完成任何程序实际所需的行为（只能做判断）。因为正常发布的代码都是断言无效的，即正常发布的代码中断言语句都不不执行的。</p><h4 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h4><p>boolean是Java的基本类型之一（默认值false）。只有两个值：true和false。区别C的判断句，Java不能直接使用1和0来表示真假，且boolean类型也不能强转到其他基本类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h4 id="4-break"><a href="#4-break" class="headerlink" title="4.break"></a>4.break</h4><ol><li>break在switch中用于跳出switch块，停止switch向下穿透的现象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> value:expression;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ol><li>break在循环中用于跳出循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>break也可以在后面接标签，用来跳出一些嵌套比较复杂的循环中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag:</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">break</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-byte"><a href="#5-byte" class="headerlink" title="5.byte"></a>5.byte</h4><p>byte是Java的基本类型之一（默认值0）。表示8位有符号整数。</p><p>范围：-128~127</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h4 id="6-case"><a href="#6-case" class="headerlink" title="6.case"></a>6.case</h4><p>case用于switch中，用于判断和执行语句。用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量值:语句;</span><br></pre></td></tr></table></figure><p>若变量值和switch(变量值)<br>中的变量值相等，就执行后面的语句。执行完后继续执行下一个case语句。</p><h4 id="7-catch"><a href="#7-catch" class="headerlink" title="7.catch"></a>7.catch</h4><p>catch用于捕获异常。<br>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(异常类型 异常)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>在try/catch语句块中，catch捕获发生的异常，并应对错误做一些处理。<br>当catch捕获到异常后，try中执行的语句终止，并跳到catch后的语句中。</p><h4 id="8-char"><a href="#8-char" class="headerlink" title="8.char"></a>8.char</h4><p>char是Java的基本类型之一（默认值\u000）。表示16位、在Unicode编码表中的字符。使用单引号来表示字符常量，例如’A’。</p><p>范围：0-65535</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="9-class"><a href="#9-class" class="headerlink" title="9.class"></a>9.class</h4><p>class表示类。用于声明一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问控制] (<span class="keyword">abstract</span>) <span class="class"><span class="keyword">class</span> 类名 (<span class="keyword">implements</span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="10-const"><a href="#10-const" class="headerlink" title="10.const"></a>10.const</h4><p>const是Java的一个保留关键字，没有实际意义，但是不能用于做变量名（因为被保留作为关键字了）。在C语言中表示常量，类似Java的final。</p><h4 id="11-continue"><a href="#11-continue" class="headerlink" title="11.continue"></a>11.continue</h4><ol><li>continue用于在循环中跳过本次循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>continue也可以在后面接标签，在一些嵌套比较复杂的循环中跳过一次循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag:</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">continue</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-default"><a href="#12-default" class="headerlink" title="12.default"></a>12.default</h4><p>default关键字：</p><ol><li>用于switch做默认分支：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:语句；</span><br></pre></td></tr></table></figure><ol><li>用于接口,让接口实现具体的方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        具体方法;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>default用于接口时，必须要有具体实现。<br>(API&gt;=24)</p><h4 id="13-do"><a href="#13-do" class="headerlink" title="13. do"></a>13. do</h4><p>do用于和while组成循环，do/while循环不同于while循环，属于先执行循环体再判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(...)</span><br></pre></td></tr></table></figure><h4 id="14-double"><a href="#14-double" class="headerlink" title="14.double"></a>14.double</h4><p>double是Java的基本类型之一（默认值0.0d），表示双精度、64位的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">0.1d</span>;</span><br></pre></td></tr></table></figure><h4 id="15-else"><a href="#15-else" class="headerlink" title="15.else"></a>15.else</h4><p>else用于分支结构中的判断。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断<span class="number">2</span>)&#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-enum"><a href="#16-enum" class="headerlink" title="16.enum"></a>16.enum</h4><p>enum表示枚举，用于限制变量值的类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title">Alpha</span> <span class="params">(implements 接口)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>)a,b,c,d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规定Color的实例只能为a,b,c,d其中之一。</p><p><strong>枚举类中可以有成员变量和方法。</strong></p><h4 id="17-extends"><a href="#17-extends" class="headerlink" title="17.extends"></a>17.extends</h4><p>extends表示继承。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span>父类</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Java中的继承是单继承，即子类只能有一个直接父类。<br>除了private，子类可以访问父类的方法和成员变量。</p><h4 id="18-final"><a href="#18-final" class="headerlink" title="18.final"></a>18.final</h4><ol><li>修饰变量：<br>将变量变为常量，在初始化变量后不能再改变值。</li><li>修饰方法：<br>被final修饰的方法不能被子类重写。</li><li>修饰类：<br>被final修饰的类不能被继承。</li></ol><h4 id="19-finally"><a href="#19-finally" class="headerlink" title="19.finally"></a>19.finally</h4><p>finally在try/catch语句块中处理一些后续的工作。例如关闭网络连接和输入输出流等。</p><ul><li>如果在try/catch中使用return，则finally会撤销这个return，无论如何都会执行finally中的语句。</li></ul><h4 id="20-float"><a href="#20-float" class="headerlink" title="20.float"></a>20.float</h4><p>float是Java的基本类型之一（默认值0.0f）。表示单精度、32位的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">0.1f</span>;</span><br></pre></td></tr></table></figure><h4 id="21-for"><a href="#21-for" class="headerlink" title="21.for"></a>21.for</h4><p>for用于循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化循环变量; 判断执行条件;更新循环变量)&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(变量:数组)&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22-goto"><a href="#22-goto" class="headerlink" title="22.goto"></a>22.goto</h4><p>Java中的保留关键字，没有实际意义，但是不能用做变量名。在C中表示无条件跳转语句。</p><h4 id="23-if"><a href="#23-if" class="headerlink" title="23.if"></a>23.if</h4><p>if用于分支结构中的判断。常与else和else if使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;语句&#125;</span><br></pre></td></tr></table></figure><p>若表达式为真，则执行后面的语句。</p><h4 id="24-implements"><a href="#24-implements" class="headerlink" title="24.implements"></a>24.implements</h4><p>implements用于接入接口。接上接口的类必须实现接口的抽象方法（可以不实现默认方法和静态方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">do</span>()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="25-import"><a href="#25-import" class="headerlink" title="25.import"></a>25.import</h4><p>用于导入包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br></pre></td></tr></table></figure><h4 id="26-instanceof"><a href="#26-instanceof" class="headerlink" title="26.instanceof"></a>26.instanceof</h4><p>instanceof用于判断类与对象的关系。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> b</span><br></pre></td></tr></table></figure><p>若a是b的一个实例(或子类对象)，则整个表达式的结果是true，否则结果为false。</p><h4 id="27-int"><a href="#27-int" class="headerlink" title="27.int"></a>27.int</h4><p>int是Java的基本类型之一（默认值为0）。表示32位、有符号的整数。</p><p>范围：[-231,231-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="28-interface"><a href="#28-interface" class="headerlink" title="28.interface"></a>28.interface</h4><p>interface用于声明一个接口，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明a为一个接口，若接上该接口，则必须实现其中的抽象方法b。<br>接口中的成员变量是static、final、public的。接口中的方法为静态方法或默认方法和静态方法(API&gt;=24)。</p><h4 id="29-long"><a href="#29-long" class="headerlink" title="29.long"></a>29.long</h4><p>long是Java的基本类型之一（默认值为0L），表示64位、有符号的整数。</p><p>范围：[-263,263)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">3216846849646L</span>;</span><br></pre></td></tr></table></figure><h4 id="30-native"><a href="#30-native" class="headerlink" title="30.native"></a>30.native</h4><p>native可以让Java运行非Java实现的方法。例如c语言，要编译后用javah产生一个.h文件。导入该.h文件并且实现native方法，编译成动态链接库文件。在Java加载动态链接库文件，这个native方法就可以在Java中使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">aVoid</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="31-new"><a href="#31-new" class="headerlink" title="31.new"></a>31.new</h4><p>new用于生成类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object a = <span class="keyword">new</span> Object()；</span><br></pre></td></tr></table></figure><h4 id="32-package"><a href="#32-package" class="headerlink" title="32.package"></a>32.package</h4><p>package用于规定当前文件的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.zhangyijun.testdefactivity;</span><br></pre></td></tr></table></figure><h4 id="33-private"><a href="#33-private" class="headerlink" title="33.private"></a>33.private</h4><p>访问控制的一种。<br>私有的方法和变量只能在本类中访问。类和接口不能为私有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="34-protected"><a href="#34-protected" class="headerlink" title="34.protected"></a>34.protected</h4><p>访问控制的一种。<br>受保护的方法和变量只能给子类和基类访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="35-public"><a href="#35-public" class="headerlink" title="35.public"></a>35.public</h4><p>访问控制的一种。<br>公有的方法、类、变量、接口能够被任何其他类访问。</p><h4 id="36-return"><a href="#36-return" class="headerlink" title="36.return"></a>36.return</h4><p>方法中返回数据，并结束方法。</p><h4 id="37-strictfp"><a href="#37-strictfp" class="headerlink" title="37.strictfp"></a>37.strictfp</h4><p>使用strictfp关键字来声明一个类、接口或者方法时，那么该类、接口或者方法会遵循IEEE-754标准来执行，提高浮点运算的精度，并且减少不同硬件平台之间由于浮点运算带来的差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">strictfp</span> <span class="keyword">double</span> <span class="title">aDouble</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="38-short"><a href="#38-short" class="headerlink" title="38.short"></a>38.short</h4><p>short是Java的基本类型之一（默认值0）,表示16位、有符号的整数。</p><p>范围：[-215,215)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="39-static"><a href="#39-static" class="headerlink" title="39.static"></a>39.static</h4><p>static修饰的语句块存放在堆的方法区中。</p><ol><li>静态变量：依附在类中的变量，可以被类的所有的实例共用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol><li>静态方法：依附在类中的方法。静态方法只能访问类中的静态变量和静态方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publlic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>静态块：在类加载的时候执行块中的语句，块中不能访问非静态变量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>静态内部类：用static修饰内部类。</li></ol><h4 id="40-super"><a href="#40-super" class="headerlink" title="40.super"></a>40.super</h4><p>super即超类</p><ol><li>引用父类的的成员：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.xxx</span><br></pre></td></tr></table></figure><ol><li>变量或方法重名时用super调用父类的成员或方法。</li><li>调用父类的构造方法:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(xxx);</span><br></pre></td></tr></table></figure><h4 id="41-switch"><a href="#41-switch" class="headerlink" title="41.switch"></a>41.switch</h4><p>switch用于分支结构，判断某个变量与一系列值是否相等。switch 语句中的变量类型可以是： byte、short、int 、char、String、enum。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line"><span class="keyword">case</span> value1:语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> value2:语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>若变量和case后的值相等则执行语句。</li><li>当语句执行到break时跳到switch块后，如果没有break会产生穿透现象。</li><li>default分支必须为最后一个分支，在没有值和case变量相等时执行该语句。</li></ol><h4 id="42-synchronized"><a href="#42-synchronized" class="headerlink" title="42.synchronized"></a>42.synchronized</h4><p>synchronized关键字用于保证线程安全。由这个关键字修饰的方法或者代码块保证了同一时刻只有一个线程执行该代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>当一个线程访问同步代码块时，检查obj是否有锁，如果有就挂起。如果没有就获得这个obj的锁，也就是把其他线程锁在了外面。当代码执行完毕时释放该锁，其他线程获得锁继续执行代码。</p><h4 id="43-this"><a href="#43-this" class="headerlink" title="43.this"></a>43.this</h4><ol><li>指向当前对象：<a href="http://this.xxx/">this.xxx</a></li><li>形参和成员名字重名时时用this区分。</li><li>引用构造函数。</li></ol><h4 id="44-throw"><a href="#44-throw" class="headerlink" title="44.throw"></a>44.throw</h4><p>用于抛出一个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> (Exception);</span><br></pre></td></tr></table></figure><h4 id="45-throws"><a href="#45-throws" class="headerlink" title="45.throws"></a>45.throws</h4><p>在方法中将发生的异常抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[控制访问](返回类型)(方法名)([参数列表])[<span class="keyword">throws</span>(异常类)]&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="46-transient"><a href="#46-transient" class="headerlink" title="46.transient"></a>46.transient</h4><p>类接上序列化接口后，可以通过transient关键字将某些变量变得无法序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="47-try"><a href="#47-try" class="headerlink" title="47.try"></a>47.try</h4><p>在try/catch中，将可能出现异常的语句放在try{}块中，出现异常之后代码将会终止并跳到catch中继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="48-void"><a href="#48-void" class="headerlink" title="48.void"></a>48.void</h4><p>修饰方法，表示方法没有返回值。</p><h4 id="49-volatile"><a href="#49-volatile" class="headerlink" title="49.volatile"></a>49.volatile</h4><p>volatile关键字修饰的变量在多线程中保持同步。相比synchronized效率要高，不会阻塞线程。但只能保证数据的可见性，不能保证数据的原子性。例如在处理i++的时候另外一个线程修改i的值，那么i的值将会发生错误，这是原子性导致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><h4 id="50-while"><a href="#50-while" class="headerlink" title="50.while"></a>50.while</h4><p>while用于两种循环结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判读语句)&#123;</span><br><span class="line">    循环体...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体...</span><br><span class="line">&#125;<span class="keyword">while</span>(判读语句)</span><br></pre></td></tr></table></figure><h3 id="java中的标识符"><a href="#java中的标识符" class="headerlink" title="java中的标识符"></a>java中的标识符</h3><p>在编程过程中，经常需要在程序中定义一些符号来标记一些名称，如包名、类名、方法名、参数名、变量名等，这些符号被称为标识符。标识符可以由任意顺序的大小写字母、数字、下画线(_)和美元符号($ )组成，但标识符不能以数字开头，也不能是Java 中的关键字。</p><p>下面的这些标识符都是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">username</span><br><span class="line"></span><br><span class="line">username123</span><br><span class="line"></span><br><span class="line">user_name</span><br><span class="line"></span><br><span class="line">_username</span><br><span class="line"></span><br><span class="line">$username</span><br></pre></td></tr></table></figure><p>下面的这些标识符是不合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>username       <span class="comment">//不能以数字开头</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>             //不能是关键字</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Hello</span> <span class="title">World</span>       //不能包含空格特殊字符</span></span><br></pre></td></tr></table></figure><p>在Java程序中,定义的标识符必须严格遵守上面列出的规范,否则程序在编译时会报错。</p><p>为了增强代码的可读性和美观性。除了要求初学者要严格按照上面列出的规范来定义标识符外,还建议初学者在定义标识符时要遵循以下几点规范。</p><p>1.包名所有字母一律小写,例如 com.itheima. example01。</p><p>2.类名和接口名每个单词的首字母都要大写,例如 ArrayList、Iterator。</p><p>3.常量名所有字母都大写,单词之间用下画线连接,例如 DAY_OF_MONTH。</p><p>4.变量名和方法名的第一个单词首字母小写,从第二个单词开始每个单词首字母大写,例如 lineNumber、getLineNumber。</p><p>5.在程序中,应该尽量使用有意义的英文单词来定义标识符,使得程序便于阅读,例如,使用 userName 表示用户名.password 表示密码。</p><h2 id="Java中的变量和常量"><a href="#Java中的变量和常量" class="headerlink" title="Java中的变量和常量"></a>Java中的变量和常量</h2><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><p>在Java语言中，主要是利用final关键字（在Java类中灵活使用Static关键字）来定义常量。</p><p>一是常量在定义的时候，就需要对常量进行初始化。</p><p>二是final关键字使用的范围。这个final关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</p><p>三是需要注意常量的命名规则。如在给常量取名的时候，一般都用大写字符。在Java语言中，大小写字符是敏感的。之所以采用大写字符，主要是跟变量进行区分。虽然说给常量取名时采用小写字符，也不会有语法上的错误。但是，为了在编写代码时能够一目了然的判断变量与常量，最好还是能够将常量设置为大写字符。另外，在常量中，往往通过下划线来分隔不同的字符。而不想对象名或者类名那样，通过首字符大写的方式来进行分隔。</p><blockquote><p>当利用static这个关键字来修饰一个变量的时候，在创建对象之前就会为这个变量在内存中创建一个存储空间。以后创建对对象如果需要用到这个静态变量，那么就会共享这一个变量的存储空间。也就是说，在创建对象的时候，如果用到这个变量，那么系统不会为其再分配一个存储空间，而只是将这个内存存储空间的地址赋值给他。如此做的好处就是可以让多个对象采用相同的初始变量。当需要改变多个对象中变量值的时候，只需要改变一次即可。</p></blockquote><p>常量：在程序运行期间，固定不变的量。</p><p>常量的分类：<br>1.字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：“abc”、“Hello”、“123”。<br>2.整数常量：直接写上数字，没有小数点。例如：100，200,0，-250。<br>3.浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.0。<br>4.字符常量：凡是用单引号引起来的单个字符，就是字符常量。例如：‘A’、‘b’、‘9’、‘中’。<br>5.布尔常量：只有两种取值。true、false。<br>6.空常量：null。代表没有任何数据。</p><p>注意：<br>1.两个单引号中间必须有且仅有一个字符，没有不行。<br>2.两个单引号中间必须有且仅有一个字符，有两个不行。<br>3.空常量不能直接用来打印输出。</p><h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>Java数据类型图：</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/java_data_type.png" alt="数据类型"></p><h4 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h4><p>　　基本数据类型，也称内置类型，是可以在栈直接分配内存的，Java保留基本数据类型最大的原因也在此：性能。关于这一点可以参考：<a href="http://www.importnew.com/11915.html">Java为什么需要保留基本数据类型</a>。<br>　　另外，要注意，Java是基于JVM的，所以，其所占字节固定，与机器平台无关，所有地方统一占用内存大小（除了boolean，以及byte/short/boolean数组的时候每个单元所占的内存是由各个JVM自己实现的）。<br>　　总共有四类八种基本数据类型（注1）：<br>1).整型：全部是有符号类型。<br>1.<strong>byte</strong>：1字节（8bit），高位为符号位，其余7位为数据位，范围：-2^7 ~ 2^7-1（1111,1111 ~ 0111,1111），即-128 ~ 127（下面的计算方式相同）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：byte类型虽然在语义（逻辑）上是占用1字节，但实际上，JVM中是将其当做int看</span><br><span class="line">的，也就是事实上是占用了32位，4字节的，所以其运算效率和int没区别，short也一样。</span><br><span class="line">之所以要有byte&#x2F;short类型，一是因为某些地方要明确使用这些范围类型，二是，</span><br><span class="line">在byte[]数组中，JVM存储的则是真的1字节，short[]2字节。（但也有的JVM其byte[]</span><br><span class="line">数组也是4字节1位）</span><br></pre></td></tr></table></figure><p>2.<strong>short</strong>：2字节（16bit），高位为符号位，其余15位为数据位，范围：-2^15 ~ 2^15-1，即<code>-32768~32767</code>；</p><p>3.<strong>int</strong>：4字节（32bit），范围-2^31 ~ 2^31-1；Java默认的整型类型，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l &#x3D; 0xfffffffffff;&#x2F;&#x2F;0x表示这个数是16进制数，0表示8进制。</span><br><span class="line">&#x2F;&#x2F;编译器报错，因为右边默认是int，但其超出了范围（没超出int范围的话</span><br><span class="line">&#x2F;&#x2F;编译器会隐式将int转为long），故报错（同样的错误也会出现在float）。</span><br></pre></td></tr></table></figure><p>同样的还有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">short s &#x3D; 123;&#x2F;&#x2F;（这个123也是int类型，这里，&#x3D; 操作编译器能隐式转换） </span><br><span class="line">s &#x3D; s + 123;&#x2F;&#x2F;编译器报错，那是因为s+1是int类型（编译器先将s转化为int，再+1），</span><br><span class="line">&#x2F;&#x2F;这里，+ 操作编译器不能隐式转换（会提示失真，即精度可能会受损），正确的做法：</span><br><span class="line">s &#x3D; (short)(s + 123)&#x2F;&#x2F;注意，不是(short)s + 123。</span><br></pre></td></tr></table></figure><p>类型转化详见：<a href="http://blog.csdn.net/a327369238/article/details/52367968">Java 数据类型转化</a>。<br>4.<strong>long</strong>：8字节（64bit），范围：-2^63 ~ 2^63-1；声明大的long方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long l &#x3D; 0xfffffffffffL;&#x2F;&#x2F;即在后面加上L或l。</span><br><span class="line">&#x2F;&#x2F;（强制转化：long l &#x3D; (long)0xfffffffffff也没用）</span><br></pre></td></tr></table></figure><p>2).浮点型<br>5.<strong>float</strong>：4字节（32bit），单精度，数据范围：(-2^128) ~ (-2^(-23-126))-(0)-(2^-149) ~ 2^128。浮点数，通俗来说就是小数，但是，这是有精度要求的，即在这区间float可不是能表达任意小数的，而是在一定精度下，比如float有效位7 ~ 8位（包括整数位和小数位，有效小数位是6 ~ 7位，这里为什么是7 ~ 8（6 ~ 7），参考：<a href="http://blog.csdn.net/a327369238/article/details/52354811">Java中float/double取值范围与精度</a>），即0.123456789后面的9JVM是不认识的（8能认识，整数位为0则不算是有效位，例如12.1234567后面的7也不认识，只有6位有效小数位（注意，看的是有效位，不是有效小数位，float有7~8位有效位）），即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(0.123456781f &#x3D;&#x3D; 0.123456789f)&#123;&#x2F;&#x2F;注意后面加f&#x2F;F，否则就是double</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印结果：true</span><br><span class="line">&#x2F;&#x2F;事实上，浮点数值的比较是不能直接用&#x3D;&#x3D;判断的，这里原因就要追究到浮点数的内存结构</span><br><span class="line">&#x2F;&#x2F;浮点数比较可以用一个差值，但这种情况只是近似的比较</span><br><span class="line">&#x2F;&#x2F;如果想要精确，可以使用BigDecimal</span><br><span class="line">System.out.println(Float.MIN_VALUE);&#x2F;&#x2F;1.4E-45 &#x3D; 2^-149</span><br><span class="line">&#x2F;&#x2F;这里的“最小值”意味float能表示的最小小数，实际上float最小值等于最大值取负</span><br><span class="line">System.out.println(Float.MAX_VALUE);&#x2F;&#x2F;3.4028235E38 &#x3D; 2^128</span><br></pre></td></tr></table></figure><p>6.<strong>double</strong>：8字节（64bit），双精度，范围：-2^1024 ~ (-2^(-1022-52))-0-(2^－1074) ~ 2^1024，Java默认的浮点类型，即若后面不加f/F，默认是double类型，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float f &#x3D; 1.23;&#x2F;&#x2F;编译报错，因为</span><br><span class="line">float f &#x3D; 1.23f;&#x2F;&#x2F;或float f &#x3D; 1.23F;</span><br><span class="line">&#x2F;&#x2F;默认是double，1.23(double)转成float，做隐式转换，但是double转成float是</span><br><span class="line">&#x2F;&#x2F;取值范围大的转成取值范围小的会损失精度，因此不能转换（详见Java数据类型转换）</span><br><span class="line">&#x2F;&#x2F;那为什么，int可以转换成byte、short，int范围更大不是？</span><br><span class="line">&#x2F;&#x2F;前面已经说过了，byte、short实际在JVM上就是int，因此编译器是不会认为会损失精度的</span><br><span class="line">&#x2F;&#x2F;但是int是不能转换成boolean，虽然boolean也是4字节（一般JVM），但在JVM认为这</span><br><span class="line">&#x2F;&#x2F;两者完全是两个东西，当然不能转换（强制也不行，你不能把猫强制转换成鸟，完全两个物种），而byte、short都是整型，同int是一个类型</span><br></pre></td></tr></table></figure><p>3).字符型<br>7.<strong>char</strong>：2字节（16bit），表示一个字符（可以是汉字），字符编码采用Unicode（说的更准确点，字符集（charset）采用UCS-2，编码（encoding）采用UTF-16），实际上就是一个16位的无符号整型，但是，要注意的是，因为随着发展，char所能代表的字符个数（UCS-2字符集）被限定死了，所以并不推荐使用。（更多内容，以及关于Unicode、UTF8/16参考：Unicode、UTF8以及Java char。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; 3+5;&#x2F;&#x2F;正确，char是无符号整型，但不能这样</span><br><span class="line">int a1 &#x3D; 3;int a2 &#x3D; 5;char c0 &#x3D; a1+a2;&#x2F;&#x2F;这里需要强制转换才行</span><br><span class="line">char c1 &#x3D; -3;&#x2F;&#x2F;编译错误，char不能表示负数，即使</span><br><span class="line">char c2 &#x3D; (char)-3;&#x2F;&#x2F;编译正确，但无意义（乱码）</span><br><span class="line">char c3 &#x3D; &#39;3&#39;;&#x2F;&#x2F;正确，输出字符3</span><br><span class="line">char c4 &#x3D; &quot;3&quot;;&#x2F;&#x2F;编译错误，双引号，表示的是字符串</span><br><span class="line">char c5 &#x3D; &#39;65&#39;;&#x2F;&#x2F;编译错误，这里65是两个字符</span><br></pre></td></tr></table></figure><p>4).布尔型<br>8.<strong>boolean</strong>：逻辑上：1bit，但是实际上，boolean并没有具体规定，完全是看各个JVM实现，不过《Java虚拟机规范》给出了4个字节（同byte解释）和boolean数组一个字节的定义。</p><p>注1：<br>(1).这种分法是一种比较流行的分法，事实上应该为两种：数值类型与布尔型。数值类型分为整型和浮点型。整型包括：byte、short、int、long、char；浮点型：float、double；布尔型boolean。之所以将char认为是整型是因为char在JVM就是以无符号整型存在的。<br>(2).事实上Java中除去这8种以及对象类型，还有一种比较特殊的类型存在，那就是Void。java.lang.Void，是一个占位符类，不可实例化，保存着Java关键字void的Class对象。为什么说它特殊呢？明明是一个类，难道不是对象类型？那是因为void.class.isPrimitive()（这个方法是用来判断一个Class对象是否是基本类型的）返回的是true，所以Void也算是基本类型的一个了（错了），只不过它比较特殊，不能算是一种数据，只是一种象征。<br>20160921 改：上面弄错了，把Void和void两个混为一体了，事实上，可以简单的把这两者的关系看成类似包装类和基本类型的关系，像Integer和int的关系，java.lang.Void是一个不可实例化的占位符类来保存一个引用代表了Java关键字void的Class对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final Class&lt;Void&gt; TYPE &#x3D; Class.getPrimitiveClass(&quot;void&quot;);</span><br></pre></td></tr></table></figure><p>而Integer也有类似的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final Class&lt;Integer&gt;  TYPE &#x3D; (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);</span><br></pre></td></tr></table></figure><p>区别只是，Void仅仅是为void服务，即所谓的占位符类，不做他用。所以Void类只是一个普通类，而void则可以认作为如同int一样的基本类型。</p><h4 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h4><p>简要提一下引用数据类型：字符串、数组、类、接口、Lambda。</p><p>也称对象变量类型，复合数据类型，包含类、接口、数组（除了基本类型外，就是引用类型）。引用类型与基本类型最大的区别在于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 5;&#x2F;&#x2F;这里的a是对象（严格来说不算是对象，只是个符号标识），5是数值</span><br><span class="line">Integer a &#x3D; 5;&#x2F;&#x2F;这里的a是一个引用，5才是一个对象，更形象常见的是：</span><br><span class="line">Object o &#x3D; new Object();&#x2F;&#x2F;o是引用（栈中），new Object()是对象（堆中）</span><br><span class="line">&#x2F;&#x2F;第二行代码中，5被自动包装成Integer对象</span><br></pre></td></tr></table></figure><p>这里的引用有点像C/C ++中的指针，但是同指针不同的是，你不能通过改变它的值从而去改变它所指向的值。即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassA p &#x3D; new ClassA();&#x2F;&#x2F;C++中，这个时候是可以这样操作的：</span><br><span class="line">p &#x3D; p + 1;&#x2F;&#x2F;向前移动一个单元，Java则不能</span><br><span class="line">&#x2F;&#x2F;这种操作，其实是对内存直接的操作，很显然，Java是不允许程序员做这种操作的</span><br></pre></td></tr></table></figure><p>　　其实质就是，Java的引用不支持对内存直接操作，而指针则可以，所以，Java用起来更安全，但不够灵活，而指针，自由度大，但同时，要更加小心因为指针操作不当而引起的各种内存问题。在Java中，任何对象都需要通过引用才能访问到，没有引用指向的对象被视为垃圾对象，将会被回收（GC）。<br>　　引用，其实质同指针一样（可以理解为受限制的指针），存放的是一个地址，至于是实例对象的地址，还是一个指向句柄池的地址（这里可以参考：<a href="http://blog.csdn.net/a327369238/article/details/52094738">(3) Java内存结构</a>），完全是看各个JVM的实现了。<br>　　Java中的枚举类型，都是Enum类的子类，算是类中的一种，也是引用类型。<br>　　引用类型又称为对象变量类型，是相对于基本数据类型来说的（基本数据类型不是对象），而又被称为复合数据类型，可以这样理解，引用类型的数据最终都是由基本数据类型构成的。而像接口，接口是不能实例化的，最终的实现还是由类实现的；数组在JVM中的实现也是通过类实现的，每个类型的一维数组，二维数组……都是一个类，只是这是一个特殊的类，它的对象头有别于一般对象的对象头（最主要的就是，数组对象头有对象长度）。<br>　　另外，关于Java引用可以参考：<a href="http://blog.csdn.net/a327369238/article/details/52384649">Java中的引用</a>。</p><p>取值范围与内存占用不相关，就比如说图中的long占用8个字节而单精度浮点数float只占用四个字节，但是float的取值范围却比long的取值范围大很多，这是因为float采用的是科学计数法计算省空间。</p><p>注意事项：<br>1.字符串不是基本类型，而是引用类型。<br>2.浮点型可能只是一个近似值，并非精确值。<br>3.数据范围与字节数不一定相关。例如：float数据范围比long更加广泛，但是float是4字节，long是8字节。<br>4.浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。<br>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。大小写后缀都可以，推荐使用大写字母后缀。</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量：程序运行期间，内容可以发生改变的量。</p><p>创建一个变量并且使用的格式：数据类型 变量名称; 变量名称 = 数据值;</p><p>一步到位的格式：数据类型 变量名称 = 数据值;//在创建一个变量的同时，立刻放入指定的数据值。</p><p>用long 和 float时要加后缀。例如：long num = 30000000000L; float num = 2.5F;</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>当数据类型不一样时，将会发生数据类型转换。</p><p>数据类型转换分为两类：</p><p> 自动类型转换（隐式）<br>  1.特点：代码不需要进行特殊处理，自动完成。<br>  2.规则：数据范围从小到大。</p><p> 强制类型转换（显式）<br>  1.特点：代码需要进行特殊的格式处理，不能自动完成。<br>  2.格式：范围小的数据类型 范围小的变量名 = （范围小的类型）原本范围大的数据; 例如：int num = (int) 100L;</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>规定了变量所能使用的范围，只有在作用域范围内变量才能被使用。根据变量声明地点的不同，变量的作用域也不同。<br>根据作用域的不同，一般将变量分为不同的类型：类变量、局部变量、方法参数变量及异常处理参数变量。</p><ul><li>类变量<br>类变量也称为成员变量，声明在类中，不属于任何一个方法，作用域是整个类。</li><li>局部变量<br>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。</li><li>方法参数变量<br>作为方法参数声明的变量的作用域是整个方法。</li><li>异常处理参数变量<br>异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基本语法和变量及常量：Java的语法格式、注释、关键字、数据类型、常量和变量的声明及其作用域。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Variable" scheme="http://yoursite.com/tags/Variable/"/>
    
    <category term="Annotation" scheme="http://yoursite.com/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Java技能树-Java概述</title>
    <link href="http://yoursite.com/article/761b2c7d.html"/>
    <id>http://yoursite.com/article/761b2c7d.html</id>
    <published>2022-05-14T10:07:16.000Z</published>
    <updated>2025-10-22T03:11:19.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java概述：Java程序的Hello World、JDK安装和环境配置、Java的编译和运行、JVM虚拟机、Maven管理工具</p></blockquote><a id="more"></a><h2 id="编辑Java源代码"><a href="#编辑Java源代码" class="headerlink" title="编辑Java源代码"></a>编辑Java源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWord&#123;</span><br><span class="line">    &#x2F;&#x2F;java程序的入口方法，程序将从这里开始执行</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;向控制台打印一条语句</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译Java程序"><a href="#编译Java程序" class="headerlink" title="编译Java程序"></a>编译Java程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure><h2 id="Java的运行机制"><a href="#Java的运行机制" class="headerlink" title="Java的运行机制"></a>Java的运行机制</h2><blockquote><p>🍎Java程序运行时,必须经过编译和运行两个步骤。<br>🍊 首先将后缀名为.java的源文件进行编译,最终生成后缀名为.class的字节码文件。然后Java虚拟机将字节码文件进行解释执行,并将结果显示出来<br>🍉Java程序的运行过程详细解释<br>🍋1、编写一个HelloWorld.java文件<br>🍋2、使用javac HelloWorld.java 命令开启Java编译器并进行编译。编译结束后,会自动生成一个HelloWorld.class的字节码文件<br>🍋3、使用java HelloWorld 命令启动Java虚拟机运行程序,Java虚拟机首先将编译好的字节码文件加载到内存,<strong>这个过程被称为类加载</strong>,它是由类加载器完成的,然后虚拟机针对加载到内存中的Java类进行解释执行,便可看到运行结果</p></blockquote><p>以下关于Java的运行机制中描述正确的是：</p><ol><li>ClassLoader 是 JVM 实现的一部分</li><li>Java 编译器会将程序编译为 Java 虚拟机可以执行的字节码</li><li>Java 虚拟机（Java Virutal Machine）简称 JVM ，用于执行 Java 字节码</li><li>Java 运行时环境（Java Runtime Evironment）简称 JRE ，用于运行 Java 程序，包含 JVM</li><li>Java 开发工具包（Java Development Kit）用于开发Java程序，包含JRE和 Java 编译工具等</li></ol><blockquote><p>Java语言具有”一次编写,到处运行(Write one , run anywhere)”的特点,有效地解释了程序设计语言在不同操作系统编译时产生不同机器代码的问题,大大降低了程序开发和维护的成本。需要注意的是,Java程序通过Java虚拟机可以达到跨平台特性,但Java虚拟机并不是跨平台的,也就是说,不同操作系统上的Java虚拟机是不同的,即Windows平台上的Java虚拟机不能使用在Linux平台上。</p></blockquote><h2 id="Java程序的环境配置"><a href="#Java程序的环境配置" class="headerlink" title="Java程序的环境配置"></a>Java程序的环境配置</h2><p>安装完JDK(Java Development Kit，Java开发套件)之后，可以在安装目录下找到两个子目录(bin目录和lib目录)。bin目录中包含着Java编译器等可执行文件。</p><p>如果要运行执行java命令，必须得执行java命令对应的可执行文件的路径，通常有两种方式：</p><ul><li>在%JAVA_HOME%目录下执行。</li><li>执行命令的时候，指明路径%JAVA_HOME%/bin/java</li></ul><p>但是，这样不是特别方便，这就是为什么配置环境变量。</p><p>JAVA_HOME环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_51\</span><br></pre></td></tr></table></figure><p>通常将下面的内容加到PATH环境变量的最左侧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%JAVA_HOME%&#x2F;bin&#x2F;;%JAVA_HOME%&#x2F;jre&#x2F;bin</span><br></pre></td></tr></table></figure><p>和PATH变量不同，CLASSPATH环境变量的作用是指定Java类所在的目录(或许它的意思就是<code>PATH of Class</code>)。</p><p>Java中通常将环境变量CLASSPATH配置为<code>.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar</code>。其中为何包含<code>.</code>，</p><p>dt.jar：运行环境类库，主要是Swing包，这一点通过用压缩软件打开dt.jar也可以看到。如果在开发时候没有用到Swing包，那么可以不用将dt.jar添加到CLASSPATH变量中。</p><p>tools.jar：工具类库，它跟我们程序中用到的基础类库没有关系。我们注意到在Path中变量值bin目录下的各个exe工具的大小都很小，一般都在27KB左右，这是因为它们实际上仅仅相当于是一层代码的包装，这些工具的实现所要用到的类库都在tools.jar中，用压缩软件打开tools.jar,你会发现有很多文件是和bin目录下的exe工具相对性的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c:\test&gt;type HelloWorld.java   #查看文本文件的内容</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                System.out.println(&quot;Hello World!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">c:\test&gt;javac HelloWorld.java   #因为配置了PATH环境变量，在任意目录下都可执行javac</span><br><span class="line"></span><br><span class="line">c:\test&gt;dir   #查看编译生成的class文件</span><br><span class="line">2016&#x2F;03&#x2F;28  22:13               427 HelloWorld.class</span><br><span class="line">2016&#x2F;03&#x2F;28  22:08               152 HelloWorld.java</span><br><span class="line">c:\test&gt;java HelloWorld   #运行HelloWorld(注意，不能加.class后缀)</span><br><span class="line">错误: 找不到或无法加载主类 HelloWorld</span><br></pre></td></tr></table></figure><h2 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h2><p>Maven的作用</p><p>maven本质上是一个项目管理工具，是将项目开发和管理过程抽象成一个项目对象模型（POM:project object model）</p><p>maven可以为我们进行项目构建(提供标准化，跨平台的zi’dong话项目构建方式)，依赖管理(方便快捷的管理项目的依赖资源jar包，避免资源及版本的冲突)，同意开发结构：提供标准统一的项目结构。</p><p>Maven的安装：maven属于是绿色软件，解压即安装</p><p><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p>Maven文件结构：</p><ul><li>bin:maven的核心运行文件</li><li>boot：mavem的类加载器</li><li>conf：maven的核心配置</li><li>lib：maven的依赖jar包</li></ul><p>Maven环境变量配置</p><ul><li>依赖于java，需要配置JAVA_HOME</li><li>设置Maven自身的MAVEN_HOME</li><li>运行cmd输入mvn检测是否安装成功</li></ul><p>Maven的基础概念</p><p><strong>仓库</strong>：用于存储各种资源，包含各种jar包</p><p><img src="https://img-blog.csdnimg.cn/c67076183eeb4a2394e5ee869ffecc44.png" alt="img"></p><p>仓库分类：</p><ul><li>本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源</li><li>远程仓库：非自己电脑上的仓库，为本地仓库提供资源</li><li><ul><li>中央仓库：Maven团队维护，存储所有资源的仓库</li><li>私服：部门/公司范围内存储的仓库，从中央仓库获取资源</li></ul></li><li>私服的作用：</li><li><ul><li>保存具有版权的资源，包含自主研发或购买的jar(中央仓库的的jar包都是开源的，不能存储具有版权的资源)</li><li>一定范围内共享资源，仅对内部开放，不对外共享。</li></ul></li></ul><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>坐标是用来在仓库中资源的位置的。</p><p><a href="https://repo1.maven.org/maven2/%E8%AF%A5%E9%93%BE%E6%8E%A5%E4%B8%AD%E6%98%AFmaven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E8%B5%84%E6%BA%90%E3%80%82">https://repo1.maven.org/maven2/该链接中是maven中央仓库资源。</a></p><p>maven坐标的组成：</p><ul><li>groupId:定义当前Maven项目隶属于组织的名称（通常是域名反写）</li><li>artifactld:定义当前Maven项目的名称（通常是模块名称，例如：CRM,SMS）</li><li>version:定义当前项目的版本号</li><li>packaging:定义当前项目的打包方式</li></ul><h4 id="本地仓库配置"><a href="#本地仓库配置" class="headerlink" title="本地仓库配置"></a>本地仓库配置</h4><ol><li><p>进入Maven的conf文件夹中的setting文件</p><ul><li><p>默认的仓库配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br></pre></td></tr></table></figure></li><li><p>自定义自己的仓库位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;localRepository&gt;D:\maven\repository&lt;&#x2F;localRepository&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure></li><li><p>中央仓库的配置位置</p><p>在lib文件中随便找一个jar包用winrar打开，然后返回上一级目录搜索pom*.*,找到pom-4.0.0.xml文件，定位到。将文件拖出后打开。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/9f4df60aad1443bca569a9a81a7a0763.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3LTSJRym-1638532754173)(D:\Document\note\框架\maven\远程仓库.png)]"></p><ul><li><p>远程镜像仓库的配置（当需要访问中央仓库的时候，就会去访问镜像仓库。ps:中央仓库在国外，访问速度慢）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置具体仓库的下载镜像 --&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;!-- 此镜像的唯一标识符，用来区分不同的mirror元素 --&gt;</span><br><span class="line">    &lt;id&gt;ali-maven&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;!-- 对哪种仓库进行镜像，简单说就是代替哪个仓库 --&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">    &lt;!-- 镜像的名称 --&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;!-- 镜像的URL --&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="Maven项目构建命令"><a href="#Maven项目构建命令" class="headerlink" title="Maven项目构建命令"></a>Maven项目构建命令</h4><p>后面的命令在执行的时候都会执行前面的命令，如：在执行install的时候前面的生命周期都会执行。</p><ul><li><p>mvn -v 查看版本</p></li><li><p>mvn compile 编译(在src同级目录下生成一个target文件)</p></li><li><p>mvn clean 清理(删除target文件)</p></li><li><p>mvn test 测试(会在编译同时将test的部分也编译，并执行test内测试方法的内容，在surefile-reports中生成报告内容)</p></li><li><p>mvn package 打包(target文件中生成一个jar包)</p></li><li><p>mvn install 安装到自己本地仓库</p></li><li><p>mvn archetype: generate生成maven项目</p></li></ul><h4 id="idea使用maven命令"><a href="#idea使用maven命令" class="headerlink" title="idea使用maven命令"></a>idea使用maven命令</h4><p> 在idea的右边有一个maven选项，打开后点击声明周期可以运行maven的命令（与命令效果相同）</p><p>也可以点击上方的锤子选择Maven，添加命令在执行达到一样的效果（<strong>优点</strong>：可以使用debug模式运行）</p><h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    <span class="comment">//单个依赖</span></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;排除包含</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &#x2F;&#x2F;具体排除的依赖</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br></pre></td></tr></table></figure><h4 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h4><ul><li>依赖的jar默认可以在任何地方使用，可以通过scope标签设定其作用的范围</li><li>作用范围</li><li><ul><li>主程序范围内有效(main文件范围内)</li><li>测试程序范围内有效(test文件范围内)</li><li>是否参与打包(package指令范围内)</li></ul></li></ul><table><thead><tr><th align="left">scope</th><th align="left">主代码</th><th align="left">测试代码</th><th align="left">打包</th><th align="left">范例</th></tr></thead><tbody><tr><td align="left">compolie(默认)</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">log4j</td></tr><tr><td align="left">test</td><td align="left"></td><td align="left">Y</td><td align="left"></td><td align="left">junit</td></tr><tr><td align="left">provided</td><td align="left">Y</td><td align="left">Y</td><td align="left"></td><td align="left">servlet-api</td></tr><tr><td align="left">runtime</td><td align="left"></td><td align="left"></td><td align="left">Y</td><td align="left">jdbc</td></tr></tbody></table><h3 id="项目的构建生命周期"><a href="#项目的构建生命周期" class="headerlink" title="项目的构建生命周期"></a>项目的构建生命周期</h3><p> Maven对项目构建生命周期分为三个阶段,不同阶段有不同的过程事件</p><ul><li>clean:清理工作</li><li><ul><li>pre-clean :执行一些需要在clean之前完成的工作</li><li>clean:移除上一次构建生成的文件</li><li>post-clean:执行一些在clean之后立即完成的工作</li></ul></li><li>defult:核心工作，例如编译，测试，打包，部署等</li></ul><p><img src="https://img-blog.csdnimg.cn/cc6ab85acf374e68a5cd5f1fda5348d6.png" alt="img"></p><ul><li>site:产生报告，发布站点</li><li><ul><li>pre-site:执行一些在生成站点文件前要完成的工作</li><li>site:生成项目的站点文件</li><li>post-site:执行一些需要在生成站点文件后完成的工作，为部署做准备</li><li>site-deploy:将生成的站点文档部署到特定的服务器上</li></ul></li></ul><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应插件功能</li><li>默认Maven的各个生命周期上绑定有预定的预设功能</li><li>通过插件可以自定义其他功能</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--具体插件：对test区域源代码的打jar--&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">    &lt;!--插件的行为--&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;!--具体行为--&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;!--目标：执行的结果，这里时打jar包，并未所有的插件都有--&gt;</span><br><span class="line">                &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">      &lt;!--可以打多个jar包--&gt;</span><br><span class="line">    &lt;goal&gt;test-jar&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;!--在哪个阶段执行--&gt;</span><br><span class="line">            &lt;phase&gt;generate-test-sources&lt;/phase&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java概述：Java程序的Hello World、JDK安装和环境配置、Java的编译和运行、JVM虚拟机、Maven管理工具&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
    <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>多媒体视频处理工具FFmpeg</title>
    <link href="http://yoursite.com/article/b3c1f4b1.html"/>
    <id>http://yoursite.com/article/b3c1f4b1.html</id>
    <published>2022-05-13T10:07:06.000Z</published>
    <updated>2025-10-22T03:11:19.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。</p></blockquote><a id="more"></a><p>FFmpeg常用命令解析<br><a href="https://www.cnblogs.com/Dicky-Zhang/p/11838416.html">https://www.cnblogs.com/Dicky-Zhang/p/11838416.html</a></p><p>ffFFmpegpg处理视频<br>example：m3u8转mp4<br><a href="https://www.cnblogs.com/zhangceblogs/p/8514443.html">https://www.cnblogs.com/zhangceblogs/p/8514443.html</a></p><p><a href="https://github.com/FFmpeg/FFmpeg">https://github.com/FFmpeg/FFmpeg</a><br><a href="https://github.com/BtbN/FFmpeg-Builds">https://github.com/BtbN/FFmpeg-Builds</a><br>下载：ffmpeg-n-104327-g1902a60dda-win64-gpl.zip</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发常用的开发工具</title>
    <link href="http://yoursite.com/article/bdc11bc8.html"/>
    <id>http://yoursite.com/article/bdc11bc8.html</id>
    <published>2022-05-13T10:06:57.000Z</published>
    <updated>2025-10-22T03:11:19.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分享的关于Web前端开发常用的十款很优秀的开发工具汇总。</p></blockquote><a id="more"></a><ol><li>Glitch<br><a href="https://glitch.com/">https://glitch.com</a><br>好的，这不仅仅是一个工具，还是一个非常棒的编码平台以及一个很棒的技术社区。我可以在内置代码编辑器的帮助下托管我的项目。支持多种语言，但最适合NodeJS。</li><li>Shadows<br><a href="https://brumm.af/shadows">https://brumm.af/shadows</a><br>这个网站提供生成平滑阴影的CSS代码，可以创建平滑的边框阴影。它看起来真的很流畅，令人满意。</li><li>Coolors<br><a href="https://coolors.co/">https://coolors.co</a><br>这是一款非常好的在线工具，可以为项目生成匹配的颜色方案。如果不喜欢当前的方案，按下空格键，它会重新生成一个配色方案，直到你满意~</li><li>Blobmaker<br><a href="https://blobmaker.app/">https://blobmaker.app</a><br>Blobmaker可帮助你随机生成各种尺寸，不同颜色和形状的SVG Blob。你可以用作背景或创建看起来很酷的动画。</li><li>Getwavs<br><a href="https://getwaves.io/">https://getwaves.io</a><br>与Blobmaker相似，Get Waves能够随机生成不同颜色和不同数量的波浪。用作网页的页脚或页眉看起来不错。</li><li>Undraw.co<br><a href="https://undraw.co/">https://undraw.co</a><br>开放源代码项目的SVG插图集，可用来做登录页面，404页面等，当然普通页面也能用!上面的插图可以不带归属地版权的使用，无需支付任何费用。</li><li>Marcdown<br><a href="https://liyasthomas.github.io/marcdown">https://liyasthomas.github.io/marcdown</a><br>由Liyas Thomas提供的在线实时的Markdown网页编辑器，它可预览Markdown代码，将其发布到GitHub上。它提供一个非常漂亮的暗黑模式。还可脱机工作，这使得它显得更出色。</li><li>postwoman<br><a href="https://postwoman.io/">https://postwoman.io</a><br>这是Liyas Thomas构建的另一个工具。Postwoman是一个API请求构建工作。开发者可以不使用代理来测试 API。这是一个渐进式Web应用程序，可以保存到桌面来用。它是轻量级的产品，基本上可以是Postman的在线替代品。</li><li>Screely.com<br><a href="https://screely.com/">https://screely.com</a><br>它可以帮助你创建超级漂亮的网站截图模型。如果你不是MacBook用户，但需要更好的网站图片作为自述文件，它非常适合我们。</li><li>CSS网格生成器<br><a href="https://cssgrid-generator.netlify.com/">https://cssgrid-generator.netlify.com/</a><br>这是Sarah Drasner的创建的优秀网站，它使用CSS创建动态网格布局。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;分享的关于Web前端开发常用的十款很优秀的开发工具汇总。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Glitch" scheme="http://yoursite.com/tags/Glitch/"/>
    
    <category term="Postman" scheme="http://yoursite.com/tags/Postman/"/>
    
    <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Windows修改DNS方法</title>
    <link href="http://yoursite.com/article/7c78b42f.html"/>
    <id>http://yoursite.com/article/7c78b42f.html</id>
    <published>2022-05-12T07:08:37.000Z</published>
    <updated>2025-10-22T03:11:19.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DNS是域名系统，我们链接互联网的时候，仅仅有一个IP地址是不够的，还需要设置域名，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取IP数串。通过域名，最终得到该域名对应IP地址的过程叫做域名解析（或主机名解析）。</p></blockquote><a id="more"></a><p>修改DNS的好处就是可以适当提高上网速度；更换DNS可以访问某些因为域名解析存在问题而不能访问的网站；可以屏蔽运营商的广告，还可以帮助您避免被钓鱼的危险；</p><p>当然修改DNS也有可能带来副作用，比如无法访问页面或者访问的页面不是你想要的页面；访问速度没有你从运营商处获得的DNS访问分速度快，延时比较大；受到DNS劫持，插入广告和被钓鱼网站攻击。</p><h3 id="Windows修改DNS步骤"><a href="#Windows修改DNS步骤" class="headerlink" title="Windows修改DNS步骤"></a>Windows修改DNS步骤</h3><p>1.打开windows设置，找到并单击“网络和Internet”选项;</p><p>2.右侧下拉找到“更改适配器选项”，单击打开;</p><p>3.右键你的以太网，选择“属性”打开;</p><p>4.进入后下拉下方选项，找到“Internet 协议版本 4 (TCP/IPv4)”选项并选中，单击“属性”进入;</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/dns_ipv4.png" alt="TCP/IPV4属性"></p><p>5.进入后即可勾选为“使用下面的DNS服务器地址”选项，进行DNS服务器设置，确定保存即可。</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/dns_server.png" alt="DNS服务器设置"></p><p>6.返回桌面重启电脑或者重启网卡即可设置完成。</p><h3 id="常用的DNS服务器"><a href="#常用的DNS服务器" class="headerlink" title="常用的DNS服务器"></a>常用的DNS服务器</h3><ul><li><p>阿里的DNS是223.5.5.5和223.6.6.6</p></li><li><p>百度的DNS是180.76.76.76</p></li><li><p>114的DNS是114.114.114.114和114.114.115.115</p></li><li><p>谷歌的DNS是8.8.8.8和8.8.8.4</p></li><li><p>微软官方推荐使用的DNS服务器地址为4.2.2.1以及4.2.2.2</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DNS是域名系统，我们链接互联网的时候，仅仅有一个IP地址是不够的，还需要设置域名，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取IP数串。通过域名，最终得到该域名对应IP地址的过程叫做域名解析（或主机名解析）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Windows" scheme="http://yoursite.com/categories/Windows/"/>
    
    
    <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
    <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack常用组件介绍</title>
    <link href="http://yoursite.com/article/5ad2a15a.html"/>
    <id>http://yoursite.com/article/5ad2a15a.html</id>
    <published>2022-05-11T11:25:01.000Z</published>
    <updated>2025-10-22T03:11:19.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JetPack架构组件:ViewModel、LiveData、ViewBinding、DataBinding、LifeCycle、Room等的介绍、使用场景和使用方法。</p></blockquote><a id="more"></a><h2 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h2><p>LifeCycle应用</p><blockquote><p>使用ltifecycle解耦页面与组件<br>使用LifecycleService解耦Service与组件<br>使用ProcessLifecycleOwner监听应用程序生命周期</p></blockquote><p>LifeCycle的好处</p><blockquote><p>1.帮助开发者建立可感知生命周期的组件<br>2.组件在其内部管理自己的生命周期，从而降低模块耦合度<br>3.降低内存泄漏发生的可能性<br>4.Activity、Fragment、Service、Application均有LifeCycle支持(LifecycleObserver、LifecycleService、ProcessLifecycleOwner)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">控件结合Lifecycle</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChronometer</span> <span class="keyword">extends</span> <span class="title">Chronometer</span> <span class="keyword">implements</span> <span class="title">Lifecycle0bserver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> elapsedTime;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyChronometer</span> <span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span> ( context, attrs) ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span> (Lifecycle.Event.ONRESUME)   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startMeter</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">setpase (SystemClock.elapsedRealtime() - elapsedTime) ;</span><br><span class="line">        start ( );</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span> (Lifecycle.Event.ONSTOP)    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopMeter</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">elapsedTime = SystemClock.elapsedRealtime() - getBase();</span><br><span class="line">        stop () ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity添加监听</span></span><br><span class="line">getLifecycle().addOnserver(chronomter)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationService</span> <span class="keyword">extends</span> <span class="title">LifecycleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationService</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">Log.d ( tag: <span class="string">&quot;ning&quot;</span> , msg: <span class="string">&quot;MyLocationService&quot;</span> ) ;</span><br><span class="line">MyLocation0bserver observer = <span class="keyword">new</span> MyLocationObserver ( context: <span class="keyword">this</span>) ;</span><br><span class="line">        getLifecycle ( ) .addobserver (observer) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel的诞生</p><blockquote><p>瞬态数据丢失<br>异步调用的内存泄漏<br>类膨胀提高维护难度和测试难度</p></blockquote><p>ViewModel的作用</p><blockquote><p>1.它是介于View(视图）和Model（数据模型）之间的桥梁<br>2.使视图和数据能够分离，也能保持通信</p></blockquote><p>ViewModel的生命周期特性</p><blockquote><p>独立于配置变化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旋转屏幕不会丢失数据</span></span><br><span class="line">MyViewModel extents ViewModel</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel</span></span><br><span class="line">viewModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>,<span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>，<span class="keyword">new</span> AndroidViewModelFactory(<span class="keyword">this</span>)).get(MViewModel.class))</span><br><span class="line">++ viewModel.num</span><br><span class="line">text.setText(viewModel.num)</span><br></pre></td></tr></table></figure><p>AndroidViewModel</p><blockquote><p>1.不要向ViewModel中传入Context，会导致内存泄漏<br>2.如果要使用Context，请使用AndroidViewModel中的Applications</p></blockquote><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>LiveData和ViewModel的关系</p><blockquote><p>在ViewModel中的数据发生变化时通知页面</p></blockquote><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_livedate.png" alt="Jetpack LiveData"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyviewModel</span> <span class="keyword">extends</span> <span class="title">viewModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MutableLiveData是LiveData子类</span></span><br><span class="line"><span class="keyword">private</span> MutableLiveData&lt;Integer&gt; currentsecond;</span><br><span class="line">    <span class="comment">//private MutableLiveData&lt;Integer&gt; currentsecond = new MutableLiveData&lt;&gt;(0);</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title">getCurrentSecond</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(currentSecond == <span class="keyword">null</span>) &#123;</span><br><span class="line">currentsecond = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">            currentsecond.setvalue (<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currentSecond;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非UI线程使用postVaule(),UI线程使用setvalue()</span></span><br><span class="line">viewModel.getCurrentSecond().postValue</span><br><span class="line">    </span><br><span class="line"><span class="comment">//监听LiveData数据变化</span></span><br><span class="line">viewModel.getCurrentSecond().observe(<span class="keyword">this</span>,<span class="keyword">new</span> Observerr&lt;Interger&gt;()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(Interger i)</span></span>&#123;</span><br><span class="line">        textview.setText(String.valueOf(i));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>LiveData的优势</p><blockquote><p>确保界面符合数据状态<br>不会发生内存泄漏<br>不会因Activity停止而导致崩溃<br>不再需要手动处理生命周期<br>数据始终保持最新状态<br>适当的配置更改<br>共享资源</p></blockquote><h2 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h2><p>DataBinding的意义</p><blockquote><p>让布局文件承担了部分原本属于页面的工作，使页面与布局耦合度进一步降低</p></blockquote><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_databinding.png" alt="Jetpack DataBinding"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build配置</span></span><br><span class="line">dataBinding = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布局生成databinding layout</span></span><br><span class="line"><span class="comment">//导入方法：布局文件使用代码</span></span><br><span class="line"><span class="comment">//&lt;import type=&quot;com.dongnaoedu.databinding.star0tils&quot;/&gt;</span></span><br><span class="line">&lt;Layout</span><br><span class="line">&lt;data&gt;</span><br><span class="line"> &lt;variable</span><br><span class="line"> name=<span class="string">&quot;idol&quot;</span></span><br><span class="line"> type=<span class="string">&quot;com.dongnaoedu.databinding.Ido1&quot;</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//ActivityMainBinding由来</span></span><br><span class="line">ActivityMainBinding binding = DataBingingUtil.setcontentView(<span class="keyword">this</span>,R.layout.activity_main);</span><br><span class="line">Idol idol = <span class="keyword">new</span> Idol（<span class="string">&quot;name&quot;</span>,<span class="number">5</span>);</span><br><span class="line">binding.setIdol(idol);</span><br><span class="line"></span><br><span class="line"><span class="comment">//xml获取属性</span></span><br><span class="line">android:text=<span class="string">&quot;@&#123;idol.name&#125;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按钮点击事件绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义点击事件监听类</span></span><br><span class="line">EventHandleListener&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">onclick</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加绑定</span></span><br><span class="line">binding。setEventHandleListener(<span class="keyword">new</span> EventHandleListener(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//布局文件添加事件类</span></span><br><span class="line">&lt;data&gt;</span><br><span class="line"> &lt;variable</span><br><span class="line"> name=<span class="string">&quot;eventHandle&quot;</span></span><br><span class="line"> type=<span class="string">&quot;com.dongnaoedu.databinding.EventHandleListener&quot;</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">    </span><br><span class="line">&lt;Button</span><br><span class="line">    click=<span class="string">&quot;@&#123;eventHandle.onclick&#125;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二级页面的绑定:&lt;include&gt;标签引用二级页面</span><br><span class="line"><span class="comment">//使用下述方法传递</span></span><br><span class="line">app:idol = <span class="string">&quot;@&#123;idol&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>自定义BindingAdapter</p><blockquote><p>加载网络图片<br>方法重载，加载本地图片<br>多参数重载</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">自定义binding</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1.自定义</span></span><br><span class="line"><span class="comment">//public class ImageviewBindingAdapter</span></span><br><span class="line"><span class="comment">//加载网络图片 image注解</span></span><br><span class="line"><span class="meta">@BindingAdapter</span> ( <span class="string">&quot;image&quot;</span>)</span><br><span class="line"><span class="keyword">public</span>. .<span class="keyword">static</span>..<span class="keyword">void</span>..set Image.(ImageView...imageView..tring..url)&#123;</span><br><span class="line"><span class="keyword">if</span>( !TextUtils.isEmpty (ur1))&#123;</span><br><span class="line">Picasso-get(<span class="number">0</span> Picasso</span><br><span class="line">.load (url) RequestCreator</span><br><span class="line">.placeholder (R.drawable.ic_launcher_background).into (imageview) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">imageView.setBackgroundColor (color . GRAY) ;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.layout绑定</span></span><br><span class="line">&lt;data&gt;</span><br><span class="line"> &lt;variable</span><br><span class="line"> name=<span class="string">&quot;networkImage&quot;</span></span><br><span class="line"> type=<span class="string">&quot;String&quot;</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">            </span><br><span class="line">&lt;Imageview</span><br><span class="line">android: id=<span class="string">&quot;@+id/imageView&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    app:image=&quot;</span>@ &#123;networkImage&#125;  <span class="comment">//image为注解</span></span><br><span class="line">    android: layout_width=<span class="string">&quot;300dip&quot;</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.绑定</span></span><br><span class="line">ActivityMainBinding binding = DataBingingUtil.setcontentView(<span class="keyword">this</span>,R.layout.activity_main);DataBindingUtil.setContentactivityMainBinding.setNetworkImage (<span class="string">&quot;https://gimg2.baidu.com/image_s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可选择</span></span><br><span class="line"><span class="meta">@BindingAdapter</span> (value = &#123; <span class="string">&quot;image&quot;</span>,<span class="string">&quot;defaultImageResource&quot;</span> &#125;, requireAll = <span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line">&lt;Imageview</span><br><span class="line">android: id=<span class="string">&quot;@+id/imageView&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    app:image=&quot;</span>@ &#123;networkImage&#125;  <span class="comment">//image为注解</span></span><br><span class="line">    app:<span class="keyword">default</span>=<span class="string">&quot;@ &#123;localImage&#125;</span></span><br><span class="line"><span class="string">    android: layout_width=&quot;</span><span class="number">300d</span>ip<span class="string">&quot;            </span></span><br></pre></td></tr></table></figure><p>双向绑定</p><blockquote><p>BaseObservable与ObservableField</p></blockquote><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_databinding_baseobservable.png" alt="Jetpack DataBinding BaseObservable"></p><p>BaseObservable方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> string userName;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span> <span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserViewModel对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> <span class="keyword">extends</span> <span class="title">Base0bservable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserViewModel</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = <span class="keyword">new</span> User ( userName: <span class="string">&quot;Jack&quot;</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变对象的值View变化    </span></span><br><span class="line"><span class="meta">@Bindable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getUserName</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user.userName ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当View变化时改变对象的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span> <span class="params">( String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; !userName. equals(user.userName) ) &#123;</span><br><span class="line">user. userName = userName;</span><br><span class="line">Log.d( tag: <span class="string">&quot;ning&quot;</span> , msg: <span class="string">&quot;set username :&quot;</span>+userName);</span><br><span class="line">        notifyPropertyChanged(BR. userName) ;<span class="comment">//通知对象的变化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;data&gt;</span><br><span class="line">&lt;variable</span><br><span class="line">name=<span class="string">&quot;userviewModel&quot;</span></span><br><span class="line">type=<span class="string">&quot;com.dongnaoedu.databinding4.UserviewModel&quot;</span> /&gt;</span><br><span class="line">&lt;/ data&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向绑定@=&#123;&#125;</span></span><br><span class="line">&lt;EditText</span><br><span class="line">android: id-<span class="string">&quot;e+id/editText&quot;</span></span><br><span class="line">android : layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android: layout height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android : ems=<span class="string">&quot;10&quot;</span></span><br><span class="line">android: inputType=<span class="string">&quot;textPersonName&quot;</span></span><br><span class="line">android : text=<span class="string">&quot;@=&#123;userviewModel.userName)&quot;</span></span><br><span class="line"></span><br><span class="line">ContentactivityMainBinding.userviewModel (<span class="keyword">new</span> UserViewModel());</span><br></pre></td></tr></table></figure><p>ObservableField方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ObservableField&lt;User&gt; userobservableField;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserViewModel</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User ( userName: <span class="string">&quot;Jack &quot;</span> ) ;</span><br><span class="line">userObservableField = <span class="keyword">new</span> ObservableField&lt;&gt; ();</span><br><span class="line">        userObservableField.set (user);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userObservableField.get ().userName;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span> <span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">Log.d( tag: <span class="string">&quot;ning&quot;</span> , msg: <span class="string">&quot;userObservableField: &quot;</span>+userName) ;</span><br><span class="line">        userObservableField.get ().userName = userName ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RecycleView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//item xml布局：databinding layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span> <span class="params">(NonNull ViewGroup parent,<span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">ItemBinding itemBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext (</span><br><span class="line">R.layout.item,</span><br><span class="line">parent,</span><br><span class="line">attachToParent: <span class="keyword">false</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyViewHolder (itemBinding) ;</span><br><span class="line">&#125;</span><br><span class="line">                                                                          </span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span> <span class="params">(<span class="meta">@NonNull</span> MyViewHolder holder，<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">Idol idol = idols.get (position) ;</span><br><span class="line">holder.itemBinding.setIdol (idol) ;</span><br><span class="line">&#125;</span><br><span class="line">                                                                          </span><br><span class="line"><span class="comment">//设置适配器</span></span><br><span class="line">ActivityMainBinding binding = DatabinfingUtil.setContentView(<span class="keyword">this</span>,R.layout.activity_main);</span><br><span class="line">binding.recycleView.setLayoutManager(<span class="keyword">new</span> LinearLayputManager(<span class="keyword">this</span>))</span><br><span class="line">binding.recycleView.setAdapetr(<span class="keyword">new</span> RecycleAdapter())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>篮球计分：ViewModel + LiveData + Databinding</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">viewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; bTeamScore;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title">getbTeamScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bTeamScore -= nul1)&#123;</span><br><span class="line">bTeamscore = <span class="keyword">new</span> MutableLiveData&lt;&gt;();bTeanscore.setvalue (<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> bTeamScore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bTeamAdd</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">saveLastscore() ;</span><br><span class="line">bTeamScore.setValue (bTeamScore.getValue ()+ i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span> <span class="params">()</span></span>&#123;</span><br><span class="line">aTeamscore.setValue (aLast);</span><br><span class="line">        bTeamScore.setValue(bLast) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xml：添加点击事件</span></span><br><span class="line">android: onClick=<span class="string">&quot;@&#123; ()-&gt;viewModel.undo ()&#125;&quot;</span> I</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主activity绑定binding</span></span><br><span class="line">ActivityMainBinding activityMainBinding m DataBindingUtil.setContentView( activity. <span class="keyword">this</span>,R.layout.acticity_main);</span><br><span class="line"><span class="comment">//设置viewmodel data</span></span><br><span class="line">MyViewWodel viewModel = <span class="keyword">new</span> ViewModelProvider ( owner. <span class="keyword">this</span>，<span class="keyword">new</span> ViewModelProvider.Android</span><br><span class="line">activityMainBinding.setViewModel (viewModel) ;</span><br><span class="line"><span class="comment">//感知生命周期</span></span><br><span class="line">activityMainBinding.setLifecycleowner(<span class="keyword">this</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DataBinding的优势</p><blockquote><p>不再需要findViewByld，项目更加简洁，可读性更高。<br>布局文件可以包含简单的业务逻辑。</p></blockquote><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_databinding_viewmodel.png" alt="Jetpack Databinding Viewmodel"></p><h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Room重要概念:</span><br><span class="line">Entity:实体类，对应的是数据库的一张表结构，使用注解@Entity标记&gt;</span><br><span class="line">Dao:包含访问一系列访问数据库的方法，使用注解@Dao标记。//Data Access Objects</span><br><span class="line">Database:数据库持有者，作为与应用持久化相关数据的底层连接的主要接入点。使用注解@Database标记，另外需满足以下条件:定义的类必须是一个继承于RoomDatabase的抽象类，在注解中需要定义与数据库相关联的实体类列表。包含一个没有参数的抽象方法并且返回一个Dao对象。</span><br></pre></td></tr></table></figure><p>app从Database得到get DAO,从DAO得到Entity，从Entity得到和设置对象值</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_room.png" alt="Jetpack Room"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.room: room-runtime: 2.2.5&#x27;</span></span><br><span class="line">//注解器：抽象类自动生成实现类</span><br><span class="line">annotationProcessor <span class="string">&#x27;androidx .room:room-compiler:2.2.5&#x27;</span></span><br></pre></td></tr></table></figure><p>Entity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> (tableName - <span class="string">&quot;student&quot;</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@PrimaryKey</span> (autoGenerate = <span class="keyword">true</span>)</span><br><span class="line">       <span class="meta">@ColumnInfo(name = &quot;id&quot;,typeAffinity = ColumnInfo.INTEGER)</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="meta">@ColumnInfo(name = &quot;name&quot;, typeAffinity = ColumnInfo.TEXT)</span></span><br><span class="line">       <span class="keyword">public</span> string name;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@columnInfo(name = &quot;name&quot;,typeAffinity = ColumnInfo.TEXT)</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">student</span> <span class="params">(<span class="keyword">int</span> id,String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">           <span class="keyword">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// Ignore注解 room会自动忽略此构造函数      </span></span><br><span class="line"><span class="meta">@Ignores</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">student</span> <span class="params">(string name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dao：增删查改接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span> <span class="params">(student. .- students)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletestudent</span> <span class="params">(student. . . students)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span> <span class="params">(Student . . . students)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span> ( <span class="string">&quot;SELECT *FROMstudent&quot;</span>)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">getAllstudent</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span> (<span class="string">&quot;SELECT * FROM student WHERE id = :id&quot;</span>)</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Database</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span> (entities = &#123;Student.class&#125;, version = <span class="number">1</span>, exportSchema = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> string DATABASE_NAME= <span class="string">&quot;my_db. db&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyDatabase mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> MyDatabase <span class="title">getInstance</span> <span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == nul1) &#123;</span><br><span class="line">mInstance = Room. databaseBuilder(context.getApplicationContext(),</span><br><span class="line">MyDatabase.class,</span><br><span class="line">DATABASE_NAME<span class="string">&#x27;).build() ;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return minstance;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">public abstract StudentDao getStudentDao ();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MyDatabase database = MyDatabase.getInstance (<span class="keyword">this</span>);</span><br><span class="line">studentDao = database.getStudentDao ( ) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mlnsert</span> <span class="params">(View view)</span></span>&#123;</span><br><span class="line">student s1 = <span class="keyword">new</span> Student ( name: <span class="string">&quot;Jack&quot;</span> , age: <span class="number">20</span>) ;</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student( name: <span class="string">&quot;Rose&quot;</span>,age: <span class="number">1</span> ;<span class="keyword">new</span> </span><br><span class="line">    InsertStudentTask (studentDao).execute (s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//room不允许在主线程执行数据库操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertStudentTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Student</span>, <span class="title">Void</span>,<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> studentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsertStudentTask</span> <span class="params">(StudentDao studentDao)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span> . studentDao - studentDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span> <span class="params">(Student. . . students)</span> </span>&#123;</span><br><span class="line">studentDao.insertStudent ( students) ;</span><br><span class="line">        rerurn <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进一步优化</p><blockquote><p>问题:每当数据库数据发生变化时，都需要开启一个工作线程去重新获取数据库中的数据。<br>解决:当数据发生变化时，通过LiveData通知View层，实现数据自动更新。</p></blockquote><p>Room+ViewModel+LiveData</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack_viewmodel_room_livedata.png" alt="Jetpack Viewmodel Room Livedata"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Repository:通过Repository操作数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">studentRepository</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentRepository</span> <span class="params">(Context context)</span></span>&#123;</span><br><span class="line">MyDatabase database = MyDatabase.getInstance ( context) ;</span><br><span class="line">        <span class="keyword">this</span>.studentDao = database.getStudentDao ( ) ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStudent</span> <span class="params">(Student. . . students)</span></span>&#123;</span><br><span class="line"><span class="keyword">new</span> InsertStudentTask(studentDao) .execute (students);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InsertStudentTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Student</span>, <span class="title">Void</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> studentDao studentDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InsertStudentTask</span><span class="params">(StudentDao studentDao)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.studentDa</span><br><span class="line"></span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span> <span class="params">(Student. . . students)</span> </span>&#123;</span><br><span class="line">studentDao.insertstudent (students) ;</span><br><span class="line"><span class="keyword">return</span> nul1;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewModel:ViewModel传递上下文对象需要用AndroidViewModel</span></span><br><span class="line"><span class="comment">//ViewModel保存数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">studentViewModel</span> <span class="keyword">extends</span> <span class="title">AndroidViewModel</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> studentRepository repository ;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentViewModel</span> <span class="params">( <span class="meta">@NonNull</span> Application application)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(application) ;</span><br><span class="line"><span class="keyword">this</span>.repository = <span class="keyword">new</span> StudentRepository(application) ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStudent</span> <span class="params">(Student. . . students)</span> </span>&#123;</span><br><span class="line">repository.insertStudent(students) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity只需要和ViewModel交互即可</span></span><br><span class="line">studentViewModel = <span class="keyword">new</span> ViewModelProvider ( owner: <span class="keyword">this</span>, <span class="keyword">new</span></span><br><span class="line">ViewModelProvider.AndroidviewModelFactory(getApplication()).get(StudentViewModel.class)</span><br><span class="line"><span class="comment">//Livedata自动更新</span></span><br><span class="line">studentViewModel.getAllStudentsLive () .observe ( owner: <span class="keyword">this</span>，<span class="keyword">new</span> Observer&lt;List&lt;Student&gt;&gt;()</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span> <span class="params">(List&lt;Student&gt; students)</span></span>&#123;</span><br><span class="line">adapter.setstudents ( students ) ;</span><br><span class="line">adapter.notifyDataSetChanged ( );</span><br><span class="line">&#125;);</span><br><span class="line"> &#125;</span><br><span class="line">                                          </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mInsert</span> <span class="params">(View view)</span> </span>&#123;</span><br><span class="line">Student s1 = <span class="keyword">new</span> student ( name: <span class="string">&quot;Jack&quot;</span>, age: <span class="number">20</span>) ;</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student ( name: <span class="string">&quot;Rose&quot;</span>, age: <span class="number">18</span>);</span><br><span class="line">    studentviewModel .insertStudent (s1,s2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>room版本升级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造Migration</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_1_2 = <span class="keyword">new</span> Migration (<span class="number">1</span>,<span class="number">2</span>)&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span> <span class="params">(<span class="meta">@NonNull</span> SupportSQLiteDatabase database)</span></span>&#123;</span><br><span class="line">database.execSQL ( <span class="string">&quot;ALTERTABLE student ADD COLUMN sex INTEGER NOT NULLDEFAULT 1&quot;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>添加addMigrations</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> MyDatabase <span class="title">getInstance</span> <span class="params">(Context context)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( mInstance -= nul1)&#123;</span><br><span class="line">mInstance = Room. databaseBuilder(context.getapplicationContext(),</span><br><span class="line">                                          MyDatabase.class,</span><br><span class="line">                                          DATABASE_NAME)</span><br><span class="line">.addMigrations (MIGRATION_1_2,MIGRATION_2_3)</span><br><span class="line">            .build () ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mlnstance;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>修改注解</span><br><span class="line"><span class="meta">@Database</span> (entities = &#123;Student.class&#125;, version = <span class="number">2</span>, exportSchema = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>使用Migration升级数据库</p><blockquote><p>问题:如果用户设备上数据库版本为1，而当前要安装的App数据库版本为3，怎么办?<br>Room会先判断当前有没有直接从1到3的升级方案，如果有，就直接执行从1到3的升级方案，如果没有，那么Room会按照顺序先后执行Migration(1,2)、Migration(2,3)以完成升级。</p></blockquote><h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Navigation的主要元素</span><br><span class="line">1.Navigation Graph，一种新的XML资源文件，包含应用程序所有的页面以及页面间的关系。</span><br><span class="line">2.NavHostFragment，一个特殊的Fragment，可以将它看作是其他Fragment的容器，Navigation Graph中的Fragment正是通过NavHostFragment进行展示的。</span><br><span class="line">3.NavController，用于在代码中完成Navigation Graph中具体的页面切换工作。</span><br><span class="line"></span><br><span class="line">他们三责之间的关系当你想切换Fragment时，使用NavController对象，告诉它你想要去Navigation Graph中的哪个Fragment,NavController会将你想去的Fragment展示NavHostFragment中。</span><br><span class="line"></span><br><span class="line">创建顺序：</span><br><span class="line">Fragment -&gt; Navigation Graph -&gt; main_layout:NavHostFragment -&gt; -&gt;</span><br><span class="line"></span><br><span class="line">NavController navController = Navigation.findNavController( activity: this，R.id.fragment);</span><br><span class="line">NavigationUI.setupActionBarWithNavController( activity: this, navController);</span><br></pre></td></tr></table></figure><p>NavigationUl的作用</p><blockquote><p>Fragment的切换，除了Fragment页面本身的切换，通常还伴有App bar的变化。为了方便统一管理，Navigation组件引入了NavigationUI类。</p></blockquote><p>更多支持<br>App bar</p><blockquote><p>ActionBar<br>Toolbar<br>CollapsingToolbarLayout</p></blockquote><p>menu</p><blockquote><p>抽屉菜单 (DrawLayout+Navigation View)<br>底部菜单(（BottomNavigationView)</p></blockquote><h2 id="Jetpack-Kotlin-MVVM项目"><a href="#Jetpack-Kotlin-MVVM项目" class="headerlink" title="Jetpack+Kotlin+MVVM项目"></a>Jetpack+Kotlin+MVVM项目</h2><p>采用 <a href="https://developer.android.com/jetpack">Jetpack</a> +Kotlin <a href="https://github.com/Kotlin/kotlinx.coroutines">协程</a>实现的 MVVM 架构项目：<a href="https://github.com/VIPyinzhiwei/Eyepetizer">Eyepetizer)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JetPack架构组件:ViewModel、LiveData、ViewBinding、DataBinding、LifeCycle、Room等的介绍、使用场景和使用方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
    <category term="ViewModel" scheme="http://yoursite.com/tags/ViewModel/"/>
    
    <category term="DataBinding" scheme="http://yoursite.com/tags/DataBinding/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack系列库简介</title>
    <link href="http://yoursite.com/article/23f0b0f3.html"/>
    <id>http://yoursite.com/article/23f0b0f3.html</id>
    <published>2022-05-11T11:24:50.000Z</published>
    <updated>2025-10-22T03:11:19.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JetPack是Google推出的一些库的集合，是Android基础支持库SDK以外的部分，包含了组件、工具、架构方案等，最核心的出发点就是帮助开发者快速构建出稳定、高性能、测试友好同时向后兼容的APP。</p></blockquote><a id="more"></a><h3 id="什么是Jetpack"><a href="#什么是Jetpack" class="headerlink" title="什么是Jetpack"></a>什么是Jetpack</h3><p>2018年谷歌I/O 发布了一系列辅助Android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。大体上，JetPack是Google推出的一些库的集合，是Android基础支持库SDK以外的部分，包含了组件、工具、架构方案等，开发者可以自主按需选择接入具体的哪个库。</p><ul><li><p>Goole IO 2017：Google 开始推出Architecture Component, ORM库Room, 用户生命周期管理的ViewModel/ListData。</p></li><li><p>Goole IO 2018：将Support lib 更名为androidx，Google将许多正确的方案集中起来，以高效的开发Android APP。</p></li></ul><p>以上种种，现在统称为JetPack.其最核心的出发点就是帮助开发者快速构建出稳定、高性能、测试友好同时向后兼容的APP。</p><p>使用Jetpack的优势：</p><ul><li>加快开发速度</li><li>消除样板代码</li><li>编译功能强大的优质应用</li></ul><h3 id="Jetpack的组成"><a href="#Jetpack的组成" class="headerlink" title="Jetpack的组成"></a>Jetpack的组成</h3><p>Android Jetpack 组件覆盖以下 4 个方面：Foundation （基础组件）、Architecture（架构组件）、Behavior（行为组件）、UI（界面组件）。</p><p><img src="https://gitcode.net/weixin_44008788/images/-/raw/master/hexo/jetpack.png" alt="Android Jetpack"></p><ol><li>基础组件</li></ol><p>AppCompat：使得支持较低的 Android 版本。从以前继承 Activity 到现在继承 AppCompatActivity 就是属于这一部分<br>Android KTX：Kotlin 的扩展支持库<br>Multidex：多 dex 文件支持<br>Test：测试支持库</p><ol start="2"><li>架构组件</li></ol><p>Data Binding：MVVM 的一种实践<br>Lifecycles：管理你的 Activity 和 Fragment 生命周期<br>LiveData：通过观察者模式感知数据变化，类比 RxJava<br>Navigation：处理 Fragment 导航相关逻辑<br>Paging：分页数据加载方案<br>Room：官方 ORM 库<br>ViewModel：通过数据驱动 V 视图发生改变<br>WorkManager：管理后台任务</p><ol start="3"><li>行为组件</li></ol><p>DownloadManager：管理下载任务<br>Media App：多媒体播放和一些向后兼容的API。主要包含 MediaPlayer 和 ExoPlayer<br>Notifications：提供向后兼容的通知 API，支持 Wear 和 Auto<br>Permissions：权限管理，这个应该都接触过。用于检查和请求应用权限<br>Settings：Preference 相关 API。基本每个应用都会用到<br>Share Action：提供分享操作。这块在国内使用的不多，都是自己封装或者采用第三方方案<br>Slices：可以让应用通过外部（其他 APP）显示 APP 界面（通过设备自带的搜索，语音助手等）</p><ol start="4"><li>界面组件</li></ol><p>Animations and Transitions：动画，界面转场等<br>Auto：针对车辆的标准化界面和模式<br>Emoji：表情符号相关<br>Fragment：基础概念<br>Layout：基础概念<br>Palette-Colors：调色板<br>TV：Android TV 开发相关<br>Wear：可穿戴设备（目前主要是手表）开发相关</p><h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><p><a href="https://blog.csdn.net/qq_34519487/article/details/103963912">https://blog.csdn.net/qq_34519487/article/details/103963912</a></p><p><a href="http://www.xiangxueketang.cn/enjoy/removal/article_6?sdclkid=AL2G15oN1526A6D6bo&amp;bd_vid=7921788666531507771">http://www.xiangxueketang.cn/enjoy/removal/article_6?sdclkid=AL2G15oN1526A6D6bo&amp;bd_vid=7921788666531507771</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JetPack是Google推出的一些库的集合，是Android基础支持库SDK以外的部分，包含了组件、工具、架构方案等，最核心的出发点就是帮助开发者快速构建出稳定、高性能、测试友好同时向后兼容的APP。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>关于设计UI/UX/UED职能解释</title>
    <link href="http://yoursite.com/article/198ad0b7.html"/>
    <id>http://yoursite.com/article/198ad0b7.html</id>
    <published>2022-05-10T10:00:46.000Z</published>
    <updated>2025-10-22T03:11:19.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>百度百科上说UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。 关于设计或者产品经理或者开发者来说，我们经常听到UI/UX/UED/UCD等专有名词，却总是搞不清楚他们的区别，这里将说明他们各自的含义。百度百科上说UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。</p></blockquote><a id="more"></a><h2 id="UI-UID"><a href="#UI-UID" class="headerlink" title="UI/UID"></a>UI/UID</h2><p><strong>UI：User Interface  用户界面 / UID：User Interface Design 用户界面设计</strong></p><p>用户界面其实是一个比较广泛的概念，指人和机器互动过程中的界面，以车为例子，方向盘、仪表盘、换档器等都属于用户界面。</p><ul><li>现在一般把屏幕上显示的图形用户界面（GUI ：Graphic User Interface）都简单称为UI。</li><li>现在一般所说的UI设计师，也即是指GUI设计师。</li><li>用户界面设计（UID）不仅仅是做”漂亮的界面”，所以不可避免的会涉及到交互设计。所以广义来说，界面设计包含交互设计。  </li></ul><h2 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h2><p><strong>ID：Interaction design 交互设计</strong></p><p>交互指任何机器互动的过程，交互设计通过了解人的心理、目标和期望，使用有效的交互方式来让整个过程可用、易用。</p><ul><li>交互设计的主要对象是人机界面（UI），但不仅限于图形界面（GUI）。 </li><li>为了达到目标，交互设计师需要关注心理、文化、人体工程等许多方面的内容。</li></ul><h2 id="UE-UX"><a href="#UE-UX" class="headerlink" title="UE/UX"></a>UE/UX</h2><p><strong>UE/UX： User Experience 用户体验</strong> </p><p>用户体验指用户在使用产品过程中的个人主观感受。</p><ul><li>关注用户使用前、使用过程中、使用后的整体感受，包括行为、情感、成就等各个方面。 </li><li>用户体验是整体感受，所以不仅仅来自于用户界面，那只是其中的一部分。</li></ul><h2 id="UED"><a href="#UED" class="headerlink" title="UED"></a>UED</h2><p><strong>UED： User Experience Design 用户体验设计</strong></p><p>用户体验是个人主观感受，但是共性的体验是可以经由良好的设计提升的。用户体验设计旨在提升用户使用产品的体验。</p><ul><li>互联网企业中，一般将视觉界面设计，交互设计和前端设计都归为用户体验设计。 </li><li>但实际上用户体验设计贯穿于整个产品设计流程，是必然涉及到的，只是重视与否。 </li><li>一名优秀的用户体验设计师，实际上需要对界面、交互和实现技术都有深入的理解。</li></ul><h2 id="UCD"><a href="#UCD" class="headerlink" title="UCD"></a>UCD</h2><p><strong>UCD：User Centered Design 以用户为中心的设计</strong></p><p>UCD是一种设计模式，思维。强调在产品设计过程中，从用户角度出发来进行设计，用户优先。</p><ul><li>产品设计有个BTU三圈图（Business, Technique, User），即一个好的产品，应该兼顾商业盈利，技术实现和用户需求。</li><li>无论是B、T还是U为优先进入产品设计，都可以设计出好的产品。UCD只是强调用户优先。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;百度百科上说UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。 关于设计或者产品经理或者开发者来说，我们经常听到UI/UX/UED/UCD等专有名词，却总是搞不清楚他们的区别，这里将说明他们各自的含义。百度百科上说UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="UI设计" scheme="http://yoursite.com/categories/UI%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
    <category term="UX" scheme="http://yoursite.com/tags/UX/"/>
    
    <category term="UED" scheme="http://yoursite.com/tags/UED/"/>
    
  </entry>
  
</feed>
